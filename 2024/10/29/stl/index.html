<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++ STL常用内容总结 | Zenith</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/yellow.jpg');
 --light-background: url('/img/green.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><script>(function () {  
    var a_idx = 0;  
    window.onclick = function (event) {  
        var a = new Array("这一路上走走停停","顺着少年漂流的痕迹","迈出车站的前一刻","竟有些犹豫","不禁笑这近乡情怯","仍无法避免","而长野的天","依旧那么暖","风吹起了从前",
        "从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不得真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","逆着光行走 任风吹雨打","短短的路走走停停","也有了几分的距离","不知抚摸的是故事","还是段心情","也许期待的不过是","与时间为敌","再次见到你","微凉晨光里","笑得很甜蜜","从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不做真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","晚风吹起你鬓间的白发","抚平回忆留下的疤","你的眼中 明暗交杂 一笑生花","暮色遮住你蹒跚的步伐","走进床头藏起的画","画中的你 低着头说话","我仍感叹于世界之大","也沉醉于儿时情话","不剩真假 不做挣扎 无谓笑话","我终将青春还给了她","连同指尖弹出的盛夏","心之所动 就随风去了","以爱之名 你还愿意吗",
        "这一路上走走停停","顺着少年漂流的痕迹","迈出车站的前一刻","竟有些犹豫","不禁笑这近乡情怯","仍无法避免","而长野的天","依旧那么暖","风吹起了从前",
        "从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不得真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","逆着光行走 任风吹雨打","短短的路走走停停","也有了几分的距离","不知抚摸的是故事","还是段心情","也许期待的不过是","与时间为敌","再次见到你","微凉晨光里","笑得很甜蜜","从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不做真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","晚风吹起你鬓间的白发","抚平回忆留下的疤","你的眼中 明暗交杂 一笑生花","暮色遮住你蹒跚的步伐","走进床头藏起的画","画中的你 低着头说话","我仍感叹于世界之大","也沉醉于儿时情话","不剩真假 不做挣扎 无谓笑话","我终将青春还给了她","连同指尖弹出的盛夏","心之所动 就随风去了","以爱之名 你还愿意吗",
        "这一路上走走停停","顺着少年漂流的痕迹","迈出车站的前一刻","竟有些犹豫","不禁笑这近乡情怯","仍无法避免","而长野的天","依旧那么暖","风吹起了从前",
        "从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不得真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","逆着光行走 任风吹雨打","短短的路走走停停","也有了几分的距离","不知抚摸的是故事","还是段心情","也许期待的不过是","与时间为敌","再次见到你","微凉晨光里","笑得很甜蜜","从前初识这世间","万般流连","看着天边似在眼前","也甘愿赴汤蹈火去走它一遍","如今走过这世间","万般流连","翻过岁月不同侧脸","措不及防闯入你的笑颜","我曾难自拔于世界之大","也沉溺于其中梦话","不做真假 不做挣扎 不惧笑话","我曾将青春翻涌成她","也曾指尖弹出盛夏","心之所动 且就随缘去吧","晚风吹起你鬓间的白发","抚平回忆留下的疤","你的眼中 明暗交杂 一笑生花","暮色遮住你蹒跚的步伐","走进床头藏起的画","画中的你 低着头说话","我仍感叹于世界之大","也沉醉于儿时情话","不剩真假 不做挣扎 无谓笑话","我终将青春还给了她","连同指尖弹出的盛夏","心之所动 就随风去了","以爱之名 你还愿意吗",
        "曾经有人让我听这首歌","可是那时的我还不谙情事","也没有真正认真的听完整首歌","直到后来","分开后再听时才发现","原来我错过了","曾经的阿芒","你还好吗");  

        var heart = document.createElement("p"); // 创建p元素，这里从b改为p  
        heart.onselectstart = function() { return false; }; // 简化防止拖动的代码  

        document.body.appendChild(heart).textContent = a[a_idx]; // 使用textContent代替innerHTML，因为这里只是文本  
        a_idx = (a_idx + 1) % a.length;  
        heart.style.cssText = "position: fixed;left:-100%;"; // 初始位置  

        var f = 16, // 字体大小  
            x = event.clientX - f / 2, // 横坐标  
            y = event.clientY - f, // 纵坐标  
            c = randomColor(), // 随机颜色  
            a = 1, // 透明度  
            s = 1.2; // 放大缩小比例  

        var timer = setInterval(function () { // 添加定时器  
            if (a <= 0) {  
                document.body.removeChild(heart);  
                clearInterval(timer);  
            } else {  
                heart.style.cssText = "font-size:" + f + "px;cursor: default;position: fixed;color:" +  
                    c + ";left:" + x + "px;top:" + y + "px;opacity:" + a + ";transform:scale(" +  
                    s + ");";  

                y--;  
                a -= 0.016;  
                s += 0.002;  
            }  
        }, 15);  
    }  

    // 随机颜色函数  
    function randomColor() {  
        //- return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";  
        return "(255,240,245)";
    }  
}());</script><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">首页</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">关于</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">归档</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>C++ STL常用内容总结</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-10-28T16:00:00.000Z" id="date"> 2024-10-29</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-11-03T15:52:39.315Z" id="updated"> 2024-11-03</time></div></span><br><span>文章总字数: <div class="control">12.3k</div></span><br><span>预计阅读时间: <div class="control">52 分钟</div></span></div></div><hr><div id="post-content"><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这是关于C++ STL常用内容总结</p>
<p><strong>强调使用方法</strong>，并不强调原理</p>
<p>本篇博客是我用于个人学习总结用的</p>
<span id="more"></span>

<p>大部分内容来源于<a target="_blank" rel="noopener" href="https://wyqz.top/p/870124582.html">网络</a>和书本，因为是个人整理复习用所以就先不加了，如果后期看的人多我会加上的</p>
<p>因为还有挺多课的，而且还有比赛和组里的任务，所以可能会不定期不定量更新</p>
<p>内容可能有不全的，或错误的，欢迎批评指正</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>主要包含下面几个STL函数</p>
<blockquote>
<ul>
<li>vector 动态数组</li>
<li>stack 栈</li>
<li>queue 队列</li>
<li>deque 双端队列</li>
<li>priority_queue 优先队列</li>
<li>map 映射</li>
<li>set 集合</li>
<li>pair 二元组</li>
<li>string 字符串</li>
<li>bitset</li>
<li>array 数组</li>
<li>tuple 元组</li>
<li>……</li>
</ul>
</blockquote>
<p><del>这是目前的安排，计划在11.03前赶完，因为11.03要比赛，11.10还要考<a href="https://smallgoodgood.top/hide/discrete-mathematics">离散</a>，中间还要把几次练习赛的题补了。（好忙）</del></p>
<p>补：比赛也算是拿了银奖了</p>
<span class="hide"><object><p>被高中生爆杀</p></object></span>

<p>目前（11.02）已将上述STL函数整理完成，算是按时提前完成了吧</p>
<p>后续会增加一些常用的STL函数，例如sort等</p>
<p>暂定在12.20前完成后续的补充</p>
<p>话不多说，接下来进入正题吧</p>
<h1 id="STL函数总结"><a href="#STL函数总结" class="headerlink" title="STL函数总结"></a>STL函数总结</h1><h2 id="vector-动态数组"><a href="#vector-动态数组" class="headerlink" title="vector 动态数组"></a>vector 动态数组</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>vector</code>为可变长数组（动态数组），定义的<code>vector</code>数组可以随时添加数值和删除元素。</p>
<blockquote>
<p>注意：<strong>在局部区域中（比如局部函数里面）开vector数组，是在 堆空间 里面开的。</strong></p>
<p>在局部区域开 数组 是在 栈空间 开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p>
<p>故局部区域 <strong>不可以</strong> 开大长度数组，但是可以开大长度<code>vector</code>。</p>
</blockquote>
<ul>
<li><p>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>一维初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a; <span class="hljs-comment">//定义了一个名为a的一维数组,数组存储int类型数据</span><br>vector&lt;<span class="hljs-type">double</span>&gt; b;<span class="hljs-comment">//定义了一个名为b的一维数组，数组存储double类型数据</span><br>vector&lt;node&gt; c;<span class="hljs-comment">//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>指定<strong>长度</strong>和<strong>初始值</strong>的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">// 定义一个长度为n的数组，初始值默认为0，下标范围 [0, n - 1]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//定义一个长度为n的数组，下标范围 [0, n - 1], v[0] 到 v[n - 1]所有的元素初始值均为1</span><br><span class="hljs-comment">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化中有多个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//数组a中有五个元素，数组长度就为5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>拷贝初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">// 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; c = a; <span class="hljs-comment">// 也是拷贝初始化,c和a是完全一样的数组</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>二维初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义第一维固定长度为5，第二维可变化的二维数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v[<span class="hljs-number">5</span>];<span class="hljs-comment">//定义可变长二维数组</span><br><span class="hljs-comment">//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素</span><br><span class="hljs-comment">//第一维固定长度为5，第二维长度可以改变</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>vector&lt;int&gt; v[5]</code>可以这样理解：长度为5的v数组，数组中存储的是<code>vector&lt;int&gt; </code>数据类型，而该类型就是数组形式，故<code>v</code>为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">v[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//第二行尾部增加一个元素 2</span><br>v[<span class="hljs-number">2</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//第三行尾部增加一个元素 3</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>行列均可变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化二维均可变长数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; v;<span class="hljs-comment">//定义一个行和列均可变的二维数组</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>应用：可以在<code>v</code>数组里面装多个数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; t1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; t2&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>v.<span class="hljs-built_in">push_back</span>(t1);<br>v.<span class="hljs-built_in">push_back</span>(t2);<br>v.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;) <span class="hljs-comment">// &#123;3, 4, 5, 6&#125;可以作为vector的初始化,相当于一个无名vector</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>行列长度均固定</p>
<blockquote>
<p><code>n + 1</code>行  <code>m + 1</code>列  初始值为0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//定义一个长度为 n+1 的数组，下标范围 [0, n - 1], a[0] 到 a[n - 1]所有的元素初始值均为vector&lt;int&gt;(m + 1, 0)</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>c++17及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 声明一个int类型动态数组，初识元素自己指定</span><br><span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法函数"><a href="#方法函数" class="headerlink" title="方法函数"></a>方法函数</h3><p>个人认为vector和数组的差距首先是存储位置不一样，vector是在堆空间，数组是在栈空间，其次就是vector中有许多方法函数，这些方法函数可以极大的方便我们编程，解题，不仅仅vector是这样的，其他STL函数也是。但是因为我才刚刚入门，这只是我的一种感觉，具体怎么等我多学一些，学深一些再来补充。先占个坑。</p>
<p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p>
<p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p>
<table>
<thead>
<tr>
<th align="center"><strong>代码</strong></th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c.front()</td>
<td align="center">返回第一个数据O ( 1 )</td>
</tr>
<tr>
<td align="center">c.back()</td>
<td align="center">返回数组中的最后一个数据 O ( 1 )</td>
</tr>
<tr>
<td align="center">c.pop_back()</td>
<td align="center">删除最后一个数据O ( 1 )</td>
</tr>
<tr>
<td align="center">c.push_back(element)</td>
<td align="center">在尾部加一个数据O ( 1 )</td>
</tr>
<tr>
<td align="center">c.size()</td>
<td align="center">返回实际数据个数（unsigned类型）O ( 1 )</td>
</tr>
<tr>
<td align="center">c.clear()</td>
<td align="center">清除元素个数O ( N )，N为元素个数</td>
</tr>
<tr>
<td align="center">c.resize(n, v)</td>
<td align="center">改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0</td>
</tr>
<tr>
<td align="center">c.insert(it, x)</td>
<td align="center">向任意迭代器it（通俗来说就是地址）插入一个元素x ，O ( N )</td>
</tr>
<tr>
<td align="center">c.erase(first,last)</td>
<td align="center">删除[first,last)的所有元素，O ( N )</td>
</tr>
<tr>
<td align="center">c.begin()</td>
<td align="center">返回首元素的迭代器（通俗来说就是地址）O ( 1 )</td>
</tr>
<tr>
<td align="center">c.end()</td>
<td align="center">返回最后一个元素后一个位置的迭代器（地址）O ( 1 )</td>
</tr>
<tr>
<td align="center">c.empty()</td>
<td align="center">判断是否为空，为空返回真，反之返回假 O ( 1 )</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li><p><code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong></p>
</li>
<li><p>使用 <code>vi.resize(n, v)</code> 函数时，若 <code>vi</code> 之前指定过大小为 <code>pre</code></p>
<ul>
<li><code>pre &gt; n</code> ：即数组大小变小了，数组会保存前 <code>n</code> 个元素，前 <code>n</code> 个元素值为原来的值，不都变为 <code>v</code></li>
<li><code>pre &lt; n</code> ：即数组大小变大了，数组会在后面插入 <code>n - pre</code> 个值为 <code>v</code> 的元素</li>
</ul>
<p>也就是说，这个初始值 <code>v</code> 只对新插入的元素生效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: a) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-built_in">out</span>(a); <span class="hljs-comment">// 1 1 1 1 1</span><br>	a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">out</span>(a); <span class="hljs-comment">// 1 1 1 1 1 2 2 2 2 2</span><br>	a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">out</span>(a); <span class="hljs-comment">// 1 1 1</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><strong>排序</strong></p>
<p>使用<code>sort</code>排序要： <code>sort(c.begin(), c.end());</code></p>
<blockquote>
<p><code>sort()</code>为STL函数，请参考本文最后面STL函数系列。</p>
</blockquote>
<p>对所有元素进行排序，如果要对指定区间进行排序，可以对<code>sort()</code>里面的参数进行加减改动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对[1, n]区间进行从小到大排序</span><br></code></pre></td></tr></table></figure>

<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>共三种方法：</p>
<ul>
<li><strong>下标法</strong> ： 和普通数组一样</li>
</ul>
<p>注意：一维数组的下标是从 <code>0</code> 到 <code>v.size()-1</code> ，访问之外的数会出现越界错误</p>
<ul>
<li><p><strong>迭代器法</strong> ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi; <span class="hljs-comment">//定义一个vi数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vi.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//声明一个迭代器指向vi的初始位置</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用auto</strong> ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）</p>
</li>
</ul>
<h4 id="下标访问"><a href="#下标访问" class="headerlink" title="下标访问"></a>下标访问</h4><p>直接和普通数组一样进行访问即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//添加元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	vi.<span class="hljs-built_in">push_back</span>(i);<br>	<br><span class="hljs-comment">//下标访问 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	cout &lt;&lt; vi[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="迭代器访问"><a href="#迭代器访问" class="headerlink" title="迭代器访问"></a>迭代器访问</h4><p>类似指针，迭代器就是充当指针的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//迭代器访问</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;   <br><span class="hljs-comment">// 相当于声明了一个迭代器类型的变量it</span><br><span class="hljs-comment">// 通俗来说就是声明了一个指针变量</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>方法一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vi.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	cout &lt;&lt; *(it + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = vi.<span class="hljs-built_in">begin</span>(); it != vi.<span class="hljs-built_in">end</span>();it ++)<br>	cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">//vi.end()指向尾元素地址的下一个地址</span><br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">auto</span> it = vi.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != vi.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    it++;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。</p>
<p><code>auto</code> 能够自动识别并获取类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1. 输入</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: a) &#123;<br>    cin &gt;&gt; x; <span class="hljs-comment">// 可以进行输入，注意加引用</span><br>&#125;<br><span class="hljs-comment">// for (auto &amp;x: a)：这是一个范围for循环，用于遍历向量a中的每个元素。auto关键字自动推导变量x的类型，这里x的类型将是int&amp;（整数的引用），因为我们在循环中使用了引用&amp;。使用引用的好处是可以直接修改向量中的元素值。</span><br><span class="hljs-comment">// 2. 输出</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">12</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">241</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : v) &#123;<br>	cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 12 241</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>vector</code>注意：</p>
<ul>
<li><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价，与指针类似。</li>
<li><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</li>
</ul>
</blockquote>
<h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件需要添加</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//声明</span><br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br>stack&lt;string&gt; s;<br>stack&lt;node&gt; s;<span class="hljs-comment">//node是结构体类型</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法函数-1"><a href="#方法函数-1" class="headerlink" title="方法函数"></a>方法函数</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.push(ele)</td>
<td align="center">元素ele入栈，增加元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">s.pop()</td>
<td align="center">移除栈顶元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">s.top()</td>
<td align="center">取得栈顶元素（但不删除）O ( 1 )</td>
</tr>
<tr>
<td align="center">s.empty()</td>
<td align="center">检测栈内是否为空，空为真 O ( 1 )</td>
</tr>
<tr>
<td align="center">s.size()</td>
<td align="center">返回栈内元素的个数 O ( 1 )</td>
</tr>
</tbody></table>
<h3 id="栈遍历"><a href="#栈遍历" class="headerlink" title="栈遍历"></a>栈遍历</h3><h4 id="栈遍历-1"><a href="#栈遍历-1" class="headerlink" title="栈遍历"></a>栈遍历</h4><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) st.<span class="hljs-built_in">push</span>(i);<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> tp = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 栈顶元素</span><br>    st.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组模拟栈进行遍历"><a href="#数组模拟栈进行遍历" class="headerlink" title="数组模拟栈进行遍历"></a>数组模拟栈进行遍历</h4><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p>
<blockquote>
<p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p>
</blockquote>
<p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 栈 从左至右为栈底到栈顶</span><br><span class="hljs-type">int</span> tt = <span class="hljs-number">-1</span>; <span class="hljs-comment">// tt 代表栈顶指针,初始栈内无元素，tt为-1</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>	<span class="hljs-comment">//入栈 </span><br>	s[++tt] = i;<br>&#125;<br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> top_element = s[tt--]; <br><br><span class="hljs-comment">//入栈操作示意</span><br><span class="hljs-comment">//  0  1  2  3  4  5  </span><br><span class="hljs-comment">//                tt</span><br><span class="hljs-comment">//出栈后示意</span><br><span class="hljs-comment">//  0  1  2  3  4 </span><br><span class="hljs-comment">//              tt</span><br></code></pre></td></tr></table></figure>

<h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>队列是一种先进先出的数据结构。</p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p><em>定义初始化</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义初始化</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法函数-2"><a href="#方法函数-2" class="headerlink" title="方法函数"></a>方法函数</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">q.front()</td>
<td align="center">返回队首元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">q.back()</td>
<td align="center">返回队尾元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">q.push(element)</td>
<td align="center">尾部添加一个元素element 进队O ( 1 )</td>
</tr>
<tr>
<td align="center">q.pop()</td>
<td align="center">删除第一个元素 出队 O ( 1 )</td>
</tr>
<tr>
<td align="center">q.size()</td>
<td align="center">返回队列中元素个数，返回值类型unsigned int O ( 1 )</td>
</tr>
<tr>
<td align="center">q.empty()</td>
<td align="center">判断是否为空，队列为空，返回true O ( 1 )</td>
</tr>
</tbody></table>
<h3 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h3><p>使用<code>q[]</code>数组模拟队列</p>
<p><code>hh</code>表示队首元素的下标，初始值为<code>0</code></p>
<p><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p>
<blockquote>
<p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>,tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//	入队 </span><br>	q[++tt] = <span class="hljs-number">1</span>;<br>	q[++tt] = <span class="hljs-number">2</span>; <br><span class="hljs-comment">//	将所有元素出队 </span><br>	<span class="hljs-keyword">while</span>(hh &lt;= tt) &#123;<br>		<span class="hljs-type">int</span> t = q[hh++];<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,t);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure>

<h2 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque  双端队列"></a>deque  双端队列</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>首尾都可插入和删除的队列为双端队列。</p>
<ul>
<li><p><em>头文件</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//添加头文件<br>#include&lt;deque&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化定义</span><br>deque&lt;<span class="hljs-type">int</span>&gt; dq;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法函数-3"><a href="#方法函数-3" class="headerlink" title="方法函数"></a>方法函数</h3><blockquote>
<p>注意双端队列的常数比较大。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">push_back(x)&#x2F;push_front(x)</td>
<td align="center">把x插入队尾后 &#x2F; 队首 O ( 1 )</td>
</tr>
<tr>
<td align="center">back()&#x2F;front()</td>
<td align="center">返回队尾 &#x2F; 队首元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">pop_back() &#x2F; pop_front()</td>
<td align="center">删除队尾 &#x2F; 队首元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">erase(iterator it)</td>
<td align="center">删除双端队列中的某一个元素</td>
</tr>
<tr>
<td align="center">erase(iterator first,iterator last)</td>
<td align="center">删除双端队列中<code>[first,last)</code>中的元素</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">判断deque是否空 O ( 1 )</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回deque的元素数量 O ( 1 )</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">清空deque</td>
</tr>
</tbody></table>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>deque可以进行排序</p>
<blockquote>
<p>双端队列排序一般不用，感觉毫无用处，使用其他<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=STL&spm=1001.2101.3001.7020">STL</a>依然可以实现相同功能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//从小到大<br>sort(q.begin(), q.end())<br>//从大到小排序<br>sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型<br>sort(q.begin(), q.end(), greater());//高版本C++才可以用<br></code></pre></td></tr></table></figure>

<h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p>
<p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p>
<p>它的底层是通过<strong>堆</strong>来实现的。</p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化定义</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">q.top()</td>
<td align="center">访问队首元素 O ( 1 )</td>
</tr>
<tr>
<td align="center">q.push()</td>
<td align="center">入队 O ( l o g N )</td>
</tr>
<tr>
<td align="center">q.pop()</td>
<td align="center">堆顶（队首）元素出队 O ( l o g N )</td>
</tr>
<tr>
<td align="center">q.size()</td>
<td align="center">队列元素个数 O ( 1 )</td>
</tr>
<tr>
<td align="center">q.empty()</td>
<td align="center">是否为空 O ( 1 )</td>
</tr>
</tbody></table>
<p><strong>注意</strong>没有<code>clear()</code>！不提供该方法</p>
<p>优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</p>
<h3 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h3><h4 id="基本数据类型的优先级"><a href="#基本数据类型的优先级" class="headerlink" title="基本数据类型的优先级"></a>基本数据类型的优先级</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 小根堆, 每次取出的元素是队列中的最小值</span><br><br></code></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p>第一个参数：就是优先队列中存储的数据类型</p>
</li>
<li><p>第二个参数：</p>
<p><code>vector&lt;int&gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt;double&gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p>
</li>
<li><p>第三个参数：</p>
<p><code>less&lt;int&gt;</code> 表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt;int&gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p>基础写法（非常常用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; q1; <span class="hljs-comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt; q2; <span class="hljs-comment">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span><br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; q3; <span class="hljs-comment">// 小根堆, 每次取出的元素是队列中的最小值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>自定义排序（不常见，主要是写着麻烦）：</p>
<p>下面的代码比较长，基础类型优先级写着太麻烦，用基础写法即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp1</span> &#123;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> x &gt; y;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp2</span> &#123;<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> x &lt; y;<br>	&#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp1&gt; q1; <span class="hljs-comment">// 小根堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp2&gt; q2; <span class="hljs-comment">// 大根堆</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="高级数据类型-结构体-优先级"><a href="#高级数据类型-结构体-优先级" class="headerlink" title="高级数据类型(结构体)优先级"></a>高级数据类型(结构体)优先级</h4><blockquote>
<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>
</blockquote>
<p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//要排序的结构体（存储在优先队列里面的）</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>	<span class="hljs-type">int</span> x, y;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>版本一：自定义全局比较规则</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义的比较结构体</span><br><span class="hljs-comment">//注意：cmp是个结构体 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<span class="hljs-comment">//自定义堆的排序规则 </span><br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; a,<span class="hljs-type">const</span> Point&amp; b)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> a.x &lt; b.x;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">//初始化定义， </span><br>priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; <span class="hljs-comment">// x大的在堆顶</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>版本二：直接在结构体里面写</strong></p>
<blockquote>
<p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p>
</blockquote>
<p>结构体内部有两种方式：</p>
<ul>
<li><p><strong>方式一</strong> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, y;<br>	<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Point a, Point b) &#123;<span class="hljs-comment">//为两个结构体参数，结构体调用一定要写上friend</span><br>		<span class="hljs-keyword">return</span> a.x &lt; b.x;<span class="hljs-comment">//按x从小到大排，x大的在堆顶</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二</strong> ：（推荐此种）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Point &amp;a) <span class="hljs-type">const</span> &#123;<span class="hljs-comment">//直接传入一个参数，不必要写friend</span><br>        <span class="hljs-keyword">return</span> x &lt; a.x;<span class="hljs-comment">//按x升序排列，x大的在堆顶</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>优先队列的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;Point&gt; q;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 优先队列自定义排序规则和<code>sort()</code>函数定义<code>cmp</code>函数很相似，但是最后返回的情况是<strong>相反</strong>的。即相同的符号，最后定义的排列顺序是完全相反的。<br>所以只需要记住<code>sort</code>的排序规则和优先队列的排序规则是相反的就可以了。</p>
<blockquote>
<p>当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 <code>&gt;</code> ，那么孩子节点要大于父亲节点，堆顶自然是最小值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="存储特殊类型的优先级"><a href="#存储特殊类型的优先级" class="headerlink" title="存储特殊类型的优先级"></a>存储特殊类型的优先级</h3><h4 id="存储pair类型"><a href="#存储pair类型" class="headerlink" title="存储pair类型"></a>存储pair类型</h4><ul>
<li><p>排序规则：<br>默认先对<code>pair</code>的<code>first</code>进行降序排序，然后再对<code>second</code>降序排序<br>对<code>first</code>先排序，大的排在前面，如果<code>first</code>元素相同，再对<code>second</code>元素排序，保持大的在前面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;q;<br>	q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;);<br>	q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;);<br>	q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">8</span>, <span class="hljs-number">7</span>));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>结果：<br>8 7<br>7 9<br>7 8</p>
</blockquote>
</li>
</ul>
<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p>
<blockquote>
<p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p>
</blockquote>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化定义</span><br>map&lt;string, string&gt; mp;<br>map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>map&lt;<span class="hljs-type">int</span>, node&gt; mp;<span class="hljs-comment">//node是结构体类型</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p>
</blockquote>
</li>
</ul>
<h3 id="函数方法-1"><a href="#函数方法-1" class="headerlink" title="函数方法"></a>函数方法</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mp.find(key)</td>
<td align="center">返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end ( )</td>
</tr>
<tr>
<td align="center">mp.erase(it)</td>
<td align="center">删除迭代器对应的键和值 O ( l o g N )</td>
</tr>
<tr>
<td align="center">mp.erase(key)</td>
<td align="center">根据映射的键删除键和值 O ( l o g N )</td>
</tr>
<tr>
<td align="center">mp.erase(first,last)</td>
<td align="center">删除左闭右开区间迭代器对应的键和值 O ( l a s t − f i r s t )</td>
</tr>
<tr>
<td align="center">mp.size()</td>
<td align="center">返回映射的对数 O (1)</td>
</tr>
<tr>
<td align="center">mp.clear()</td>
<td align="center">清空map中的所有元素 O ( N )</td>
</tr>
<tr>
<td align="center">mp.insert()</td>
<td align="center">插入元素，插入时要构造键值对</td>
</tr>
<tr>
<td align="center">mp.empty()</td>
<td align="center">如果map为空，返回true，否则返回false</td>
</tr>
<tr>
<td align="center">mp.begin()</td>
<td align="center">返回指向map第一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="center">mp.end()</td>
<td align="center">返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td>
</tr>
<tr>
<td align="center">mp.rbegin()</td>
<td align="center">返回指向map最后一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="center">mp.rend()</td>
<td align="center">返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td>
</tr>
<tr>
<td align="center">mp.count(key)</td>
<td align="center">查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>
</tr>
<tr>
<td align="center">mp.lower_bound()</td>
<td align="center">返回一个迭代器，指向键值&gt;&#x3D; <strong>key</strong>的第一个元素</td>
</tr>
<tr>
<td align="center">mp.upper_bound()</td>
<td align="center">返回一个迭代器，指向键值&gt; key的第一个元素</td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>下面说明部分函数方法的注意点</strong></p>
<blockquote>
<p>注意：<br>查找元素<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8&spm=1001.2101.3001.7020">是否存在</a>时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%94%AE%E5%80%BC%E5%AF%B9&spm=1001.2101.3001.7020">键值对</a>（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p>
</blockquote>
<h4 id="迭代器进行正反向遍历"><a href="#迭代器进行正反向遍历" class="headerlink" title="迭代器进行正反向遍历"></a>迭代器进行正反向遍历</h4><ul>
<li><p><code>mp.begin()</code>和<code>mp.end()</code>用法：</p>
<p><strong>用于正向遍历map</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>mp[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>mp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(it != mp.<span class="hljs-built_in">end</span>()) &#123;<br>	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	it ++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>mp.rbegin()</code>和<code>mp.rend()</code>用法：</p>
<p><strong>用于逆向遍历map</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>mp[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>mp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">rbegin</span>();<br><span class="hljs-keyword">while</span>(it != mp.<span class="hljs-built_in">rend</span>()) &#123;<br>	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	it ++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找<code>lower_bound() upper_bound()</code></p>
<blockquote>
<p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">//有序</span><br>	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it1 = m.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">2</span>);<br>	cout &lt;&lt; it1-&gt;first &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//it1-&gt;first=2</span><br>	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it2 = m.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">2</span>);<br>	cout &lt;&lt; it2-&gt;first &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//it2-&gt;first=6</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//先声明</span><br>map&lt;string, string&gt; mp;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>方式一：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mp[<span class="hljs-string">&quot;学习&quot;</span>] = <span class="hljs-string">&quot;看书&quot;</span>;<br>mp[<span class="hljs-string">&quot;玩耍&quot;</span>] = <span class="hljs-string">&quot;打游戏&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二：插入元素构造键值对</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;vegetable&quot;</span>,<span class="hljs-string">&quot;蔬菜&quot;</span>));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方式三：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string,string&gt;(<span class="hljs-string">&quot;fruit&quot;</span>,<span class="hljs-string">&quot;水果&quot;</span>));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方式四:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><h4 id="下标访问-1"><a href="#下标访问-1" class="headerlink" title="下标访问"></a>下标访问</h4><p>(大部分情况用于访问单个元素)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mp[<span class="hljs-string">&quot;菜哇菜&quot;</span>] = <span class="hljs-string">&quot;强哇强&quot;</span>;<br>cout &lt;&lt; mp[<span class="hljs-string">&quot;菜哇菜&quot;</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//只是简写的一个例子，程序并不完整</span><br></code></pre></td></tr></table></figure>

<h4 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h4><ul>
<li><p>方式一：迭代器访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string,string&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); it++) &#123;<br>	<span class="hljs-comment">//      键                 值 </span><br>	<span class="hljs-comment">// it是结构体指针访问所以要用 -&gt; 访问</span><br>	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	<span class="hljs-comment">//*it是结构体变量 访问要用 . 访问</span><br>	<span class="hljs-comment">//cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二：智能指针访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : mp)<br>cout &lt;&lt; i.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<span class="hljs-comment">//键，值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方式三：对指定单个元素访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>cout &lt;&lt; it -&gt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;  it-&gt;second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式四：c++17特性才具有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [x, y] : mp)<br>	cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">//x,y对应键和值</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="与unordered-map的比较"><a href="#与unordered-map的比较" class="headerlink" title="与unordered_map的比较"></a>与unordered_map的比较</h3><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p>
<h4 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h4><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>
<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>
<h4 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h4><p>map：</p>
<ul>
<li>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N)</li>
<li>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</li>
</ul>
<p>unordered_map：</p>
<ul>
<li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li>
<li>缺点：建立哈希表比较耗时。</li>
</ul>
<blockquote>
<p>两者方法函数基本一样，差别不大。</p>
<p>注意：</p>
<ul>
<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>
</li>
<li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p>
</li>
<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以 map 为例</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-type">int</span> x = <span class="hljs-number">999999999</span>;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(x)) <span class="hljs-comment">// 此处判断是否存在x这个键</span><br>    cout &lt;&lt; mp[x] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;   <span class="hljs-comment">// 只有存在才会索引对应的值，避免不存在x时多余空元素的创建</span><br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>另外：</p>
<blockquote>
<p>还有一种映射：<code>multimap</code></p>
<p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>
</blockquote>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p>
<p>即：set里面的元素<strong>不重复 且有序</strong></p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化定义</span><br>set&lt;<span class="hljs-type">int</span>&gt; s;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数方法-2"><a href="#函数方法-2" class="headerlink" title="函数方法"></a>函数方法</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.begin()</td>
<td align="center">返回set容器的第一个元素的地址（迭代器）O ( 1 )</td>
</tr>
<tr>
<td align="center">s.end()</td>
<td align="center">返回set容器的最后一个元素的<strong>下一个</strong>地址（迭代器）O ( 1 )</td>
</tr>
<tr>
<td align="center">s.rbegin()</td>
<td align="center">返回逆序迭代器，指向容器元素最后一个位置O ( 1 )</td>
</tr>
<tr>
<td align="center">s.rend()</td>
<td align="center">返回逆序迭代器，指向容器第一个元素<strong>前面</strong>的位置O ( 1 )</td>
</tr>
<tr>
<td align="center">s.clear()</td>
<td align="center">删除set容器中的所有的元素</td>
</tr>
<tr>
<td align="center">s.empty()</td>
<td align="center">判断set容器是否为空O ( 1 )</td>
</tr>
<tr>
<td align="center">s.insert()</td>
<td align="center">插入一个元素</td>
</tr>
<tr>
<td align="center">s.size()</td>
<td align="center">返回当前set容器中的元素个数O ( 1 )</td>
</tr>
<tr>
<td align="center">erase(iterator)</td>
<td align="center">删除定位器iterator指向的值</td>
</tr>
<tr>
<td align="center">erase(first,second）</td>
<td align="center">删除定位器first和second之间的值</td>
</tr>
<tr>
<td align="center">erase(key_value)</td>
<td align="center">删除键值key_value的值</td>
</tr>
<tr>
<td align="center">s.find(element)</td>
<td align="center">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>
</tr>
<tr>
<td align="center">s.count(element)</td>
<td align="center">查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td>
</tr>
<tr>
<td align="center">s.lower_bound(k)</td>
<td align="center">返回&gt;&#x3D;k的第一个元素的迭代器O ( l o g N )</td>
</tr>
<tr>
<td align="center">s.upper_bound(k)</td>
<td align="center">返回&gt;k的第一个元素的迭代器O ( l o g N )</td>
</tr>
</tbody></table>
<h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><ul>
<li><p><strong>迭代器访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>	cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>智能指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)<br>	cout &lt;&lt; i &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>访问最后一个元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一种</span><br>cout &lt;&lt; *s.<span class="hljs-built_in">rbegin</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">//第二种</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator iter = s.<span class="hljs-built_in">end</span>();<br>iter--;<br>cout &lt;&lt; (*iter) &lt;&lt; endl; <span class="hljs-comment">//打印2;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第三种</span><br>cout &lt;&lt; *(--s.<span class="hljs-built_in">end</span>()) &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载&lt;运算符"></a>重载&lt;运算符</h3><ul>
<li><p><strong>基础数据类型</strong></p>
<p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s1; <span class="hljs-comment">// 默认从小到大排序</span><br>set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; s2; <span class="hljs-comment">// 从大到小排序</span><br></code></pre></td></tr></table></figure>

<p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//重载 &lt; 运算符</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> <span class="hljs-type">const</span> </span>&#123;<br>       <span class="hljs-comment">// return + 返回条件</span><br>       <span class="hljs-keyword">return</span> u &gt; v;<br>    &#125;<br>&#125;;<br>set&lt;<span class="hljs-type">int</span>, cmp&gt; s; <br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>    s.<span class="hljs-built_in">insert</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">// 10 9 8 7 6 5 4 3 2 1</span><br></code></pre></td></tr></table></figure>

<p>方式三：初始化时使用匿名函数定义比较规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; <span class="hljs-built_in">s</span>([&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<br>    <span class="hljs-keyword">return</span> i &gt; j; <span class="hljs-comment">// 从大到小</span><br>&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++)<br>    s.<span class="hljs-built_in">insert</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : s)<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>高级数据类型（结构体）</strong></p>
<p>直接重载结构体运算符即可，让结构体可以比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>	<span class="hljs-type">int</span> x, y;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Point &amp;p) <span class="hljs-type">const</span> &#123;<br>		<span class="hljs-comment">// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大</span><br>		<span class="hljs-keyword">if</span>(x == p.x)<br>			<span class="hljs-keyword">return</span> y &lt; p.y;<br>		<span class="hljs-keyword">return</span> x &lt; p.x;<br>	&#125;<br>&#125;;<br><br>set&lt;Point&gt; s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    s.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;);<br>&#125;	<br><span class="hljs-comment">/* 输入</span><br><span class="hljs-comment">5 4</span><br><span class="hljs-comment">5 2</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">3 5</span><br><span class="hljs-comment">4 8</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)<br>    cout &lt;&lt; i.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">3 5</span><br><span class="hljs-comment">3 7</span><br><span class="hljs-comment">4 8</span><br><span class="hljs-comment">5 2</span><br><span class="hljs-comment">5 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="其它set"><a href="#其它set" class="headerlink" title="其它set"></a>其它set</h3><p><code>multiset</code>:元素可以重复，且元素有序</p>
<p><code>unordered_set</code> ：元素无序且只能出现一次</p>
<p><code>unordered_multiset</code> ： 元素无序可以出现多次</p>
<h2 id="pair-二元组"><a href="#pair-二元组" class="headerlink" title="pair 二元组"></a>pair 二元组</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>pair只含有两个元素，可以看作是只有两个元素的结构体。</p>
<p><strong>应用：</strong></p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p><em>初始化</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1.初始化定义</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;zenith32&quot;</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//带初始值的</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p;<span class="hljs-comment">//不带初始值的</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><em>赋值</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//2.赋值</span><br>p = &#123;<span class="hljs-string">&quot;zenith32&quot;</span>, <span class="hljs-number">18</span>&#125;;<br>p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;zenith32&quot;</span>, <span class="hljs-number">18</span>);<br>p = <span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;zenith32&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>代替二元结构体</p>
</li>
<li><p>作为map键值对进行插入（代码如下）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;zenith32&quot;</span>,<span class="hljs-number">1</span>));<br><span class="hljs-comment">// mp.insert(make_pair(&quot;zenith32&quot;, 1));</span><br><span class="hljs-comment">// mp.insert(&#123;&quot;zenith32&quot;, 1&#125;);</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="访问-2"><a href="#访问-2" class="headerlink" title="访问"></a>访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义结构体数组</span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>	<span class="hljs-comment">//和结构体类似，first代表第一个元素，second代表第二个元素</span><br>	cout &lt;&lt; p[i].first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>string是一个字符串类，和<code>char</code>型字符串类似。</p>
<p>可以把string理解为一个字符串类型，像int一样可以定义</p>
<h3 id="初始化及定义"><a href="#初始化及定义" class="headerlink" title="初始化及定义"></a>初始化及定义</h3><ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1.</span><br>string str1; <span class="hljs-comment">//生成空字符串</span><br><br><span class="hljs-comment">//2.</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot;123456789&quot;</span>)</span></span>; <span class="hljs-comment">//生成&quot;123456789&quot;的复制品 </span><br><br><span class="hljs-comment">//3.</span><br><span class="hljs-function">string <span class="hljs-title">str3</span><span class="hljs-params">(<span class="hljs-string">&quot;12345&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//结果为&quot;123&quot; ，从0位置开始，长度为3</span><br><br><span class="hljs-comment">//4.</span><br><span class="hljs-function">string <span class="hljs-title">str4</span><span class="hljs-params">(<span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">//结果为&quot;12345&quot; ，长度为5</span><br><br><span class="hljs-comment">//5.</span><br><span class="hljs-function">string <span class="hljs-title">str5</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;2&#x27;</span>)</span></span>; <span class="hljs-comment">//结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串</span><br><br><span class="hljs-comment">//6.</span><br><span class="hljs-function">string <span class="hljs-title">str6</span><span class="hljs-params">(str2, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>访问单个字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string s = <span class="hljs-string">&quot;zenith!!!&quot;</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>		cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>string数组使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string s[<span class="hljs-number">10</span>];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>		s[i] = <span class="hljs-string">&quot;loading...  &quot;</span> ;<br>		cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>	&#125; <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//结果:</span><br><span class="hljs-comment">//loading...  1</span><br><span class="hljs-comment">//loading...  2</span><br><span class="hljs-comment">//loading...  3</span><br><span class="hljs-comment">//loading...  4</span><br><span class="hljs-comment">//loading...  5</span><br><span class="hljs-comment">//loading...  6</span><br><span class="hljs-comment">//loading...  7</span><br><span class="hljs-comment">//loading...  8</span><br><span class="hljs-comment">//loading...  9</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="string-特性"><a href="#string-特性" class="headerlink" title="string 特性"></a>string 特性</h3><ul>
<li><p>支持比较运算符</p>
<p>string字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），支持string与C-string的比较（如 str &lt; “hello”）。</p>
<p>在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按 字典顺序 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p>
<p>同时，<code>string (&quot;aaaa&quot;) &lt;string(&quot;aaaaa&quot;)</code>。</p>
</li>
<li><p>支持<code>+</code>运算符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br>string s = s1 + s2;<br>cout &lt;&lt; s;   <span class="hljs-comment">//123456</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="读入详解"><a href="#读入详解" class="headerlink" title="读入详解"></a>读入详解</h3><p><strong>读入字符串，遇空格，回车结束</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br>cin &gt;&gt; s;<br></code></pre></td></tr></table></figure>

<p><strong>读入一行字符串（包括空格），遇回车结束</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br></code></pre></td></tr></table></figure>

<p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code> cin.get()</code></p>
<p>错误读取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getline</span>(cin, s); <span class="hljs-comment">//此时读取相当于读取了前一个回车字符</span><br></code></pre></td></tr></table></figure>

<p>正确读取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//cin.get() 读取前一个回车字符</span><br><span class="hljs-built_in">getline</span>(cin, s);<span class="hljs-comment">//可正确读入下一行的输入</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>cin</code>与<code>cin.getline()</code>混用</p>
<p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>
</blockquote>
<p><strong>cin和cout解锁</strong></p>
<p>代码（写在main函数开头）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么要进行cin和cout的解锁，原因是：</p>
<p>在一些题目中，读入的数据量很大，往往超过了1e5（105）的数据量,而cin和cout的读入输出的速度很慢（是因为cin和cout为了兼容C语言的读入输出在性能上做了妥协），远不如scanf和printf的速度，具体原因可以搜索相关的博客进行了解。</p>
<p>所以对cin和cout进行解锁使cin和cout的速度几乎接近scanf和printf，避免输入输出超时。</p>
</blockquote>
<p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p>
<blockquote>
<p>string与C语言字符串（C-string）的区别</p>
<p>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\0字符<br>C-string<br>C语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\0结尾</p>
</blockquote>
<p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s = <span class="hljs-string">&quot;zenith&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2 = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure>

<h3 id="函数方法-3"><a href="#函数方法-3" class="headerlink" title="函数方法"></a>函数方法</h3><ul>
<li><p><strong>获取字符串长度</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.size()<code>和</code>s.length()</td>
<td align="center">返回string对象的字符个数，他们执行效果相同。</td>
</tr>
<tr>
<td align="center">s.max_size()</td>
<td align="center">返回string对象最多包含的字符数，超出会抛出length_error异常</td>
</tr>
<tr>
<td align="center">s.capacity()</td>
<td align="center">重新分配内存之前，string对象能包含的最大字符数</td>
</tr>
</tbody></table>
</li>
<li><p><strong>插入</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.push_back(element)</td>
<td align="center">在末尾插入</td>
</tr>
<tr>
<td align="center">s.insert(pos,element)</td>
<td align="center">在pos位置插入element</td>
</tr>
<tr>
<td align="center">s.append(str)</td>
<td align="center">在s字符串结尾添加str字符串</td>
</tr>
</tbody></table>
<p>例</p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.push_back(‘a’)</td>
<td align="center">末尾插入一个字符a</td>
</tr>
<tr>
<td align="center">s.insert(s.begin(),’1’)</td>
<td align="center">在第一个位置插入1字符</td>
</tr>
<tr>
<td align="center">s.append(“abc”)</td>
<td align="center">在s字符串末尾添加字符串“abc”</td>
</tr>
</tbody></table>
</li>
<li><p><strong>删除</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">erase(iterator p)</td>
<td align="center">删除字符串中p所指的字符</td>
</tr>
<tr>
<td align="center">erase(iterator first, iterator last)</td>
<td align="center">删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td>
</tr>
<tr>
<td align="center">erase(pos, len)</td>
<td align="center">删除字符串中从索引位置pos开始的len个字符</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">删除字符串中所有字符</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字符替换</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.replace(pos,n,str)</td>
<td align="center">把当前字符串从索引pos开始的n个字符替换为str</td>
</tr>
<tr>
<td align="center">s.replace(pos,n,n1,c)</td>
<td align="center">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>
</tr>
<tr>
<td align="center">s.replace(it1,it2,str)</td>
<td align="center">把当前字符串<code>[it1,it2)</code>区间替换为str <strong>it1 ,it2为迭代器（iterator）</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>大小写转换</strong></p>
<p>法一：</p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tolower(s[i])</td>
<td align="center">转换为小写</td>
</tr>
<tr>
<td align="center">toupper(s[i])</td>
<td align="center">转换为大写</td>
</tr>
</tbody></table>
<p>法二：</p>
<p>通过stl的<code>transform</code>算法配合<code>tolower</code> 和<code>toupper</code> 实现。<br>有4个参数，前2个指定<strong>要转换的容器</strong>的起止范围，第3个参数是<strong>结果存放容器</strong>的起始位置，第4个参数是一元运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-built_in">transform</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),s.<span class="hljs-built_in">begin</span>(),::tolower);<span class="hljs-comment">//转换小写</span><br><span class="hljs-built_in">transform</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),s.<span class="hljs-built_in">begin</span>(),::toupper);<span class="hljs-comment">//转换大写</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>分割</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.substr(pos,n)</td>
<td align="center">截取从pos索引开始的n个字符</td>
</tr>
</tbody></table>
</li>
<li><p><strong>查找</strong></p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s.find (str, pos)</td>
<td align="center">在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="center">s.find (c, pos)</td>
<td align="center">在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="center">s.rfind (str, pos)</td>
<td align="center">在当前字符串的pos索引位置开始，<strong>反向</strong>查找子串s，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="center">s.rfind (c,pos)</td>
<td align="center">在当前字符串的pos索引位置开始，<strong>反向</strong>查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="center">s.find_first_of (str, pos)</td>
<td align="center">在当前字符串的pos索引位置（默认为0）开始，查找子串s<strong>的字符</strong>，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="center">s.find_first_not_of (str,pos)</td>
<td align="center">在当前字符串的pos索引位置（默认为0）开始，查找<strong>第一个不位于子串s的字符</strong>，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="center">s.find_last_of(str, pos)</td>
<td align="center">在当前字符串的pos索引位置开始，查找最后一个位于子串s<strong>的字符</strong>，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="center">s.find_last_not_of ( str, pos)</td>
<td align="center">在当前字符串的pos索引位置开始，查找<strong>最后一个不位于子串s的字符</strong>，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;<br><span class="hljs-comment">//字符串查找-----找到后返回首字母在字符串中的下标</span><br><span class="hljs-comment">// 1. 查找一个字符串</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">6</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：11</span><br>    <br><span class="hljs-comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 4. 从字符串的末尾开始查找字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;i&#x27;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符</span><br>    <br><span class="hljs-comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;13br98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：4---b</span><br>    <br><span class="hljs-comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 结果是：4</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_first_not_of</span>(<span class="hljs-string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="hljs-comment">// 结果是：9</span><br>    <br><span class="hljs-comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&quot;13r98&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：19</span><br><br><span class="hljs-comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&quot;teac&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 结果是：21</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>排序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//按ASCII码排序</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化定义"><a href="#初始化定义" class="headerlink" title="初始化定义"></a>初始化定义</h3><ul>
<li><p>初始化方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bitset&lt;n&gt; a;<span class="hljs-comment">//a有n位，每位都为0</span><br><span class="hljs-function">bitset&lt;n&gt; <span class="hljs-title">a</span><span class="hljs-params">(b)</span></span>;<span class="hljs-comment">//a是unsigned long型b的一个二进制副本</span><br><span class="hljs-function">bitset&lt;n&gt; <span class="hljs-title">a</span><span class="hljs-params">(s)</span></span>;<span class="hljs-comment">//a是string对象s中含有的位串的副本</span><br><span class="hljs-function">bitset&lt;n&gt; <span class="hljs-title">a</span><span class="hljs-params">(s,pos,n)</span></span>;<span class="hljs-comment">//a是s中从位置pos开始的n个位的副本</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>n</code>必须为常量表达式</p>
</blockquote>
<p>演示代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	bitset&lt;4&gt; bitset1;　　  <span class="hljs-comment">//无参构造，长度为４，默认每一位为0</span><br><span class="hljs-function">bitset&lt;9&gt; <span class="hljs-title">bitset2</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;　<span class="hljs-comment">//长度为9，二进制保存，前面用0补充</span><br><br>string s = <span class="hljs-string">&quot;100101&quot;</span>;<br><span class="hljs-function">bitset&lt;10&gt; <span class="hljs-title">bitset3</span><span class="hljs-params">(s)</span></span>;　　<span class="hljs-comment">//长度为10，前面用0补充</span><br><br><span class="hljs-type">char</span> s2[] = <span class="hljs-string">&quot;10101&quot;</span>;<br><span class="hljs-function">bitset&lt;13&gt; <span class="hljs-title">bitset4</span><span class="hljs-params">(s2)</span></span>;　　<span class="hljs-comment">//长度为13，前面用0补充</span><br><br>cout &lt;&lt; bitset1 &lt;&lt; endl;　　<span class="hljs-comment">//0000</span><br>cout &lt;&lt; bitset2 &lt;&lt; endl;　　<span class="hljs-comment">//000001100</span><br>cout &lt;&lt; bitset3 &lt;&lt; endl;　　<span class="hljs-comment">//0000100101</span><br>cout &lt;&lt; bitset4 &lt;&lt; endl;　<span class="hljs-comment">//0000000010101</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><code>bitset</code>可以进行<strong>位操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">bitset&lt;4&gt; <span class="hljs-title">foo</span> <span class="hljs-params">(string(<span class="hljs-string">&quot;1001&quot;</span>))</span></span>;<br><span class="hljs-function">bitset&lt;4&gt; <span class="hljs-title">bar</span> <span class="hljs-params">(string(<span class="hljs-string">&quot;0011&quot;</span>))</span></span>;<br><br>cout &lt;&lt; (foo^=bar) &lt;&lt; endl;<span class="hljs-comment">// 1010 (foo对bar按位异或后赋值给foo)</span><br><br>cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;<span class="hljs-comment">// 0001 (按位与后赋值给foo)</span><br><br>cout &lt;&lt; (foo|=bar) &lt;&lt; endl;<span class="hljs-comment">// 1011 (按位或后赋值给foo)</span><br><br>cout &lt;&lt; (foo&lt;&lt;=<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">// 0100 (左移2位，低位补0，有自身赋值)</span><br><br>cout &lt;&lt; (foo&gt;&gt;=<span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">// 0100 (右移1位，高位补0，有自身赋值)</span><br><br>cout &lt;&lt; (~bar) &lt;&lt; endl;<span class="hljs-comment">// 1100 (按位取反)</span><br><br>cout &lt;&lt; (bar&lt;&lt;<span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">// 0110 (左移，不赋值)</span><br><br>cout &lt;&lt; (bar&gt;&gt;<span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">// 0001 (右移，不赋值)</span><br><br>cout &lt;&lt; (foo==bar) &lt;&lt; endl;<span class="hljs-comment">// false (1001==0011为false)</span><br><br>cout &lt;&lt; (foo!=bar) &lt;&lt; endl;<span class="hljs-comment">// true  (1001!=0011为true)</span><br><br>cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;<span class="hljs-comment">// 0001 (按位与，不赋值)</span><br><br>cout &lt;&lt; (foo|bar) &lt;&lt; endl;<span class="hljs-comment">// 1011 (按位或，不赋值)</span><br><br>cout &lt;&lt; (foo^bar) &lt;&lt; endl;<span class="hljs-comment">// 1010 (按位异或，不赋值)</span><br></code></pre></td></tr></table></figure>

<p><strong>访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：</span><br><span class="hljs-function">bitset&lt;4&gt; <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-string">&quot;1011&quot;</span>)</span></span>; <br><br>cout &lt;&lt; foo[<span class="hljs-number">0</span>] &lt;&lt; endl;　　<span class="hljs-comment">//1</span><br>cout &lt;&lt; foo[<span class="hljs-number">1</span>] &lt;&lt; endl;　　<span class="hljs-comment">//0</span><br>cout &lt;&lt; foo[<span class="hljs-number">2</span>] &lt;&lt; endl;　　<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法函数-4"><a href="#方法函数-4" class="headerlink" title="方法函数"></a>方法函数</h3><table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b.any()</td>
<td align="center">b中是否存在置为1的二进制位，有 返回true</td>
</tr>
<tr>
<td align="center">b.none()</td>
<td align="center">b中是否没有1，没有 返回true</td>
</tr>
<tr>
<td align="center">b.count()</td>
<td align="center">b中为1的个数</td>
</tr>
<tr>
<td align="center">b.size()</td>
<td align="center">b中二进制位的个数</td>
</tr>
<tr>
<td align="center">b.test(pos)</td>
<td align="center">测试b在pos位置是否为1，是 返回true</td>
</tr>
<tr>
<td align="center">b[pos]</td>
<td align="center">返回b在pos处的二进制位</td>
</tr>
<tr>
<td align="center">b.set()</td>
<td align="center">把b中所有位都置为1</td>
</tr>
<tr>
<td align="center">b.set(pos)</td>
<td align="center">把b中pos位置置为1</td>
</tr>
<tr>
<td align="center">b.reset()</td>
<td align="center">把b中所有位都置为0</td>
</tr>
<tr>
<td align="center">b.reset(pos)</td>
<td align="center">把b中pos位置置为0</td>
</tr>
<tr>
<td align="center">b.flip()</td>
<td align="center">把b中所有二进制位取反</td>
</tr>
<tr>
<td align="center">b.flip(pos)</td>
<td align="center">把b中pos位置取反</td>
</tr>
<tr>
<td align="center">b.to_ulong()</td>
<td align="center">用b中同样的二进制位返回一个unsigned long值</td>
</tr>
</tbody></table>
<h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array 数组"></a>array 数组</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p>
<p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>
<p><strong>注意：</strong></p>
<p><code>array</code>的使用要在<code>std</code>命名空间里</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><ul>
<li><p>基础数据类型</p>
<p>声明一个大小为100的<code>int</code>型数组，元素的值不确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 100&gt; a;<br></code></pre></td></tr></table></figure>

<p>声明一个大小为100的<code>int</code>型数组，初始值均为<code>0</code>(初始值与默认元素类型等效)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 100&gt; a&#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>声明一个大小为100的<code>int</code>型数组，初始化部分值，其余全部为<code>0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 100&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>或者可以用等号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 100&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h4><p>不同于数组的是对元素类型不做要求，可以套结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;string, 2&gt; s = &#123;<span class="hljs-string">&quot;ha&quot;</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;haha&quot;</span>)&#125;;<br>array&lt;node, 2&gt; a;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="取存元素值"><a href="#取存元素值" class="headerlink" title="取存元素值"></a><strong>取存元素值</strong></h3><ul>
<li><p>修改元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 4&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>访问元素</p>
<p>下标访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 4&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>

<p>利用auto访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : a)<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>

<p>迭代器访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span>(; it != a.<span class="hljs-built_in">end</span>(); it++) <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>

<p><code>at()</code>函数访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//下标为1的元素 加上 下标为2的元素，答案为5</span><br>array&lt;<span class="hljs-type">int</span>, 4&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> res = a.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) + a.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);<br>cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<p><code>get</code>方法访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//将a数组下标为1位置处的值改为x</span><br><span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a) = x;<br><span class="hljs-comment">//注意 获取的下标只能写数字，不能填变量</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a><strong>成员函数</strong></h3><table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回容器中第一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回容器最后一个元素<strong>后一个位置</strong>的访问迭代器（地址）</td>
</tr>
<tr>
<td align="center">rbegin()</td>
<td align="center">返回最后一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="center">rend()</td>
<td align="center">返回第一个元素<strong>前一个位置</strong>的访问迭代器（地址）</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td>
</tr>
<tr>
<td align="center">max_size()</td>
<td align="center">返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">判断容器是否为空</td>
</tr>
<tr>
<td align="center">at(n)</td>
<td align="center">返回容器中 n 位置处元素的<strong>引用</strong>，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>
</tr>
<tr>
<td align="center">front()</td>
<td align="center">返回容器中第一个元素的<strong>直接引用</strong>，函数不适用于空的 array 容器</td>
</tr>
<tr>
<td align="center">back()</td>
<td align="center">返回容器中最后一个元素的<strong>直接引用</strong>，函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td align="center">data()</td>
<td align="center">返回一个指向容器首个元素的<strong>指针</strong>。利用该指针，可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td align="center">fill(x)</td>
<td align="center">将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td>
</tr>
<tr>
<td align="center">array1.swap(array2)</td>
<td align="center">交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>
</tr>
</tbody></table>
<h3 id="部分用法示例"><a href="#部分用法示例" class="headerlink" title="部分用法示例"></a>部分用法示例</h3><h3 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h3><p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>, 4&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> res = a.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) + a.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);<br>cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.<span class="hljs-built_in">fill</span>(x);<br></code></pre></td></tr></table></figure>

<p>另外还有其它的fill()函数:将a数组[begin,end)全部值变为x</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fill</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), x);<br></code></pre></td></tr></table></figure>

<h3 id="get方法获取元素值"><a href="#get方法获取元素值" class="headerlink" title="get方法获取元素值"></a>get方法获取元素值</h3><p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>
<p>注意 获取的下标只能写数字，不能填变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a) = x;<br></code></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p>
<p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p>
<p>tuple可以等价为<strong>结构体</strong>使用</p>
<ul>
<li><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a><strong>基础用法</strong></h3><h3 id="声明及初始化"><a href="#声明及初始化" class="headerlink" title="声明及初始化"></a>声明及初始化</h3><ul>
<li><p>声明一个空的<code>tuple</code>三元组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, string&gt; t1;<br></code></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t1 = <span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;hahaha&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建的同时初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-number">1</span>);<br>tuple&lt;string, <span class="hljs-type">int</span>&gt; t3 &#123;p&#125;; <span class="hljs-comment">//将pair对象赋给tuple对象</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><ul>
<li><p>获取tuple对象<code>t</code>的第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> first = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t);<br></code></pre></td></tr></table></figure>
<p>修改tuple对象<code>t</code>的第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h3><ul>
<li><p>获取元素个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>cout &lt;&lt; tuple_size&lt;<span class="hljs-keyword">decltype</span>(t)&gt;::value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>获取对应元素的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//通过`get&lt;n&gt;(obj)`方法获取,`n`必须为数字不能是变量</span><br><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 1</span><br>cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 2</span><br>cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>通过<code>tie</code>解包 获取元素值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//tie可以让tuple变量中的三个值依次赋到tie中的三个变量中</span><br><span class="hljs-type">int</span> one, three;<br>string two; <br><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hahaha&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-built_in">tie</span>(one, two, three) = t;<br>cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1hahaha3</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>stl 的总结就到这里先结束了，也算是按时提前完成此次任务了吧</p>
<p>后续应该会补充一些其他常用的函数，例如 sort 等</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/11/14/BMX055/">← 下一篇 stm32f407驱动BMX055记录</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/10/28/birdking-is-so-cool/">祝birdking生日快乐！！！ 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Zenith</a></h1><div id="description"><p>未经审视的人生是不值得过的人生</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">STL函数总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">vector 动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">3.1.3.</span> <span class="toc-text">访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">下标访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">迭代器访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">智能指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack-%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">stack 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">栈遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%81%8D%E5%8E%86-1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">栈遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">数组模拟栈进行遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-%E9%98%9F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">queue 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">队列模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">deque  双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0-3"><span class="toc-number">3.4.2.</span> <span class="toc-text">方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.4.3.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">3.5.</span> <span class="toc-text">priority_queue 优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.5.3.</span> <span class="toc-text">设置优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">基本数据类型的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">高级数据类型(结构体)优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.5.4.</span> <span class="toc-text">存储特殊类型的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8pair%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">存储pair类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E6%98%A0%E5%B0%84"><span class="toc-number">3.6.</span> <span class="toc-text">map 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">3.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.6.2.</span> <span class="toc-text">函数方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%AD%A3%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">迭代器进行正反向遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">3.6.3.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">3.6.4.</span> <span class="toc-text">访问元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-1"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">下标访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%AE%BF%E9%97%AE"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">遍历访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Eunordered-map%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.6.5.</span> <span class="toc-text">与unordered_map的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">内部实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">效率比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-%E9%9B%86%E5%90%88"><span class="toc-number">3.7.</span> <span class="toc-text">set 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">3.7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95-2"><span class="toc-number">3.7.2.</span> <span class="toc-text">函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-1"><span class="toc-number">3.7.3.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">3.7.4.</span> <span class="toc-text">重载&lt;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83set"><span class="toc-number">3.7.5.</span> <span class="toc-text">其它set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pair-%E4%BA%8C%E5%85%83%E7%BB%84"><span class="toc-number">3.8.</span> <span class="toc-text">pair 二元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">3.8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-2"><span class="toc-number">3.8.2.</span> <span class="toc-text">访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.9.</span> <span class="toc-text">string 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">3.9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">3.9.2.</span> <span class="toc-text">初始化及定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%89%B9%E6%80%A7"><span class="toc-number">3.9.3.</span> <span class="toc-text">string 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.9.4.</span> <span class="toc-text">读入详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95-3"><span class="toc-number">3.9.5.</span> <span class="toc-text">函数方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bitset"><span class="toc-number">3.10.</span> <span class="toc-text">bitset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">3.10.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">3.10.2.</span> <span class="toc-text">初始化定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">3.10.3.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0-4"><span class="toc-number">3.10.4.</span> <span class="toc-text">方法函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array-%E6%95%B0%E7%BB%84"><span class="toc-number">3.11.</span> <span class="toc-text">array 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">3.11.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">高级数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%AD%98%E5%85%83%E7%B4%A0%E5%80%BC"><span class="toc-number">3.11.3.</span> <span class="toc-text">取存元素值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.11.4.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.11.5.</span> <span class="toc-text">部分用法示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data"><span class="toc-number">3.11.6.</span> <span class="toc-text">data()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at"><span class="toc-number">3.11.7.</span> <span class="toc-text">at()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill"><span class="toc-number">3.11.8.</span> <span class="toc-text">fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%80%BC"><span class="toc-number">3.11.9.</span> <span class="toc-text">get方法获取元素值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">3.11.10.</span> <span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple-%E5%85%83%E7%BB%84"><span class="toc-number">3.12.</span> <span class="toc-text">tuple 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">3.12.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">3.12.2.</span> <span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.12.3.</span> <span class="toc-text">声明及初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.12.4.</span> <span class="toc-text">元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.12.5.</span> <span class="toc-text">函数操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">4.</span> <span class="toc-text">后记</span></a></li></ol></div></div><footer><nobr><span class="icp-title">♖</span><a class="icp-content" href="https://smallgoodgood.top/about/">关于本站</a></nobr><br><nobr>Pubulished by <a href="http://smallgoodgood.top">Zenith <br></a></nobr><wbr><!-- 添加网站运行时间 --><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now = new Date();

function createtime() {
  var grt = new Date("02/09/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间 
  now.setTime(now.getTime() + 250);
  days = (now - grt) / 1000 / 60 / 60 / 24;
  dnum = Math.floor(days);
  hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
  hnum = Math.floor(hours);
  if (String(hnum).length == 1) {
      hnum = "0" + hnum;
  }
  minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
  mnum = Math.floor(minutes);
  if (String(mnum).length == 1) {
      mnum = "0" + mnum;
  }
  seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
  snum = Math.round(seconds);
  if (String(snum).length == 1) {
      snum = "0" + snum;
  }
  document.getElementById("timeDate").innerHTML = " | 本站已安全运行 " + dnum + " 天 ";
  document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()", 250);
<!-- 添加网站运行时间 -->

</script></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>