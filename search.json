[{"title":"A Predictive Study on the Development of China's Pet Industry and Pet Food Market Based on ARIMA and Multiple Linear Regression Models.","url":"/2024/11/26/APMCM/","content":"This is the outcome of the Asia-Pacific Mathematical Modeling Competition, primarily using ARIMA, MLR, Logistic models, and various data analysis models. Attached paper .\n","categories":["学习"],"tags":["数模"]},{"title":"C语言知识点总结","url":"/2024/11/17/C/","content":"这是我主持的OurEDA的例会内容整理点击 下载 本次沙龙 PPT\n变量常用变量表（看看就好有个印象就行）\n\n\n类型\n含义\n32位编译器中大小(一般)\n64位编译器中大小(一般)\n最小值(32位)\n最大值(32位)\n\n\n\nbool\n布尔类型\n1byte\n1byte\nfalse\ntrue\n\n\nchar\n单个字符\n1byte\n1byte\n-2^7^\n2^7^-1\n\n\nshort\n短整形\n2byte\n2byte\n-2^15^\n2^15^-1\n\n\nint\n整形\n4byte\n4byte\n-2^31^\n2^31^-1\n\n\nlong\n长整形\n4byte4byte\n8byte\n-2^31^\n2^31^-1\n\n\nlong long\n长整形\n8byte\n8byte\n-2^63^\n2^63^-1\n\n\nfloat\n单精度浮点数\n4byte\n4byte\n-2^127^\n2^128^\n\n\ndouble\n双精度浮点数\n8byte\n8byte\n-2^1023^\n2^1024^\n\n\nlong double\n扩展精度浮点数\n12byte\n16byte\n-2^16383^\n2^16384^\n\n\nchar*\n字符常量或字符串常量\n4byte\n8byte\n无意义\n无意义\n\n\n\n\n\n类型\n有效位数计算\n有效位数\n\n\n\nfloat\n223+1&#x3D;16,777,216\n8-1&#x3D;7\n\n\ndouble\n252+1&#x3D;9,007,199,254,740,992‬\n16-1&#x3D;15\n\n\nlong double\n280+1&#x3D;2.410 24 &#x2F; 2112+1&#x3D;1.0381034\n25-1&#x3D;24 &#x2F; 35-1&#x3D;34\n\n\n一些注意事项\n\n数字默认是 double\n字符串默认是const char*\n\n特殊前缀extern int a;  // 声明一个int类型的变量a，一般用在.h文件中声明项目全局变量const int b=1;  // 定义一个不可变的变量b，使用const关键字都要赋初值static int c=1;  // 在函数中使用，只在第一次使用时初始化，相当于作用域在函数内的全局变量typedef long long int;  // 把long long当作int使用\n\n变量作用域\n局部变量\n\n全局变量\n\n\n字符串字符串在c语言中有两种形式char*和char[]，这里简单分辨下两者之间的不同。\n“HelloWorld!”是字符串常量，不可修改。\n\nchar* c1&#x3D;”HelloWorld!”中，c1指向代码段中的常量，只读不写，且常量相同，指向的地址也相同。\nchar c2[]&#x3D;”HelloWorld!”中，c2指向堆栈段中的数据，可读可写，相当于把代码端的数据拷贝了出来。\n\n结构体结构体可以看作是一种几个基础类型复合的类型。\n语句条件语句\nif - else - if else\nif依据后面的条件语句的结果进行判断，非0为真，0为假\nif会优先和近的else组合\nif()    //...else if()    //...else    //...\n\n\n\nif()    //...if()    //...else    //...\n\n\n\nswitch - case - default\n注意：每种情况下都要有break，否则将会持续执行。\nswitch(ch)&#123;  \tcase &#x27;a&#x27;:\t\t//...\t\tbreak;\tcase &#x27;b&#x27;:\t\t//...\t\tbreak;\tdefault:\t\t//...&#125;\n\n循环语句\nwhile\n先判断，再执行\nwhile 依据后面语句的结果进行判断，非0为真，0为假\n\ndo while（见得较少）\n不判断，先执行一次\n\nfor\n先判断，再执行\n适用于控制执行的次数\n\n\n跳转语句\nbreak\n跳出当前语句（{}）\n\ncontinue\n在 条件语句 中表示什么都不做（替代空语句）；\n在 迭代语句 中表示 直接进入下一轮循环，不执行完当前循环 。\n\ngoto（非常非常不建议，不过学的时候可以试着玩一下）\ngoto任意位置\nfor (int i=0; i&lt;n; i++) &#123;\tfor (int j=0; j&lt;m; j++) &#123;\t\tfor (int k=0; k&lt;o; k++) &#123;\t\t\tif (跳出条件) &#123;\t\t\t\tgoto end;\t\t\t&#125;\t\t&#125;\t&#125;&#125;end://...\n\n函数\n函数结果\n返回类型 函数名（形式传入参数）\n{\n​    函数体;\n​    return ()；\n}\n\nreturn 在 dfs 等算法中用于回溯\n\n内联函数 inline\n提高程序执行效率（整体代换而不是用函数调用)\ninline char *dbtest(int a)&#123;    return (a % 2 &gt; 0 ? &quot;奇&quot; : &quot;偶&quot;);&#125;\n\n指针\n\n\n\n\n&amp;\n\n常量指针（不能修改指针指向地址中的值）\n\n指针常量（不能修改指针的值）\n\n常量指针常量（既不能修改指针指向地址中的值，又不能修改指针的值）\n\n结构体指针变量（ . &#x2F; -&gt; ）\n\n数组与指针\n数组的变量名就是该数组的首地址\n数组的下标就是地址的位移量\n\n\nscanf 与 printf\nscanf(“输入格式”，变量地址);\nprintf(“输出格式”，变量);\n\n","categories":["学习"],"tags":["C语言","知识总结"]},{"title":"对内容进行了一些完善","url":"/2024/10/05/add-something-new/","content":"\n\n\n因为闲着所以试一些有意思的小玩意儿,不知道有没有人看得到哈哈哈哈哈哈 \n首先就是使用了隐藏文本\n以后可以说一些悄悄话了（）\n新增了跳转链接尝试与 Rhodes Island™ 取得弱神经连接：\n\n        \n        Rhodes Island™'与  Rhodes  Island™  取得弱神经连接'\n\n想添加自己的链接可以联系我\n新增了音乐播放器放一首我听得最多的\n&nbsp;\n\n思绪绵绵呀\n新增了一只噬元兽没错，就是左下角这一只（不知道你们有没有看到，毕竟隐身了）\n在添加的过程中看到有个博客有罗小黑的桌宠，本来打算也添加一个的，但是忘记收藏，导致现在找不到那个博客了。后来我也在B站上找到了lpk文件，尝试了一上午加半个下午，仍然不知道怎么添加，只能作罢。。（如果有谁看到那个用了罗小黑的博客或者知道怎么在web上使用lpk文件，请联系我，不胜感激）\n新增了本站运行时间在右下角哟\n特意把时间设置成北京时间，可以当作时钟（我多贴心）\n\n新增了点击特效就用《起风了》的歌词吧 不要问我为什么，多听几遍就知道了\n希望你们喜欢\n点下去的时候是烟花，松开的时候是歌词，有个时间差更容易看见歌词（可以等烟花散了再松开）\n\n新增了彩色滚动字体  \n    \n  \n    var binft = function (r) {\n      function t() {\n        return b[Math.floor(Math.random() * b.length)]\n      }  \n      function e() {\n        return String.fromCharCode(94 * Math.random() + 33)\n      }\n      function n(r) {\n        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {\n          var l = document.createElement(\"span\");\n          l.textContent = e(), l.style.color = t(), n.appendChild(l)\n        }\n        return n\n      }\n      function i() {\n        var t = o[c.skillI];\n        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)\n      }\n      var l = \"\",\n      o = [\"这一路上走走停停\",\"顺着少年漂流的痕迹\",\"迈出车站的前一刻\",\"竟有些犹豫\",\"不禁笑这近乡情怯\",\"仍无法避免\",\"而长野的天\",\"依旧那么暖\",\"风吹起了从前\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不得真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"逆着光行走 任风吹雨打\",\"短短的路走走停停\",\"也有了几分的距离\",\"不知抚摸的是故事\",\"还是段心情\",\"也许期待的不过是\",\"与时间为敌\",\"再次见到你\",\"微凉晨光里\",\"笑得很甜蜜\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不做真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"晚风吹起你鬓间的白发\",\"抚平回忆留下的疤\",\"你的眼中 明暗交杂 一笑生花\",\"暮色遮住你蹒跚的步伐\",\"走进床头藏起的画\",\"画中的你 低着头说话\",\"我仍感叹于世界之大\",\"也沉醉于儿时情话\",\"不剩真假 不做挣扎 无谓笑话\",\"我终将青春还给了她\",\"连同指尖弹出的盛夏\",\"心之所动 就随风去了\",\"以爱之名 你还愿意吗\"].map(function (r) {\n      return r + \"\"\n      }),\n      a = 15,//文字保留时间\n      g = 1,//文字出现速度 越大越慢\n      s = 4,//乱码长度\n      d = 50,//单个乱码展示时间\n      b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n      c = {\n        text: \"\",\n        prefixP: -s,\n        skillI: 0,\n        skillP: 0,\n        direction: \"forward\",\n        delay: a,\n        step: g\n      };\n      i()\n      };\n      binft(document.getElementById('binft'));\n   \n\n\n\n\n本来彩色滚动字体会导致下面的界面发生跳动，在外面套上div后修好了\n\n改进了折叠文本\n        \n            \n            \n            明日方舟语录\n\n        \n        是棋子，那就吃掉；是堡垒，那就攻陷；是王权，那就推翻。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——《明日方舟》觉得很霸气所以选这一句\n\n        \n\n\n\n\n杂记\n昨天成功捕捉噬元兽，带着她去看了尾巴的伤口并顺带做了绝育\n\n \n\n\n\n伤的挺严重的，已经感染了，幸好及时送到医院\n\n \n\n\n最后再附上几张 令 的图作为结束吧\n\n\n\n\n\n令 还是挺帅的\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"Linux 常用命令","url":"/2024/11/19/Linux/","content":"Linux 常用命令汇总基本命令关机和重启\n关机：\nshutdown ‐h now          #立刻关机 shutdown ‐h 5         #5分钟后关机 poweroff            #立刻关机 \n\n重启\nshutdown ‐r now          #立刻重启 shutdown ‐r 5         #5分钟后重启 reboot              #立刻重启 \n\n帮助命令\n帮助\nshutdown –help          #查看关机命令帮助信息 ifconfig    ‐‐help          #查看网卡信息 man              #（命令说明书） man shutdown \n\n注意：man shutdown 打开命令说明书之后，使用按键 q 退出 \n\n目录操作命令目录切换命令\ncd\ncd /              #切换到根目录 cd /usr              #切换到根目录下的 usr 目录 cd ../              #切换到上一级目录  或者    cd .. cd ~              #切换到 home 目录 cd ‐              #切换到上次访问的目录 \n\n\n目录查看命令\nls\nLs            #查看当前目录下的所有目录和文件 ls ‐a          #查看当前目录下的所有目录和文件（包括隐藏的文件） ls ‐l  或  ll        #列表查看当前目录下的所有目录和文件（显示更多信息） ls /dir          #查看指定目录下的所有目录和文件      如：ls /usr \n\n目录操作命令创建目录\nmkdir\nmkdir        aaa     #  在当前目录下创建一个名为 aaa 的目录 mkdir        /usr/aaa    #  在指定目录下创建一个名为 aaa 的目录 \n\n删除目录或文件\nrm\nrm  文件        #删除当前目录下的文件 rm ‐f  文件          #删除当前目录的的文件（不询问） #删除目录： rm ‐r aaa          #递归删除当前目录下的 aaa 目录 rm ‐rf aaa          #递归删除当前目录下的 aaa 目录（不询问） #全部删除： rm ‐rf *            #将当前目录下的所有目录和文件全部删除 rm ‐rf /*         #【慎用！】将根目录下的所有文件全部删除 \n\n注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删 除任何目录或文件，都直接使用 rm ‐rf 目录&#x2F;文件&#x2F;压缩包 \n\n目录修改\n重命名目录\n命令：mv 当前目录 新目录 示例：mv aaa bbb    #将目录 aaa 改为 bbb    \n\n注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作。 \n\n\n剪切目录     \n命令：mv 目录名称 目录的新位置示例：mv /usr/tmp/aaa /usr  #将/usr/tmp 目录下的 aaa 目录剪切到 /usr 目录下面   \n\n注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。\n\n\n拷贝目录\n&gt;命令：cp ‐r  目录名称  目录拷贝的目标位置      ‐r 代表递归 &gt;示例：cp /usr/tmp/aaa    /usr   #将/usr/tmp 目录下的 aaa 目录复制到  /usr 目录下面 \n\n注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用 写‐r 递归。 \n\n目录检索\n命令：find  目录  参数  文件名称 示例：find /usr/tmp ‐name &#x27;a*&#x27;        #查找/usr/tmp 目录下的所有以 a 开头的目录或文件\n\n文件操作命令新建文件\n命令：touch  文件名 示例：touch    aa.txt      #在当前目录创建一个名为 aa.txt 的文件 \n\n删除文件\n命令：rm ‐rf  文件名 \n\n修改文件\n打开文件\nvi  文件名 示例：vi aa.txt  或者  vim aa.txt      #打开当前目录下的 aa.txt 文件 \n\n若文件不存在则新建文件并打开 \n注意：使用 vi 编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘 i&#x2F;a&#x2F;o 进入 编辑模式。 \n\n编辑文件\n使用 vi 编辑器打开文件后点击按键：i ，a 或者 o 即可进入编辑模式。\ni：在光标所在字符前开始插入\na：在光标所在字符后开始插入 \no：在光标所在行的下面另起一新行插入\n\n保存文件\n第一步：ESC  进入命令行模式 \n第二步：：进入底行模式 \n第三步：wq!  #保存并退出编辑 \n\n取消编辑\n第一步：ESC  进入命令行模式 \n第二步：：进入底行模式 \n第三步：q!   #撤销本次修改并退出编辑\n\n\n\n查看文件\n文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail \ncat：看最后一屏 示例：使用 cat 查看/etc/sudo.conf 文件，只能显示最后一屏内容。 cat sudo.conf \n\nmore：百分比显示 示例：使用 more 查看/etc/sudo.conf 文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q 可以退出查看 more sudo.conf \n\nless：翻页查看 示例：使用 less 查看/etc/sudo.conf 文件，可以使用键盘上的 PgUp 和 PgDn 向上和向下翻页，q 结束查看 less sudo.conf \n\ntail：指定行数或者动态查看 示例：使用 tail ‐10  查看/etc/sudo.conf 文件的后 10 行，Ctrl+C 结束     tail ‐10 sudo.conf \n\n","categories":["学习"],"tags":["知识总结","Linux"]},{"title":"stm32f407驱动BMX055记录","url":"/2024/11/14/BMX055/","content":"stm32f407驱动BMX055记录前两天BOSS交给我一个BMX055芯片让我试试能不能用\n真的就一个芯片\n\n长下面这样\n\n刚好学习一下如何使用没有模块化的芯片\n首先是接线问题，在网络上找不到现成的BMX055芯片连线连到stm32的接线图，在询问多个学长后得知有以下几种途径\n\n查技术手册\n在各个平台上搜索有用到这个芯片的模块\n\n技术手册首先可以在半导小芯等多个平台搜索这个芯片找到这个芯片的技术手册，中英文都可以，尽量看英文手册。\n为了方便可以直接在此下载 BMX055 技术手册\n然后找到你需要的接线，比如我需要用iic与之通讯，则找到iic的接线图如下：\n\n同时可以参考引脚定义来辅助接线\n\n在刚接线时别急着一次性就把他用好，而是先把基本的接线连好（可以先不连中断），然后先读chip id，确定基本的硬件连线没有问题，芯片上电之后可以工作，再去连中断线\n是的，我这个芯片连线就连了，拔了，连了，拔了重复了好几次，所以不要放弃，多试试吧\n\n\n接线完成了\n然后就是配置stm32f407的iic了\n网上搜到的大部分都是stm32f1的，所以我稍作修改，并添加了一些我自己写的函数，附在下面供大家取用\n\n&#x2F;&#x2F;myiic.c\n//myiic.c#include &quot;myiic.h&quot;#include &quot;delay.h&quot;//初始化IICvoid IIC_Init(void)&#123;\t\t\t  GPIO_InitTypeDef  GPIO_InitStructure;  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);//使能GPIOB时钟  //GPIOB8,B9初始化设置  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//初始化\tIIC_SCL=1;\tIIC_SDA=1;&#125;//产生IIC起始信号void IIC_Start(void)&#123;\tSDA_OUT();     //sda线输出\tIIC_SDA=1;\t  \t  \tIIC_SCL=1;\tdelay_us(4); \tIIC_SDA=0;//START:when CLK is high,DATA change form high to low \tdelay_us(4);\tIIC_SCL=0;//钳住I2C总线，准备发送或接收数据 &#125;\t  //产生IIC停止信号void IIC_Stop(void)&#123;\tSDA_OUT();//sda线输出\tIIC_SCL=0;\tIIC_SDA=0;//STOP:when CLK is high DATA change form low to high \tdelay_us(4);\tIIC_SCL=1; \tIIC_SDA=1;//发送I2C总线结束信号\tdelay_us(4);\t\t\t\t\t\t\t   \t&#125;//等待应答信号到来//返回值：1，接收应答失败//        0，接收应答成功u8 IIC_Wait_Ack(void)&#123;\tu8 ucErrTime=0;\tSDA_IN();      //SDA设置为输入  \tIIC_SDA=1;delay_us(1);\t   \tIIC_SCL=1;delay_us(1);\t \twhile(READ_SDA)\t&#123;\t\tucErrTime++;\t\tif(ucErrTime&gt;250)\t\t&#123;\t\t\tIIC_Stop();\t\t\treturn 1;\t\t&#125;\t&#125;\tIIC_SCL=0;//时钟输出0 \t   \treturn 0;  &#125; //产生ACK应答void IIC_Ack(void)&#123;\tIIC_SCL=0;\tSDA_OUT();\tIIC_SDA=0;\tdelay_us(2);\tIIC_SCL=1;\tdelay_us(2);\tIIC_SCL=0;&#125;//不产生ACK应答\t\t    void IIC_NAck(void)&#123;\tIIC_SCL=0;\tSDA_OUT();\tIIC_SDA=1;\tdelay_us(2);\tIIC_SCL=1;\tdelay_us(2);\tIIC_SCL=0;&#125;\t\t\t\t\t \t\t\t\t     //IIC发送一个字节//返回从机有无应答//1，有应答//0，无应答\t\t\t  void IIC_Send_Byte(u8 txd)&#123;                            u8 t;   \tSDA_OUT(); \t        IIC_SCL=0;//拉低时钟开始数据传输    for(t=0;t&lt;8;t++)    &#123;                      IIC_SDA=(txd&amp;0x80)&gt;&gt;7;        txd&lt;&lt;=1; \t  \t\tdelay_us(2);   //对TEA5767这三个延时都是必须的\t\tIIC_SCL=1;\t\tdelay_us(2); \t\tIIC_SCL=0;\t\t\tdelay_us(2);    &#125;\t &#125; \t    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   u8 IIC_Read_Byte(unsigned char ack)&#123;\tunsigned char i,receive=0;\tSDA_IN();//SDA设置为输入    for(i=0;i&lt;8;i++ )\t&#123;        IIC_SCL=0;         delay_us(2);\t\tIIC_SCL=1;        receive&lt;&lt;=1;        if(READ_SDA)receive++;   \t\tdelay_us(1);     &#125;\t\t\t\t\t     if (!ack)        IIC_NAck();//发送nACK    else        IIC_Ack(); //发送ACK       return receive;&#125;void WriteData(u8 DevID,u8 Addr,u8 Dat)&#123;\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1| 0);\t//发送设备地址和写信号\tIIC_Wait_Ack();\tIIC_Send_Byte(Addr);\tIIC_Wait_Ack();\tIIC_Send_Byte(Dat);\tIIC_Wait_Ack();\tIIC_Stop();\tdelay_ms(10);&#125;void ReadData(u8 DevID,u8 Addr,u8 *Pbuf,u8 Num)&#123;\tu8 i;\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1 | 0);\t//发送设备地址和写信号\tIIC_Wait_Ack();\tIIC_Send_Byte(Addr);\tIIC_Wait_Ack();\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1 | 1);\t//发送设备地址和读信号\tIIC_Wait_Ack();\tfor(i = 0;i &lt; (Num - 1);i ++)\t&#123;\t\tPbuf[i] = IIC_Read_Byte(1);\t&#125;\tPbuf[i] = IIC_Read_Byte(0);\tIIC_Stop();\tdelay_ms(5);&#125;\n\n\n&#x2F;&#x2F;myiic.h\n//myiic.h#ifndef __MYIIC_H#define __MYIIC_H#include &quot;sys.h&quot;    \t   \t\t   //IO方向设置#define SDA_IN()  &#123;GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(9*2));GPIOB-&gt;MODER|=0&lt;&lt;9*2;&#125;\t//PB9输入模式#define SDA_OUT() &#123;GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(9*2));GPIOB-&gt;MODER|=1&lt;&lt;9*2;&#125; //PB9输出模式//IO操作函数\t #define IIC_SCL    PBout(8) //SCL#define IIC_SDA    PBout(9) //SDA\t #define READ_SDA   PBin(9)  //输入SDA //IIC所有操作函数void IIC_Init(void);                //初始化IIC的IO口\t\t\t\t void IIC_Start(void);\t\t\t\t//发送IIC开始信号void IIC_Stop(void);\t  \t\t\t//发送IIC停止信号void IIC_Send_Byte(u8 txd);\t\t\t//IIC发送一个字节u8 IIC_Read_Byte(unsigned char ack);//IIC读取一个字节u8 IIC_Wait_Ack(void); \t\t\t\t//IIC等待ACK信号void IIC_Ack(void);\t\t\t\t\t//IIC发送ACK信号void IIC_NAck(void);\t\t\t\t//IIC不发送ACK信号void IIC_Write_One_Byte(u8 daddr,u8 addr,u8 data);u8 IIC_Read_One_Byte(u8 daddr,u8 addr);\t  void WriteData(u8 DevID,u8 Addr,u8 Dat);void ReadData(u8 DevID,u8 Addr,u8 *Pbuf,u8 Num);#endif\n\n\n接下来就是参考芯片技术手册，编写初始化函数等，通过iic与之通讯\n&#x2F;&#x2F;BMX055.c\n//BMX055.c#include &quot;usart.h&quot;#include &quot;BMX055.h&quot;#include &quot;myiic.h&quot;void IMU_Init(void)&#123;\tWriteData(Acc_addr,0x0F, 0x03);//reset \t\t复位acc\tWriteData(Acc_addr,0x10, 0x08);//+/- 16g\t设置acc的测量范围\tWriteData(Acc_addr,0x11, 0x00);\tdelay_us(100);\tWriteData(Gyro_addr,0x0F, 0x04);\tWriteData(Gyro_addr,0x10, 0x07);// 500\tWriteData(Gyro_addr,0x11, 0x00);\tdelay_us(100);\tWriteData(Mag_addr,0x4B, 0x83);\tdelay_us(100);\tWriteData(Mag_addr,0x4B, 0x01);\tdelay_us(100);\tWriteData(Mag_addr, 0x4c, 0x00); //00000000\t\t将mag由sleep mode切换到normal mode（active）\tWriteData(Mag_addr, 0x4E, 0x84);\tWriteData(Mag_addr, 0x51, 0x04);\tWriteData(Mag_addr, 0x52, 0x16);\tdelay_us(100);&#125;// 初始化BMX055加速度计void BMX055_Init_Accelerometer() &#123; WriteData(Acc_addr, 0x0F, 0x03); // 设置范围为±2g WriteData(Acc_addr, 0x10, 0x08); // 设置带宽为7.81 Hz WriteData(Acc_addr, 0x11, 0x00); // 正常模式，睡眠时长0.5ms delay_us(100000); // 延迟等待配置生效&#125;// 初始化BMX055陀螺仪void BMX055_Init_Gyroscope() &#123; WriteData(Gyro_addr, 0x0F, 0x04); // 设置范围为±125度/秒 WriteData(Gyro_addr, 0x10, 0x07); // 设置输出数据速率为100 Hz WriteData(Gyro_addr, 0x11, 0x00); // 正常模式，睡眠时长2msdelay_us(100000); // 延迟等待配置生效&#125;// 初始化BMX055磁力计void BMX055_Init_Magnetometer() &#123; WriteData(Mag_addr, 0x4B, 0x83); // 软复位 WriteData(Mag_addr, 0x4C, 0x00); // 正常模式，输出数据速率为10 Hz WriteData(Mag_addr, 0x4E, 0x84); // 启用X、Y、Z轴 WriteData(Mag_addr, 0x51, 0x04); // 设置X-Y轴重复次数为9 WriteData(Mag_addr, 0x52, 0x0F); // 设置Z轴重复次数为15delay_us(100000); // 延迟等待配置生效&#125;// 读取加速度计数据void BMX055_Read_Accelerometer(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Acc_addr, 0x02, data, 6); *x = (int16_t)((data[1] &lt;&lt; 8) | (data[0] &amp; 0xF0)) &gt;&gt; 4; // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 8) | (data[2] &amp; 0xF0)) &gt;&gt; 4; // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 8) | (data[4] &amp; 0xF0)) &gt;&gt; 4; // Z轴数据 if (*x &gt; 2047) *x -= 4096; // 负值处理 if (*y &gt; 2047) *y -= 4096; if (*z &gt; 2047) *z -= 4096;&#125;// 读取陀螺仪数据void BMX055_Read_Gyroscope(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Gyro_addr, 0x02, data, 6); *x = (int16_t)((data[1] &lt;&lt; 8) | data[0]); // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 8) | data[2]); // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 8) | data[4]); // Z轴数据 if (*x &gt; 32767) *x -= 65536; // 负值处理 if (*y &gt; 32767) *y -= 65536; if (*z &gt; 32767) *z -= 65536;&#125;// 读取磁力计数据void BMX055_Read_Magnetometer(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Mag_addr, 0x42, data, 6); *x = (int16_t)((data[1] &lt;&lt; 5) | (data[0] &gt;&gt; 3)); // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 5) | (data[2] &gt;&gt; 3)); // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 7) | (data[4] &gt;&gt; 1)); // Z轴数据 if (*x &gt; 4095) *x -= 8192;  // 负值处理 if (*y &gt; 4095) *y -= 8192; if (*z &gt; 16383) *z -= 32768;&#125;// 读取所有传感器数据的示例void BMX055_Read_All() &#123; int16_t xAccl, yAccl, zAccl; int16_t xGyro, yGyro, zGyro; int16_t xMag, yMag, zMag; BMX055_Read_Accelerometer(&amp;xAccl, &amp;yAccl, &amp;zAccl); // 读取加速度计数据 BMX055_Read_Gyroscope(&amp;xGyro, &amp;yGyro, &amp;zGyro); // 读取陀螺仪数据 BMX055_Read_Magnetometer(&amp;xMag, &amp;yMag, &amp;zMag); // 读取磁力计数据 printf(&quot;加速度 X: %d, Y: %d, Z: %d\\n&quot;, xAccl, yAccl, zAccl); printf(&quot;陀螺仪 X: %d, Y: %d, Z: %d\\n&quot;, xGyro, yGyro, zGyro); printf(&quot;磁场 X: %d, Y: %d, Z: %d\\n&quot;, xMag, yMag, zMag);&#125;// 读取chip idvoid BMX055_Read_Chip_Id() &#123; uint8_t data; ReadData(Acc_addr, 0x00, &amp;data, 1);  // 使用指针传递data printf(&quot;Acc_addr chip_id:%d\\n&quot;, data); ReadData(Gyro_addr, 0x00, &amp;data, 1); printf(&quot;Gyro_addr chip_id:%d\\n&quot;, data); ReadData(Mag_addr, 0x40, &amp;data, 1); printf(&quot;Mag_addr chip_id:%d\\n&quot;, data);&#125;\n\n\n&#x2F;&#x2F;BMX055.h\n//BMX055.h#ifndef __BMX055_H#define __BMX055_H#include &quot;stm32f4xx.h&quot;#include &quot;sys.h&quot; #define AccSen\t\t\t\t\t\t\t0.0078125\t//g/lsb @ +/- 16g#define GyroSen\t\t\t\t\t\t\t0.01524\t\t//°/s/lsb @ 500#define TempSen\t\t\t\t\t\t\t0.5\t\t\t//K/LSB center temperature is 23℃#define MagxySen\t\t\t\t\t\t0.3\t\t\t//uT/lsb#define MagzSen\t\t\t\t\t\t\t0.15\t\t//uT/lsb//SDO1 SDO2 CSB3 pulled to GND#define Acc_addr\t\t\t\t\t\t0x18 #define Gyro_addr\t\t\t\t\t\t0x68 #define Mag_addr\t\t\t\t\t\t0x10 /* BMX055 Register Map *///ACC define#define\tACC_ID\t\t\t\t\t\t\t0x00\t//OXFA#define\tACC_XL\t\t\t\t\t\t\t0x02#define\tACC_XM\t\t\t\t\t\t\t0x03#define\tACC_YL\t\t\t\t\t\t\t0x04#define\tACC_YM\t\t\t\t\t\t\t0x05#define\tACC_ZL\t\t\t\t\t\t\t0x06#define\tACC_ZM\t\t\t\t\t\t\t0x07#define\tTemp\t\t\t\t\t\t\t0x08#define ACC_range\t\t\t\t\t\t0x0f\t//1100b --&gt; +/- 16g#define Shasow_dis\t\t\t\t\t\t0x13#define ACC_ret\t\t\t\t\t\t\t0x14\t//write 0xb6//Gyro define#define\tGYRO_ID\t\t\t\t\t\t\t0x00\t//OXOF#define\tGYRO_XL\t\t\t\t\t\t\t0x02#define\tGYRO_XM\t\t\t\t\t\t\t0x03#define\tGYRO_YL\t\t\t\t\t\t\t0x04#define\tGYRO_YM\t\t\t\t\t\t\t0x05#define\tGYRO_ZL\t\t\t\t\t\t\t0x06#define\tGYRO_ZM\t\t\t\t\t\t\t0x07#define GYRO_range\t\t\t\t\t\t0x0f\t//010b --&gt; +/- 500°/s#define GYRO_ret\t\t\t\t\t\t0x14\t//write 0xb6#define GYRO_OFFSET_reset\t\t\t\t0x21\t//writing 1 to the (0x21) offset_reset bit, all dynamic offset compensation register are reset to zero#define GYRO_SLOW_OFFSET_EN\t\t\t\t0x31\t//EN: &lt;0:2&gt; x/y/z Adjustable rate: &lt;7:6&gt; Time_period &lt;5:3&gt;#define GYRO_SLOW_OFFSET_UNFILT\t\t\t0x1A\t//&lt;5&gt;#define GYRO_FAST_OFFSET_EN\t\t\t\t0x32\t//EN: &lt;0:2&gt; x/y/z Cancellation Start: &lt;3&gt; (if the algorithm finished, &lt;3&gt;will reset to 0) Time_period &lt;5:3&gt;#define GYRO_FAST_OFFSET_UNFILT\t\t\t0x1A\t//&lt;5&gt;#define GYRO_X_OFFSET\t\t\t\t\t0x36#define GYRO_Y_OFFSET\t\t\t\t\t0x37#define GYRO_Z_OFFSET\t\t\t\t\t0x38//MAG define 8bits register 0x40 - 0x71// 0X40 - 0X4A read only#define\tMAG_ID\t\t\t\t\t\t\t0x40\t//OX32#define\tMAG_XL\t\t\t\t\t\t\t0x42\t//read only: data x[4:0]  lsb #define\tMAG_XM\t\t\t\t\t\t\t0x43\t//read only: data x[12:5] msb  x-self-test#define\tMAG_YL\t\t\t\t\t\t\t0x44\t//read only: data x[4:0]  lsb #define\tMAG_YM\t\t\t\t\t\t\t0x45\t//read only: data x[12:5] msb  Y-self-test#define\tMAG_ZL\t\t\t\t\t\t\t0x46\t//read only: data x[4:0]  lsb#define\tMAG_ZM\t\t\t\t\t\t\t0x47\t//read only: data x[12:5] msb  Z-self-test#define\tMAG_RHAL\t\t\t\t\t\t0x48#define\tMAG_RHAM\t\t\t\t\t\t0x49#define MAG_ret\t\t\t\t\t\t\t0x4b\t//1000 0001b bring the device into sleep mode, 操作完成后，自动变为00#define MAG_OPC\t\t\t\t\t\t\t0x4Cvoid IMU_Init(void);void BMX055_Init_Accelerometer();void BMX055_Init_Gyroscope();void BMX055_Init_Magnetometer();void BMX055_Read_Accelerometer(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_Gyroscope(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_Magnetometer(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_All();void BMX055_Read_Chip_Id();#endif\n\n\n\n然后就可以通过stm32f407与bmx055进行iic通讯了\n先试试chip id能不能读出来，能读出来再去读取其他的数据\n用到芯片的模块如果实在不会接线或者希望更快的使用这个芯片，可以找找有用到这个芯片的模块\n例如下面这个模块\n\n可以直接参考这个模块的接线方式进行\n然后先把程序在这个模块上跑跑能不能成功运行\n可以的话再在自己接好线的芯片上试试\n","categories":["学习"],"tags":["硬件","stm32f407"]},{"title":"祝birdking生日快乐！！！","url":"/2024/10/28/birdking-is-so-cool/","content":"\n\n急着睡觉，就先祝他生日快乐吧 !\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"算法题的错题整理及反思","url":"/2024/10/27/algorithm/","content":"这是关于算法题的错题整理及反思题目来源不一定，主要来源应该是CF、洛谷等\n也会包含一些关于比赛的反思等\n水平较低哈哈哈哈哈哈哈哈哈，还在尝试中\n\nCodeforces Round 982 (Div. 2) B标签：\n\n\n暴力枚举（brute force）\n贪心（greedy）\n\n\n题目：\n\n\nProblem-B-Codeforces\nStalin Sort-洛谷\n\n\n题目大意\n\n给出一个数组，问是否可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的。\n*子数组指的是任意一段连续子数组，斯大林排序指将严格降序的元素剔除，具体定义见题目\n\n思路分析：\n\n通过斯大林排序的定义可知\n\n任何一段数组进行斯大林排序后第一个元素都不会改变\n\n如果处理完的数组元素大于等于两个，则按非降序排列\n\n\n进一步分析\n\n对于使用斯大林排序的任意子数组，如果存在大于第一个元素的其他元素则会被保留，而小于第一个元素的一定会被剔除因此要使最后是非降序的，就必须要把子数组中大于第一个元素的其他元素都剔除掉\n那么要使剔除后的数组是可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的就要使剔除后的数组的首元素最大\n接下来只需要从头遍历整个数组，找到有最多元素的满足首元素最大的数组（不一定连续）即可\n即对数组中的每个元素寻找有多少个（k）在他之后的不大于他的元素，并记录下最大值（f）\n将元素总个数减去（最大值+1）就是其他要剔除的元素的个数\n\n\n\n        \n            \n            \n            可能的疑问\n\n        \n        \n问题一：对每个元素只考虑后面的其他元素，为什么不用考虑前面的其他元素就把他们全部剔除\n答：\n\n如果前面的元素大于等于该元素，则前面元素遍历时的值k1就会大于该值k2，那么f就会等于k1，不影响\n如果前面的元素小于该元素，则必须剔除，否则剔除后的数组的首元素就不是最大的，那么就不满足要求\n\n\n\n        \n\n思路误区：\n\n比赛时想的是减序列通过斯大林排序一定会消失，所以先对整个数组进行一次斯大林排序，得到非减序列，再把第一次出现的最大值前的元素全部剔除掉，那么剩下的就是非增序列了，问题在于在第一次通过斯大林排序时删掉的元素仍在剔除元素后的数组之中，此时数组还可能存在递增序列，不满足题意很烦的是样例给的随便过，比赛时一直没找到问题所在\n\n代码：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    int t;    cin &gt;&gt; t; // 读取测试用例数量      while (t--)    &#123;        int n;        cin &gt;&gt; n;        int* a = new int[n + 1];        for (int i = 0; i &lt; n; i++)        &#123;            cin &gt;&gt; a[i];        &#125;        int f = 0;        for (int i = 0; i &lt; n - 1; i++)        &#123;            int k = 0;            for (int j = i + 1; j &lt; n; j++)            &#123;                if (a[j] &lt;= a[i])                    k++;            &#125;            f = max(f, k);        &#125;        cout &lt;&lt; n - (f + 1) &lt;&lt; endl;        delete[] a;    &#125;    return 0;&#125;\n\n\n\n","categories":["学习"],"tags":["算法","错题整理"]},{"title":"复制黏贴出错原因分析","url":"/2024/11/20/copy_wrong/","content":"复制黏贴出错原因分析最近我在进行复制黏贴时出现了多次的错误\n一次是复制一个网址，黏贴看上去也没问题，但是就是跳转不到对应的网页，直到我将他在记事本中黏贴时才发现其变成了一堆乱码\n还有一次是我在网页上拷贝代码，将代码黏贴后看上去也没有任何问题，但就是运行时报错，每一行都报无法识别命令的错\n因此在此记录该问题，并简要分析复制黏贴出错原因\n推荐大家复制黏贴不行时试试自己输入，后续找到克服问题的方法会在此提出，或者尝试下列措施\n\n首先先分析一下为什么复制黏贴会出错\n复制粘贴内容出现不一致或变成乱码的原因可能与以下因素有关：\n1. 字符编码问题\n不同的软件或系统使用的字符编码方式可能不一致（例如 UTF-8、GB2312 等）。当粘贴的内容被另一个程序读取时，如果解码方式不一致，就会导致乱码。\n解决方法：确保复制和粘贴的两端使用相同的字符编码。如果是文档，保存为 UTF-8 通常兼容性较好。\n\n2. 格式问题\n复制的内容可能包含不可见的格式化信息（如字体、颜色、样式等），但目标软件不支持这些格式，可能导致显示异常或部分信息丢失。\n解决方法：尝试使用“纯文本”粘贴（通常是通过 Ctrl+Shift+V 或选择“仅粘贴文本”选项）。\n\n3. 源数据限制\n某些软件（如网页）可能会在复制时附加隐藏代码或广告内容，导致粘贴后出现意外结果。（真可恶）\n解决方法：先粘贴到一个纯文本编辑器（如记事本）中清除多余信息，然后再复制到目标位置。\n\n4. 语言和区域设置冲突\n如果系统的语言或区域设置与粘贴内容不匹配，可能会导致显示不正确。例如，中文文本在未启用中文支持的环境中可能会变成乱码。\n解决方法：检查系统的语言和区域设置，确保支持复制内容的语言。\n\n5. 特殊字符或符号\n某些特殊字符或符号可能在不同的软件或系统中显示效果不同，甚至可能直接变成乱码。\n解决方法：尽量避免使用过多特殊字符，或者确认目标软件是否支持这些字符。\n\n6. 跨平台兼容性问题\nWindows、macOS 和 Linux 之间在处理换行符、制表符等特殊格式时可能存在差异，导致粘贴内容变形。\n解决方法：在跨平台操作时，使用通用工具或格式化工具（如转换成纯文本）处理内容。\n\n7. 剪贴板问题\n剪贴板有时会因为数据量过大或软件冲突而无法正确复制和粘贴。\n解决方法：清空剪贴板后重新操作，或者使用专门的剪贴板管理工具（如 ClipClip）。\n\n8. 目标程序的限制\n某些程序在粘贴时会主动过滤内容或重构格式，导致粘贴结果不同。\n解决方法：尝试不同的粘贴方式，或者检查程序的粘贴选项设置。\n\n","categories":["学习"],"tags":["计算机问题"]},{"title":"祝chq生日快乐！！！","url":"/2024/10/14/chq-birthday/","content":"\n\n放一首可能不是他最喜欢的但是应该还是比较合适的歌\n\n\n\n\n\n\n祝chq生日快乐！！\n\n\n刷新一下显示滚动彩色祝福语\n\n  \n    \n  \n    var binft = function (r) {\n      function t() {\n        return b[Math.floor(Math.random() * b.length)]\n      }  \n      function e() {\n        return String.fromCharCode(94 * Math.random() + 33)\n      }\n      function n(r) {\n        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {\n          var l = document.createElement(\"span\");\n          l.textContent = e(), l.style.color = t(), n.appendChild(l)\n        }\n        return n\n      }\n      function i() {\n        var t = o[c.skillI];\n        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)\n      }\n      var l = \"\",\n      o = [\"祝chq生日快乐！！！！！！\",\"希望二十岁的你可以爱你所爱\",\"做自己喜欢的事\"].map(function (r) {\n      return r + \"\"\n      }),\n      a = 15,//文字保留时间\n      g = 1,//文字出现速度 越大越慢\n      s = 4,//乱码长度\n      d = 50,//单个乱码展示时间\n      b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n      c = {\n        text: \"\",\n        prefixP: -s,\n        skillI: 0,\n        skillP: 0,\n        direction: \"forward\",\n        delay: a,\n        step: g\n      };\n      i()\n      };\n      binft(document.getElementById('binft'));\n   \n","categories":["记录生活"],"tags":["杂谈"]},{"title":"离散考试考点预测","url":"/2024/10/28/discrete-mathematics/","content":"这是关于离散考试大概率考点的预测首先声明因为是对大概率考点的预测，因此不能保证覆盖期末考的所有考点\n最好的复习方式还是看 PPT，看学习通的作业，看课本，其次才是看这个。\n虽然书上和PPT上错误挺多的\n\n你可以将其他复习方式与该文档结合以此来有重点地复习。   \n本文档由我独立编写，难免会出现错误，欢迎指正，本文档也会持续更新补充。\n也可以点击链接下载PDF文件 离散考点预测PDF版 （后续应该还会更新）\n\n标1越多，在往年出现越多次，考的可能性越大\n\n填空题\n\n求零元、幺元（单位元）、逆元 1111111111\n求循环群中某个元素是几阶元素、循环群的性质 1\n已知群的阶数，求各种子群 1\n群中的运算 1\n顶点、边、度数的关系 11111\n已知格，求某个元素的补元\nn阶完全图的边数、度数、着色数 111111\n求邻接矩阵及其幂 111\n求补图、对偶图 \n判断哪个是格以及哪种格 1\n公式的根树表示 1\n半群、独异点、群的性质判断 11\n求运算表\n\n\n其他具体题\n\n\n四阶群必是（Klein）群或（循环）群\n说明欧拉图的充要条件是（图中无奇结点且连通）\n群是阿贝尔群的充要条件（）\n一个图是平面图的充要条件（不包含K3,3或K5同构的子图）\n\n\n选择题\n\n点、线、面的关系\n素数阶群一定是什么群\n求图中长度为定长的路径有几条 11\n判断Euler图（不重复走完所有边回到原点、图中无奇结点且连通）1111\n判断Hamilton图（不重复走完所有顶点回到原点）11\n求树某度结点的个数 11111\n判断哪个是域 111\n判断哪个是整环 11\n判断哪个是格以及格的相关性质 111111111\n布尔代数的性质 111\n求格的补元\n判断哪个是群、独异点、半群以及性质等 1111\n能构成无向简单图（无自环、无重边）的度数列 1\n求零元、幺元、逆元 1111\n求补图 1\n求邻接矩阵\n判断简单图\n运算的封闭性 11\n度数、边数的关系\n子群阶数\n\n\n证明题\n\n证明是子群\n证明是群\n证明非平面图、平面图 1\n若无向图只有两个奇数度结点，证明两个结点一定连通 11\n证明是Hamilton图\n求子群以及相应的左陪集 1\n中国邮递员问题 11\n造路问题 11\n最优二叉树 1\n二元前缀码  1\n最优前缀码（最优二叉树、频率越高前缀码越短）11\n在至少有2个顶点的图中，证明至少有两个顶点度数相等 1\n证明6个结点12条边的连通平面简单图中，每个面的面度都是3 1\n证明某某（大概率是循环群）的同态像&#x2F;任意非平凡子群必是某某 111\n证明是阿贝尔群 1\n顶点、边数、面数、度数关系 11\n证明是环且域 11\n证明不是整环\n证明是格\n证明连通性 11\n证明独异点和幺元\n证明是布尔代数 11\n求运算表、幺元、逆元、零元 1\n证明同态映射的传递性\n图着色问题\n求可达性矩阵\n二部图完美匹配问题\n构造结点和边奇偶性相反的欧拉图\n\n\n附录可以发现虽然每种题型都有很多可能的考点，但是其中有许多重合的部分\n对于重合的部分我们就可以重点复习\n附上我整理的纸质版照片\n忙。。。。。。\n\n\n\n\n","categories":["学习"],"tags":["离散","考点预测"]},{"title":"杂谈","url":"/2024/02/09/my-first-blog/","content":"这是我的第一个博客嘿嘿嘿\n\n\n这是我的第一个 Blog\n但是我不知道写什么哈哈哈哈哈\n\n\n目前还在测试中\n\n\n如果你感觉无聊你可以看看B站 \n\n关于后续后续我将会发布有关于IT技术、生活等方面的内容，不过我觉得应该不会有什么人看的，所以水一水(雾)。\n关于为什么写博客有两个理由，一个是为了装*，另一个还是为了装*哈哈哈哈哈哈哈哈哈。\n\n好了，正经一点\n\n其实是因为看见大神学长写博客所以突发奇想，想给自己做一个博客(好像还是不是什么正经理由嘿嘿嘿)\n\n时间有点来不及了，还有挺多事要做的，所以先写到这儿吧，现在要发布了(希望能发布成功)\n附一张我最爱的小猪的照片：\n \n再附一张铃兰和罗小黑的动图：\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"感谢大家","url":"/2024/10/02/thx/","content":"\n感谢我身边的大家，本博客的搭建离不开大家的建议和帮助。\n\n\n特此鸣谢\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"C++ STL常用内容总结","url":"/2024/10/29/stl/","content":"说明这是关于C++ STL常用内容总结\n强调使用方法，并不强调原理\n本篇博客是我用于个人学习总结用的\n\n\n大部分内容来源于网络和书本，因为是个人整理复习用所以就先不加了，如果后期看的人多我会加上的\n因为还有挺多课的，而且还有比赛和组里的任务，所以可能会不定期不定量更新\n内容可能有不全的，或错误的，欢迎批评指正\n目录主要包含下面几个STL函数\n\n\nvector 动态数组\nstack 栈\nqueue 队列\ndeque 双端队列\npriority_queue 优先队列\nmap 映射\nset 集合\npair 二元组\nstring 字符串\nbitset\narray 数组\ntuple 元组\n……\n\n\n这是目前的安排，计划在11.03前赶完，因为11.03要比赛，11.10还要考离散，中间还要把几次练习赛的题补了。（好忙）\n补：比赛也算是拿了银奖了\n被高中生爆杀\n\n目前（11.02）已将上述STL函数整理完成，算是按时提前完成了吧\n后续会增加一些常用的STL函数，例如sort等\n暂定在12.20前完成后续的补充\n话不多说，接下来进入正题吧\nSTL函数总结vector 动态数组介绍vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。\n\n注意：在局部区域中（比如局部函数里面）开vector数组，是在 堆空间 里面开的。\n在局部区域开 数组 是在 栈空间 开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。\n故局部区域 不可以 开大长度数组，但是可以开大长度vector。\n\n\n头文件：\n#include &lt;vector&gt;\n\n一维初始化：\nvector&lt;int&gt; a; //定义了一个名为a的一维数组,数组存储int类型数据vector&lt;double&gt; b;//定义了一个名为b的一维数组，数组存储double类型数据vector&lt;node&gt; c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型\n\n指定长度和初始值的初始化\nvector&lt;int&gt; v(n);// 定义一个长度为n的数组，初始值默认为0，下标范围 [0, n - 1]vector&lt;int&gt; v(n, 1);//定义一个长度为n的数组，下标范围 [0, n - 1], v[0] 到 v[n - 1]所有的元素初始值均为1//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）\n\n初始化中有多个元素\nvector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//数组a中有五个元素，数组长度就为5\n\n拷贝初始化\nvector&lt;int&gt; a(n + 1, 0);vector&lt;int&gt; b(a); // 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组vector&lt;int&gt; c = a; // 也是拷贝初始化,c和a是完全一样的数组\n\n二维初始化\n//定义第一维固定长度为5，第二维可变化的二维数组vector&lt;int&gt; v[5];//定义可变长二维数组//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素//第一维固定长度为5，第二维长度可以改变\n\n\nvector&lt;int&gt; v[5]可以这样理解：长度为5的v数组，数组中存储的是vector&lt;int&gt; 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：\nv[1].push_back(2);//第二行尾部增加一个元素 2v[2].push_back(3);//第三行尾部增加一个元素 3\n\n\n行列均可变\n//初始化二维均可变长数组vector&lt;vector&lt;int&gt;&gt; v;//定义一个行和列均可变的二维数组\n\n\n应用：可以在v数组里面装多个数组\nvector&lt;int&gt; t1&#123;1, 2, 3, 4&#125;;vector&lt;int&gt; t2&#123;2, 3, 4, 5&#125;;v.push_back(t1);v.push_back(t2);v.push_back(&#123;3, 4, 5, 6&#125;) // &#123;3, 4, 5, 6&#125;可以作为vector的初始化,相当于一个无名vector\n\n\n行列长度均固定\n\nn + 1行  m + 1列  初始值为0\nvector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//定义一个长度为 n+1 的数组，下标范围 [0, n - 1], a[0] 到 a[n - 1]所有的元素初始值均为vector&lt;int&gt;(m + 1, 0)\n\n\nc++17及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）\nvector a&#123;1, 2, 3, 4, 5&#125;; // 声明一个int类型动态数组，初识元素自己指定vector a(n + 1, vector(m + 1, 0));\n\n方法函数个人认为vector和数组的差距首先是存储位置不一样，vector是在堆空间，数组是在栈空间，其次就是vector中有许多方法函数，这些方法函数可以极大的方便我们编程，解题，不仅仅vector是这样的，其他STL函数也是。但是因为我才刚刚入门，这只是我的一种感觉，具体怎么等我多学一些，学深一些再来补充。先占个坑。\n知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。\nc指定为数组名称，含义中会注明算法复杂度。\n\n\n\n代码\n含义\n\n\n\nc.front()\n返回第一个数据O ( 1 )\n\n\nc.back()\n返回数组中的最后一个数据 O ( 1 )\n\n\nc.pop_back()\n删除最后一个数据O ( 1 )\n\n\nc.push_back(element)\n在尾部加一个数据O ( 1 )\n\n\nc.size()\n返回实际数据个数（unsigned类型）O ( 1 )\n\n\nc.clear()\n清除元素个数O ( N )，N为元素个数\n\n\nc.resize(n, v)\n改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0\n\n\nc.insert(it, x)\n向任意迭代器it（通俗来说就是地址）插入一个元素x ，O ( N )\n\n\nc.erase(first,last)\n删除[first,last)的所有元素，O ( N )\n\n\nc.begin()\n返回首元素的迭代器（通俗来说就是地址）O ( 1 )\n\n\nc.end()\n返回最后一个元素后一个位置的迭代器（地址）O ( 1 )\n\n\nc.empty()\n判断是否为空，为空返回真，反之返回假 O ( 1 )\n\n\n\n注意：\n\nend()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此\n\n使用 vi.resize(n, v) 函数时，若 vi 之前指定过大小为 pre\n\npre &gt; n ：即数组大小变小了，数组会保存前 n 个元素，前 n 个元素值为原来的值，不都变为 v\npre &lt; n ：即数组大小变大了，数组会在后面插入 n - pre 个值为 v 的元素\n\n也就是说，这个初始值 v 只对新插入的元素生效。\n#include&lt;bits/stdc++.h&gt;using namespace std;void out(vector&lt;int&gt; &amp;a) &#123; for (auto &amp;x: a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;\\n&quot;; &#125;int main() &#123;\tvector&lt;int&gt; a(5, 1);\tout(a); // 1 1 1 1 1\ta.resize(10, 2);\tout(a); // 1 1 1 1 1 2 2 2 2 2\ta.resize(3, 3);\tout(a); // 1 1 1\treturn 0;&#125;\n\n\n排序\n使用sort排序要： sort(c.begin(), c.end());\n\nsort()为STL函数，请参考本文最后面STL函数系列。\n\n对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。\nvector&lt;int&gt; a(n + 1);sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序\n\n访问共三种方法：\n\n下标法 ： 和普通数组一样\n\n注意：一维数组的下标是从 0 到 v.size()-1 ，访问之外的数会出现越界错误\n\n迭代器法 ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置\n\n使用auto ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）\n\n\n下标访问直接和普通数组一样进行访问即可。\n//添加元素for(int i = 0; i &lt; 5; i++)\tvi.push_back(i);\t//下标访问 for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n迭代器访问类似指针，迭代器就是充当指针的作用。\nvector&lt;int&gt; vi&#123;1, 2, 3, 4, 5&#125;;//迭代器访问vector&lt;int&gt;::iterator it;   // 相当于声明了一个迭代器类型的变量it// 通俗来说就是声明了一个指针变量\n\n\n方法一\nvector&lt;int&gt;::iterator it = vi.begin(); for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n方法二\nvector&lt;int&gt;::iterator it;for(it = vi.begin(); it != vi.end();it ++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;//vi.end()指向尾元素地址的下一个地址// 或者auto it = vi.begin();while (it != vi.end()) &#123;    cout &lt;&lt; *it &lt;&lt; &quot;\\n&quot;;    it++;&#125;\n\n智能指针只能遍历完数组，如果要指定的内容进行遍历，需要另选方法。\nauto 能够自动识别并获取类型。\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;    cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// for (auto &amp;x: a)：这是一个范围for循环，用于遍历向量a中的每个元素。auto关键字自动推导变量x的类型，这里x的类型将是int&amp;（整数的引用），因为我们在循环中使用了引用&amp;。使用引用的好处是可以直接修改向量中的元素值。// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;\tcout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\n\n\nvector注意：\n\nvi[i] 和 *(vi.begin() + i) 等价，与指针类似。\nvector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。\n\n\nstack 栈介绍栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。\n\n头文件\n//头文件需要添加#include&lt;stack&gt;\n\n声明\n//声明stack&lt;int&gt; s;stack&lt;string&gt; s;stack&lt;node&gt; s;//node是结构体类型\n\n方法函数\n\n\n代码\n含义\n\n\n\ns.push(ele)\n元素ele入栈，增加元素 O ( 1 )\n\n\ns.pop()\n移除栈顶元素 O ( 1 )\n\n\ns.top()\n取得栈顶元素（但不删除）O ( 1 )\n\n\ns.empty()\n检测栈内是否为空，空为真 O ( 1 )\n\n\ns.size()\n返回栈内元素的个数 O ( 1 )\n\n\n栈遍历栈遍历栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中\nstack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) &#123;    int tp = st.top(); // 栈顶元素    st.pop();&#125;\n\n数组模拟栈进行遍历通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n特点： 比STL的stack速度更快，遍历元素方便\nint s[100]; // 栈 从左至右为栈底到栈顶int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1for(int i = 0; i &lt;= 5; ++i) &#123;\t//入栈 \ts[++tt] = i;&#125;// 出栈int top_element = s[tt--]; //入栈操作示意//  0  1  2  3  4  5  //                tt//出栈后示意//  0  1  2  3  4 //              tt\n\nqueue 队列介绍队列是一种先进先出的数据结构。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n定义初始化\n//定义初始化queue&lt;int&gt; q;\n\n方法函数\n\n\n代码\n含义\n\n\n\nq.front()\n返回队首元素 O ( 1 )\n\n\nq.back()\n返回队尾元素 O ( 1 )\n\n\nq.push(element)\n尾部添加一个元素element 进队O ( 1 )\n\n\nq.pop()\n删除第一个元素 出队 O ( 1 )\n\n\nq.size()\n返回队列中元素个数，返回值类型unsigned int O ( 1 )\n\n\nq.empty()\n判断是否为空，队列为空，返回true O ( 1 )\n\n\n队列模拟使用q[]数组模拟队列\nhh表示队首元素的下标，初始值为0\ntt表示队尾元素的下标，初始值为-1，表示刚开始队列为空\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int q[N];int main() &#123;\tint hh = 0,tt = -1;//\t入队 \tq[++tt] = 1;\tq[++tt] = 2; //\t将所有元素出队 \twhile(hh &lt;= tt) &#123;\t\tint t = q[hh++];\t\tprintf(&quot;%d &quot;,t);\t&#125;\treturn 0; &#125; \n\ndeque  双端队列介绍首尾都可插入和删除的队列为双端队列。\n\n头文件\n//添加头文件#include&lt;deque&gt;\n\n初始化定义\n//初始化定义deque&lt;int&gt; dq;\n\n方法函数\n注意双端队列的常数比较大。\n\n\n\n\n代码\n含义\n\n\n\npush_back(x)&#x2F;push_front(x)\n把x插入队尾后 &#x2F; 队首 O ( 1 )\n\n\nback()&#x2F;front()\n返回队尾 &#x2F; 队首元素 O ( 1 )\n\n\npop_back() &#x2F; pop_front()\n删除队尾 &#x2F; 队首元素 O ( 1 )\n\n\nerase(iterator it)\n删除双端队列中的某一个元素\n\n\nerase(iterator first,iterator last)\n删除双端队列中[first,last)中的元素\n\n\nempty()\n判断deque是否空 O ( 1 )\n\n\nsize()\n返回deque的元素数量 O ( 1 )\n\n\nclear()\n清空deque\n\n\n注意点deque可以进行排序\n\n双端队列排序一般不用，感觉毫无用处，使用其他STL依然可以实现相同功能\n\n//从小到大sort(q.begin(), q.end())//从大到小排序sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型sort(q.begin(), q.end(), greater());//高版本C++才可以用\n\npriority_queue 优先队列介绍优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。\n可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。\n它的底层是通过堆来实现的。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n初始化\n//初始化定义priority_queue&lt;int&gt; q;\n\n函数方法\n\n\n代码\n含义\n\n\n\nq.top()\n访问队首元素 O ( 1 )\n\n\nq.push()\n入队 O ( l o g N )\n\n\nq.pop()\n堆顶（队首）元素出队 O ( l o g N )\n\n\nq.size()\n队列元素个数 O ( 1 )\n\n\nq.empty()\n是否为空 O ( 1 )\n\n\n注意没有clear()！不提供该方法\n优先队列只能通过top()访问队首元素（优先级最高的元素）\n设置优先级基本数据类型的优先级priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小根堆, 每次取出的元素是队列中的最小值\n\n参数解释：\n\n第一个参数：就是优先队列中存储的数据类型\n\n第二个参数：\nvector&lt;int&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector&lt;double&gt;总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。\n\n第三个参数：\nless&lt;int&gt; 表示数字大的优先级大，堆顶为最大的数字greater&lt;int&gt;表示数字小的优先级大，堆顶为最小的数字int代表的是数据类型，也要填优先队列中存储的数据类型\n\n\n\n\n基础写法（非常常用）：\npriority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值\n\n自定义排序（不常见，主要是写着麻烦）：\n下面的代码比较长，基础类型优先级写着太麻烦，用基础写法即可。\nstruct cmp1 &#123;\tbool operator()(int x, int y) &#123;\t\treturn x &gt; y;\t&#125;&#125;;struct cmp2 &#123;\tbool operator()(const int x, const int y) &#123;\t\treturn x &lt; y;\t&#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆\n\n高级数据类型(结构体)优先级\n即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。\n\n优先级设置可以定义在结构体内进行小于号重载，也可以定义在结构体外。\n//要排序的结构体（存储在优先队列里面的）struct Point &#123;\tint x, y;&#125;;\n\n\n版本一：自定义全局比较规则\n//定义的比较结构体//注意：cmp是个结构体 struct cmp &#123;//自定义堆的排序规则 \tbool operator()(const Point&amp; a,const Point&amp; b) &#123;\t\treturn a.x &lt; b.x;\t&#125;&#125;;//初始化定义， priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; // x大的在堆顶\n\n版本二：直接在结构体里面写\n\n因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。\n\n结构体内部有两种方式：\n\n方式一 ：\nstruct node &#123;\tint x, y;\tfriend bool operator &lt; (Point a, Point b) &#123;//为两个结构体参数，结构体调用一定要写上friend\t\treturn a.x &lt; b.x;//按x从小到大排，x大的在堆顶\t&#125;&#125;;\n\n方式二 ：（推荐此种）\nstruct node &#123;    int x, y;    bool operator &lt; (const Point &amp;a) const &#123;//直接传入一个参数，不必要写friend        return x &lt; a.x;//按x升序排列，x大的在堆顶    &#125;&#125;;\n\n优先队列的定义\npriority_queue&lt;Point&gt; q;\n\n注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是完全相反的。所以只需要记住sort的排序规则和优先队列的排序规则是相反的就可以了。\n\n当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 &gt; ，那么孩子节点要大于父亲节点，堆顶自然是最小值。\n\n\n\n\n\n存储特殊类型的优先级存储pair类型\n排序规则：默认先对pair的first进行降序排序，然后再对second降序排序对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    priority_queue&lt;pair&lt;int, int&gt; &gt;q;\tq.push(&#123;7, 8&#125;);\tq.push(&#123;7, 9&#125;);\tq.push(make_pair(8, 7));    while(!q.empty()) &#123;        cout &lt;&lt; q.top().first &lt;&lt; &quot; &quot; &lt;&lt; q.top().second &lt;&lt; &quot;\\n&quot;;        q.pop();    &#125;    return 0;&#125;\n\n\n结果：8 77 97 8\n\n\n\nmap 映射介绍映射类似于函数的对应关系，每个x对应一个y，而map是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。\n\n比如说：学习 对应 看书，学习 是键，看书 是值。学习-&gt;看书玩耍 对应 打游戏，玩耍 是键，打游戏 是值。玩耍-&gt;打游戏\n\n\n头文件\n//头文件#include&lt;map&gt;\n\n初始化\n//初始化定义map&lt;string, string&gt; mp;map&lt;string, int&gt; mp;map&lt;int, node&gt; mp;//node是结构体类型\n\n\nmap特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n\n\n\n函数方法\n\n\n代码\n含义\n\n\n\nmp.find(key)\n返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end ( )\n\n\nmp.erase(it)\n删除迭代器对应的键和值 O ( l o g N )\n\n\nmp.erase(key)\n根据映射的键删除键和值 O ( l o g N )\n\n\nmp.erase(first,last)\n删除左闭右开区间迭代器对应的键和值 O ( l a s t − f i r s t )\n\n\nmp.size()\n返回映射的对数 O (1)\n\n\nmp.clear()\n清空map中的所有元素 O ( N )\n\n\nmp.insert()\n插入元素，插入时要构造键值对\n\n\nmp.empty()\n如果map为空，返回true，否则返回false\n\n\nmp.begin()\n返回指向map第一个元素的迭代器（地址）\n\n\nmp.end()\n返回指向map尾部的迭代器（最后一个元素的下一个地址）\n\n\nmp.rbegin()\n返回指向map最后一个元素的迭代器（地址）\n\n\nmp.rend()\n返回指向map第一个元素前面(上一个）的逆向迭代器（地址）\n\n\nmp.count(key)\n查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0\n\n\nmp.lower_bound()\n返回一个迭代器，指向键值&gt;&#x3D; key的第一个元素\n\n\nmp.upper_bound()\n返回一个迭代器，指向键值&gt; key的第一个元素\n\n\n注意下面说明部分函数方法的注意点\n\n注意：查找元素是否存在时，可以使用①mp.find() ② mp.count() ③ mp[key]但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间）所以为了不增加额外的空间负担，最好使用前两种方法\n\n迭代器进行正反向遍历\nmp.begin()和mp.end()用法：\n用于正向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.begin();while(it != mp.end()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n1 22 33 4\n\nmp.rbegin()和mp.rend()用法：\n用于逆向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.rbegin();while(it != mp.rend()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n3 42 31 2\n\n二分查找二分查找lower_bound() upper_bound()\n\nmap的二分查找以第一个元素（即键为准），对键进行二分查找返回值为map迭代器类型\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tmap&lt;int, int&gt; m&#123;&#123;1, 2&#125;, &#123;2, 2&#125;, &#123;1, 2&#125;, &#123;8, 2&#125;, &#123;6, 2&#125;&#125;;//有序\tmap&lt;int, int&gt;::iterator it1 = m.lower_bound(2);\tcout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\\n&quot;;//it1-&gt;first=2\tmap&lt;int, int&gt;::iterator it2 = m.upper_bound(2);\tcout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\\n&quot;;//it2-&gt;first=6\treturn 0;&#125;\n\n添加元素//先声明map&lt;string, string&gt; mp;\n\n\n方式一：\nmp[&quot;学习&quot;] = &quot;看书&quot;;mp[&quot;玩耍&quot;] = &quot;打游戏&quot;;\n\n方式二：插入元素构造键值对\nmp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));\n\n方式三：\nmp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));\n\n方式四:\nmp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);\n\n访问元素下标访问(大部分情况用于访问单个元素)\nmp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\\n&quot;;//只是简写的一个例子，程序并不完整\n\n遍历访问\n方式一：迭代器访问\nmap&lt;string,string&gt;::iterator it;for(it = mp.begin(); it != mp.end(); it++) &#123;\t//      键                 值 \t// it是结构体指针访问所以要用 -&gt; 访问\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\t//*it是结构体变量 访问要用 . 访问\t//cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;&#125;\n\n方式二：智能指针访问\nfor(auto i : mp)cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值\n\n方式三：对指定单个元素访问\nmap&lt;char,int&gt;::iterator it = mp.find(&#x27;a&#x27;);cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\\n&quot;;\n\n方式四：c++17特性才具有\nfor(auto [x, y] : mp)\tcout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\\n&quot;;//x,y对应键和值\n\n与unordered_map的比较这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n内部实现原理map：内部用红黑树实现，具有自动排序（按键从小到大）功能。\nunordered_map：内部用哈希表实现，内部元素无序杂乱。\n效率比较map：\n\n优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N)\n缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。\n\nunordered_map：\n\n优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n缺点：建立哈希表比较耗时。\n\n\n两者方法函数基本一样，差别不大。\n注意：\n\n随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n\n使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。\n\n查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n// 以 map 为例map&lt;int, int&gt; mp;int x = 999999999;if(mp.count(x)) // 此处判断是否存在x这个键    cout &lt;&lt; mp[x] &lt;&lt; &quot;\\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建\n\n\n另外：\n\n还有一种映射：multimap\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n\nset 集合介绍set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n即：set里面的元素不重复 且有序\n\n头文件\n//头文件#include&lt;set&gt;\n\n初始化\n//初始化定义set&lt;int&gt; s;\n\n函数方法\n\n\n代码\n含义\n\n\n\ns.begin()\n返回set容器的第一个元素的地址（迭代器）O ( 1 )\n\n\ns.end()\n返回set容器的最后一个元素的下一个地址（迭代器）O ( 1 )\n\n\ns.rbegin()\n返回逆序迭代器，指向容器元素最后一个位置O ( 1 )\n\n\ns.rend()\n返回逆序迭代器，指向容器第一个元素前面的位置O ( 1 )\n\n\ns.clear()\n删除set容器中的所有的元素\n\n\ns.empty()\n判断set容器是否为空O ( 1 )\n\n\ns.insert()\n插入一个元素\n\n\ns.size()\n返回当前set容器中的元素个数O ( 1 )\n\n\nerase(iterator)\n删除定位器iterator指向的值\n\n\nerase(first,second）\n删除定位器first和second之间的值\n\n\nerase(key_value)\n删除键值key_value的值\n\n\ns.find(element)\n查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器\n\n\ns.count(element)\n查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现\n\n\ns.lower_bound(k)\n返回&gt;&#x3D;k的第一个元素的迭代器O ( l o g N )\n\n\ns.upper_bound(k)\n返回&gt;k的第一个元素的迭代器O ( l o g N )\n\n\n访问\n迭代器访问\nfor(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n智能指针\nfor(auto i : s)\tcout &lt;&lt; i &lt;&lt; endl;\n\n访问最后一个元素\n//第一种cout &lt;&lt; *s.rbegin() &lt;&lt; endl;\n\n //第二种set&lt;int&gt;::iterator iter = s.end();iter--;cout &lt;&lt; (*iter) &lt;&lt; endl; //打印2;\n\n//第三种cout &lt;&lt; *(--s.end()) &lt;&lt; endl;\n\n重载&lt;运算符\n基础数据类型\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\nset&lt;int&gt; s1; // 默认从小到大排序set&lt;int, greater&lt;int&gt; &gt; s2; // 从大到小排序\n\n方式二：重载运算符。（很麻烦，不太常用，没必要）\n//重载 &lt; 运算符struct cmp &#123;    bool operator () (const int&amp; u, const int&amp; v) const &#123;       // return + 返回条件       return u &gt; v;    &#125;&#125;;set&lt;int, cmp&gt; s; for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto i : s)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;// 10 9 8 7 6 5 4 3 2 1\n\n方式三：初始化时使用匿名函数定义比较规则\nset&lt;int, function&lt;bool(int, int)&gt;&gt; s([&amp;](int i, int j)&#123;    return i &gt; j; // 从大到小&#125;);for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto x : s)    cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n\n高级数据类型（结构体）\n直接重载结构体运算符即可，让结构体可以比较。\nstruct Point &#123;\tint x, y;\tbool operator &lt; (const Point &amp;p) const &#123;\t\t// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\t\tif(x == p.x)\t\t\treturn y &lt; p.y;\t\treturn x &lt; p.x;\t&#125;&#125;;set&lt;Point&gt; s;for(int i = 1; i &lt;= 5; i++) &#123;    int x, y;    cin &gt;&gt; x &gt;&gt; y;    s.insert(&#123;x, y&#125;);&#125;\t/* 输入5 45 23 73 54 8*/for(auto i : s)    cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;/* 输出3 53 74 85 25 4*/\n\n其它setmultiset:元素可以重复，且元素有序\nunordered_set ：元素无序且只能出现一次\nunordered_multiset ： 元素无序可以出现多次\npair 二元组介绍pair只含有两个元素，可以看作是只有两个元素的结构体。\n应用：\n\n头文件\n//头文件#include&lt;utility&gt;\n\n初始化\n//1.初始化定义pair&lt;string, int&gt; p(&quot;zenith32&quot;,1);//带初始值的pair&lt;string, int&gt; p;//不带初始值的\n\n赋值\n//2.赋值p = &#123;&quot;zenith32&quot;, 18&#125;;p = make_pair(&quot;zenith32&quot;, 18);p = pair&lt;string, int&gt;(&quot;zenith32&quot;, 18);\n\n代替二元结构体\n\n作为map键值对进行插入（代码如下）\nmap&lt;string, int&gt; mp;mp.insert(pair&lt;string, int&gt;(&quot;zenith32&quot;,1));// mp.insert(make_pair(&quot;zenith32&quot;, 1));// mp.insert(&#123;&quot;zenith32&quot;, 1&#125;);\n\n访问//定义结构体数组pair&lt;int,int&gt; p[20];for(int i = 0; i &lt; 20; i++) &#123;\t//和结构体类似，first代表第一个元素，second代表第二个元素\tcout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;&#125;\n\nstring 字符串介绍string是一个字符串类，和char型字符串类似。\n可以把string理解为一个字符串类型，像int一样可以定义\n初始化及定义\n头文件\n//头文件#include&lt;string&gt;\n\n初始化\n//1.string str1; //生成空字符串//2.string str2(&quot;123456789&quot;); //生成&quot;123456789&quot;的复制品 //3.string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3//4.string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5//5.string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串//6.string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后\n\n访问单个字符：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s = &quot;zenith!!!&quot;;\tfor(int i = 0; i &lt; s.size(); i++)\t\tcout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;\treturn 0;&#125;\n\nstring数组使用：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s[10];\tfor(int i = 1; i &lt; 10; i++) &#123;\t\ts[i] = &quot;loading...  &quot; ;\t\tcout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\\n&quot;;\t&#125; \treturn 0;&#125;//结果://loading...  1//loading...  2//loading...  3//loading...  4//loading...  5//loading...  6//loading...  7//loading...  8//loading...  9\n\nstring 特性\n支持比较运算符\nstring字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），支持string与C-string的比较（如 str &lt; “hello”）。\n在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按 字典顺序 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。\n同时，string (&quot;aaaa&quot;) &lt;string(&quot;aaaaa&quot;)。\n\n支持+运算符，代表拼接字符串string字符串可以拼接，通过”+”运算符进行拼接。\nstring s1 = &quot;123&quot;;string s2 = &quot;456&quot;;string s = s1 + s2;cout &lt;&lt; s;   //123456\n\n读入详解读入字符串，遇空格，回车结束\nstring s;cin &gt;&gt; s;\n\n读入一行字符串（包括空格），遇回车结束\nstring s;getline(cin, s);\n\n注意: getline(cin, s)会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：getchar() 或 cin.get()\n错误读取：\nint n;string s;cin &gt;&gt; n;getline(cin, s); //此时读取相当于读取了前一个回车字符\n\n正确读取：\nint n;string s;cin &gt;&gt; n;getchar(); //cin.get() 读取前一个回车字符getline(cin, s);//可正确读入下一行的输入\n\n\ncin与cin.getline()混用\ncin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致getline()读取回车，结束。需要在cin后面加cin.ignore()；主动删除输入流中的换行符。（不常用）\n\ncin和cout解锁\n代码（写在main函数开头）：\nios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n\n\n为什么要进行cin和cout的解锁，原因是：\n在一些题目中，读入的数据量很大，往往超过了1e5（105）的数据量,而cin和cout的读入输出的速度很慢（是因为cin和cout为了兼容C语言的读入输出在性能上做了妥协），远不如scanf和printf的速度，具体原因可以搜索相关的博客进行了解。\n所以对cin和cout进行解锁使cin和cout的速度几乎接近scanf和printf，避免输入输出超时。\n\n注意：cin cout解锁使用时，不能与 scanf,getchar, printf,cin.getline()混用，一定要注意，会出错。\n\nstring与C语言字符串（C-string）的区别\nstring是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\\0字符C-stringC语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\\0结尾\n\n一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法c_str()实现string向char数组的转换。\nstring s = &quot;zenith&quot;;const char *s2 = s.c_str();\n\n函数方法\n获取字符串长度\n\n\n\n代码\n含义\n\n\n\ns.size()和s.length()\n返回string对象的字符个数，他们执行效果相同。\n\n\ns.max_size()\n返回string对象最多包含的字符数，超出会抛出length_error异常\n\n\ns.capacity()\n重新分配内存之前，string对象能包含的最大字符数\n\n\n\n插入\n\n\n\n代码\n含义\n\n\n\ns.push_back(element)\n在末尾插入\n\n\ns.insert(pos,element)\n在pos位置插入element\n\n\ns.append(str)\n在s字符串结尾添加str字符串\n\n\n例\n\n\n\n代码\n含义\n\n\n\ns.push_back(‘a’)\n末尾插入一个字符a\n\n\ns.insert(s.begin(),’1’)\n在第一个位置插入1字符\n\n\ns.append(“abc”)\n在s字符串末尾添加字符串“abc”\n\n\n\n删除\n\n\n\n代码\n含义\n\n\n\nerase(iterator p)\n删除字符串中p所指的字符\n\n\nerase(iterator first, iterator last)\n删除字符串中迭代器区间[first,last)上所有字符\n\n\nerase(pos, len)\n删除字符串中从索引位置pos开始的len个字符\n\n\nclear()\n删除字符串中所有字符\n\n\n\n字符替换\n\n\n\n代码\n含义\n\n\n\ns.replace(pos,n,str)\n把当前字符串从索引pos开始的n个字符替换为str\n\n\ns.replace(pos,n,n1,c)\n把当前字符串从索引pos开始的n个字符替换为n1个字符c\n\n\ns.replace(it1,it2,str)\n把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器（iterator）\n\n\n\n大小写转换\n法一：\n\n\n\n代码\n含义\n\n\n\ntolower(s[i])\n转换为小写\n\n\ntoupper(s[i])\n转换为大写\n\n\n法二：\n通过stl的transform算法配合tolower 和toupper 实现。有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。\nstring s;transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写\n\n分割\n\n\n\n代码\n含义\n\n\n\ns.substr(pos,n)\n截取从pos索引开始的n个字符\n\n\n\n查找\n\n\n\n代码\n含义\n\n\n\ns.find (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串\n\n\ns.find (c, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.rfind (str, pos)\n在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串\n\n\ns.rfind (c,pos)\n在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_of (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_not_of (str,pos)\n在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_of(str, pos)\n在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_not_of ( str, pos)\n在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串\n\n\n#include&lt;string&gt;#include&lt;iostream&gt;int main() &#123;    string s(&quot;dog bird chicken bird cat&quot;);//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标    cout &lt;&lt; s.find(&#x27;i&#x27;,6) &lt;&lt; endl;// 结果是：11    // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 4. 从字符串的末尾开始查找字符    cout &lt;&lt; s.rfind(&#x27;i&#x27;) &lt;&lt; endl;// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符    // 5. 在该字符串中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b    // 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9    // 7. 在该字符串最后中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21&#125;\n\n排序\nsort(s.begin(),s.end());  //按ASCII码排序\n\nbitset介绍bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间\n\n头文件\n//头文件#include&lt;bitset&gt;\n\n初始化定义\n初始化方法\nbitset&lt;n&gt; a;//a有n位，每位都为0bitset&lt;n&gt; a(b);//a是unsigned long型b的一个二进制副本bitset&lt;n&gt; a(s);//a是string对象s中含有的位串的副本bitset&lt;n&gt; a(s,pos,n);//a是s中从位置pos开始的n个位的副本\n\n\n注意：n必须为常量表达式\n\n演示代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tbitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为0bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用0补充string s = &quot;100101&quot;;bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用0补充char s2[] = &quot;10101&quot;;bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用0补充cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101return 0;&#125;\n特性bitset可以进行位操作\nbitset&lt;4&gt; foo (string(&quot;1001&quot;));bitset&lt;4&gt; bar (string(&quot;0011&quot;));cout &lt;&lt; (foo^=bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;// 0001 (按位与后赋值给foo)cout &lt;&lt; (foo|=bar) &lt;&lt; endl;// 1011 (按位或后赋值给foo)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; endl;// 0100 (左移2位，低位补0，有自身赋值)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; endl;// 0100 (右移1位，高位补0，有自身赋值)cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; endl;// 0110 (左移，不赋值)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; endl;// 0001 (右移，不赋值)cout &lt;&lt; (foo==bar) &lt;&lt; endl;// false (1001==0011为false)cout &lt;&lt; (foo!=bar) &lt;&lt; endl;// true  (1001!=0011为true)cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;// 0001 (按位与，不赋值)cout &lt;&lt; (foo|bar) &lt;&lt; endl;// 1011 (按位或，不赋值)cout &lt;&lt; (foo^bar) &lt;&lt; endl;// 1010 (按位异或，不赋值)\n\n访问\n//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：bitset&lt;4&gt; foo (&quot;1011&quot;); cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1cout &lt;&lt; foo[1] &lt;&lt; endl;　　//0cout &lt;&lt; foo[2] &lt;&lt; endl;　　//1\n\n方法函数\n\n\n代码\n含义\n\n\n\nb.any()\nb中是否存在置为1的二进制位，有 返回true\n\n\nb.none()\nb中是否没有1，没有 返回true\n\n\nb.count()\nb中为1的个数\n\n\nb.size()\nb中二进制位的个数\n\n\nb.test(pos)\n测试b在pos位置是否为1，是 返回true\n\n\nb[pos]\n返回b在pos处的二进制位\n\n\nb.set()\n把b中所有位都置为1\n\n\nb.set(pos)\n把b中pos位置置为1\n\n\nb.reset()\n把b中所有位都置为0\n\n\nb.reset(pos)\n把b中pos位置置为0\n\n\nb.flip()\n把b中所有二进制位取反\n\n\nb.flip(pos)\n把b中pos位置取反\n\n\nb.to_ulong()\n用b中同样的二进制位返回一个unsigned long值\n\n\narray 数组介绍\n头文件\n#include&lt;array&gt;\n\narray是C++11新增的容器，效率与普通数据相差无几，比vector效率要高，自身添加了一些成员函数。\n和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，只允许访问或者替换存储的元素。\n注意：\narray的使用要在std命名空间里\n使用声明和初始化\n基础数据类型\n声明一个大小为100的int型数组，元素的值不确定\narray&lt;int, 100&gt; a;\n\n声明一个大小为100的int型数组，初始值均为0(初始值与默认元素类型等效)\narray&lt;int, 100&gt; a&#123;&#125;;\n声明一个大小为100的int型数组，初始化部分值，其余全部为0\narray&lt;int, 100&gt; a&#123;1, 2, 3&#125;;\n或者可以用等号\narray&lt;int, 100&gt; a = &#123;1, 2, 3&#125;;\n\n高级数据类型不同于数组的是对元素类型不做要求，可以套结构体\narray&lt;string, 2&gt; s = &#123;&quot;ha&quot;, string(&quot;haha&quot;)&#125;;array&lt;node, 2&gt; a;\n\n取存元素值\n修改元素\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;a[0] = 4;\n\n访问元素\n下标访问\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++)     cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];\n\n利用auto访问\nfor(auto i : a)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\n迭代器访问\nauto it = a.begin();for(; it != a.end(); it++)     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\nat()函数访问\n//下标为1的元素 加上 下标为2的元素，答案为5array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nget方法访问\n//将a数组下标为1位置处的值改为xget&lt;1&gt;(a) = x;//注意 获取的下标只能写数字，不能填变量\n\n成员函数\n\n\n成员函数\n功能\n\n\n\nbegin()\n返回容器中第一个元素的访问迭代器（地址）\n\n\nend()\n返回容器最后一个元素后一个位置的访问迭代器（地址）\n\n\nrbegin()\n返回最后一个元素的访问迭代器（地址）\n\n\nrend()\n返回第一个元素前一个位置的访问迭代器（地址）\n\n\nsize()\n返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数N\n\n\nmax_size()\n返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N\n\n\nempty()\n判断容器是否为空\n\n\nat(n)\n返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常\n\n\nfront()\n返回容器中第一个元素的直接引用，函数不适用于空的 array 容器\n\n\nback()\n返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。\n\n\ndata()\n返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能\n\n\nfill(x)\n将 x 这个值赋值给容器中的每个元素,相当于初始化\n\n\narray1.swap(array2)\n交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型\n\n\n部分用法示例data()指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。\nat()下标为1的元素加上下标为2的元素，答案为5\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nfill()array的fill()函数，将a数组全部元素值变为x\na.fill(x);\n\n另外还有其它的fill()函数:将a数组[begin,end)全部值变为x\nfill(a.begin(), a.end(), x);\n\nget方法获取元素值将a数组下标为1位置处的值改为x\n注意 获取的下标只能写数字，不能填变量\nget&lt;1&gt;(a) = x;\n\n排序sort(a.begin(), a.end());\n\ntuple 元组介绍tuple模板是pair的泛化，可以封装不同类型任意数量的对象。\n可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。\ntuple可以等价为结构体使用\n\n头文件\n#include&lt;tuple&gt;\n\n基础用法声明及初始化\n声明一个空的tuple三元组\ntuple&lt;int, int, string&gt; t1;\n\n赋值\nt1 = make_tuple(1, 1, &quot;hahaha&quot;);\n\n创建的同时初始化\ntuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);\n\n可以使用pair对象构造tuple对象，但tuple对象必须是两个元素\nauto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象\n\n元素操作\n获取tuple对象t的第一个元素\nint first = get&lt;0&gt;(t);\n修改tuple对象t的第一个元素\nget&lt;0&gt;(t) = 1;\n\n函数操作\n获取元素个数\ntuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3\n\n获取对应元素的值\n//通过`get&lt;n&gt;(obj)`方法获取,`n`必须为数字不能是变量tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 1cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 2cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 3\n\n通过tie解包 获取元素值\n//tie可以让tuple变量中的三个值依次赋到tie中的三个变量中int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3\n\n\n后记stl 的总结就到这里先结束了，也算是按时提前完成此次任务了吧\n后续应该会补充一些其他常用的函数，例如 sort 等\n","categories":["学习"],"tags":["知识总结","算法"]},{"title":"马克思主义复习重点摘要","url":"/2024/12/08/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%E6%91%98%E8%A6%81/","content":"马克思主义复习重点摘要事先声明，本文档由本人独立参照2023马原书本编写，内容为本人认为的复习重点，全是一个字一个字打的，不存在任何复制黏贴，仅用于期末考试复习参考使用。\n事实证明，马原复习一点用都没有，还不如不复习emmm，现在看来做这份文档归纳是我今年做过最错误的事，还不如多睡会emmm\n导论创始人：马克思、恩格斯\n关于：社会主义必然代替资本主义、最终实现共产主义\n包含：马克思主义哲学、马克思主义政治经济学、科学社会主义\n建立在：辩证唯物主义、历史唯物主义的基础上\n时间：19世纪40年代\n直接理论来源：德国古典哲学、英国古典政治经济学、英法空想社会主义\n科学社会主义的直接思想来源：英法空想社会主义\n自然科学前提：细胞学说、能量守恒和转化定律、生物进化论\n《德意志意识形态》：首次系统阐述了历史唯物主义的基本观点\n《共产党宣言》：1848.2 标志着马克思主义的公开问世\n《资本论》：系统阐述剩余价值学说\n毛泽东思想：马克思主义中国化时代化的第一次历史性飞跃\n中国特色社会主义理论体系：实现了马克思主义中国化时代化新的飞跃\n马克思主义基本特征：科学性、（人民性、实践性、发展性）革命性\n人民性：马克思主义的本质属性\n实践性：马克思主义区别于其他理论的根本特征\n马克思主义的当代价值：观察世界变化的认识工具、指引当代中国发展的行动指南、引领人类社会发展的科学真理\n第一章 世界的物质性及发展规律人类活动归结到两大类：认识世界、改造世界\n全部哲学的基本问题：思维和存在的关系问题\n物质的唯一特性：客观实在性\n物质的根本属性：运动\n主观世界是对客观世界的反映，并反作用于客观世界\n意识：在内容上是客观的，在形式上是主观的，是自然界长期发展的产物，也是社会历史发展的产物\n物质与意识的关系：物质决定意识、意识对物质有反作用、主观能动性与客观规律性的辩证统一\n意识的能动作用：一、目的性、计划性，二、创造性，三、指导实践改造客观世界，四、调控行为、生理\n主观能动性和客观规律性的辩证统一：尊重客观规律是正确发挥主观能动性的前提、只有充分发挥主观能动性才能正确认识利用客观规律\n社会性：人的意识所固有的本质属性\n世界的统一性：物质性\n辩证唯物主义最基本最核心的观点：物质统一性原理\n唯物辩证法的总观点：联系和发展\n唯物辩证法的总特征：联系和发展\n联系的特点：客观性、普遍性、多样性、条件性\n新事物是不可战胜的原因：一、新的因素等适应了变化 二、既否定，又保留，又添加 三、符合人民利益，得到拥护\n唯物辩证法的一般规律：对立统一、量变质变、否定之否定\n唯物辩证法的根本规律：对立统一\n对立统一是唯物辩证法的：实质、核心、内在动力\n认识世界和改变世界的根本方法：矛盾分析法\n矛盾具有：同一性、斗争性、普遍性、特殊性\n量变质变、否定之否定：事物变化发展的过程\n量变质变关系：量变是质变的必要准备、质变是量变的必然结果、质变量变相互渗透\n否定之否定：前进性与曲折性的统一\n唯物辩证法：是认识世界和改造世界的根本方法，是马克思主义世界观和方法论的核心\n唯物辩证法：本质是批判的和革命的\n唯物辩证法：是客观辩证法和主观辩证法的统一\n唯物辩证法：认识世界和改造世界的方法论\n第二章 实践与认识及其发展规律《关于费尔巴哈的提纲》：系统论述了实践的观点，揭示了科学实践观的基本内容\n实践性：马克思主义区别于其他理论的根本特征\n实践的观点：马克思主义的基本观点\n实践的特性：客观实在性、自觉能动性、社会历史性\n实践对认识的决定作用：一、实践是认识的来源 二、实践是认识发展的动力 三、实践是认识的目的 四、实践是检验真理的唯一标准\n认识的本质：主体在实践基础上对客体的能动反映\n从认识到实践：一、认识世界目的在改造世界 二、认识的真理性只有实践能检验\n实践到认识：第一次飞跃\n认识到实践：第二次飞跃\n人类认识和实践活动中的基本矛盾：主观和客观的矛盾\n认识世界和改造世界统一的基础是：实践\n真理具有：绝对性、相对性、客观性\n真理与谬误：一、真理与谬误相互对立 二、真理与谬误一定条件可以相互转化\n价值：主体性、客观性、多维性、社会历史性\n自由：对必然的认识、对客观世界的改造\n第三章 人类社会及其发展规律社会历史观的基本问题：社会存在和社会意识的关系问题\n社会意识：意识形态、非意识形态\n意识形态：用于统治的，反映利益的，非纯理性的\n人类社会的基本矛盾：生产力与生产关系、经济基础与上层建筑之间的矛盾\n生产力与生产关系：决定、反作用，构成矛盾运动\n经济基础与上层建筑：决定，反作用，构成矛盾运动\n历史发展的根本动力：社会基本矛盾\n推动事物发展的动力：矛盾\n经济社会发展的直接动力：阶级斗争\n历史的创作者：人民群众\n第四章 资本主义的本质及规律商品的使用价值和价值是相互排斥的，二者不可兼得\n商品的本质属性：价值\n价值：凝结在商品中的一般人类劳动就是商品的价值\n商品经济的基本矛盾：私人劳动和社会劳动的矛盾\n劳动的二重性：具体劳动和抽象劳动\n货币转化成资本：货币购买劳动力带来剩余价值\n资本：能够带来剩余价值的价值\n资本的有机构成：不变资本&#x2F;可变资本\n资本主义生产的直接目的和绝对性动机：获得尽可能多的剩余价值\n资本主义生产过程的两重性：生产物质资料、生产剩余价值（价值增殖过程）\n价值增殖过程：剩余价值的生产过程\n绝对剩余价值：必要劳动时间不变，延迟工作日或提高强度\n相对剩余价值：缩短必要劳动时间，延迟剩余劳动时间\n资本主义社会生产剩余价值的基本方法：绝对剩余价值生产、相对剩余价值生产\n资本主义生产的根本目的：追求剩余价值\n资本积累：剩余价值的资本化\n社会主义由空想到科学：唯物史观、剩余价值学说\n资本主义的基本矛盾：生产社会化与生产资料资本主义私人占有之间的矛盾\n资本主义国家：资产阶级进行阶级统治的工具\n第五章 资本主义的发展及其趋势国家垄断资本主义：国家政权和私人垄断资本融合在一起的垄断资本主义\n垄断统治形成后，垄断和竞争的关系：垄断和竞争并存并使竞争更加剧烈\n垄断资本向世界范围扩展的基本形式：借贷资本输出、生产资本输出、商品资本输出\n帝国主义的基本特征：一、垄断组织在经济生活起决定作用 二、在金融资本基础上形成金融寡头的统治 三、资本输出有了特别重要的意义 四、瓜分世界的资本家 国际垄断同盟 已经形成 五、最大资本主义国家已把世界上的领土瓜分完毕\n各国垄断组织从经济上瓜分世界产生了：国际垄断同盟\n第六章 社会主义的发展及其规律社会主义由空想到科学：唯物史观、剩余价值学说\n社会主义由理想到现实：十月革命\n党对怎么建设社会主义有了自己的新认识：《论十大关系》、《关于正确处理人民内部矛盾的问题》\n第七章 共产主义崇高理想及其最终实现共产主义一词的三个含义：共产主义思想体系、共产主义社会、共产主义运动\n杂 错题知识点整理马克思一生最伟大的两个发现是：唯物史观、剩余价值学说\n标志着现代无产阶级作为独立的政治力量登上历史舞台的是：法国里昂、宪章运动、纺织工人\n商品经济的基本矛盾：私人劳动和社会劳动的矛盾\n矛盾的特殊性要求：具体问题具体分析\n对立统一揭示了事物发展的：源泉与动力\n否定之否定揭示了事物发展的：方向与道路\n全部马克思主义学说的理论基础是：马克思主义哲学\n马克思主义科学体系中处于核心地位的是：科学社会主义\n白马非马这种错误在于：割裂了矛盾的普遍性和特殊性关系（遇到矛盾相关问题可以忽略矛盾二字）\n商品的本质属性：价值\n价值、价格、供求三者的关系：一、价格受供求关系影响，围绕价值上下波动 二、价格由价值决定，反映价值并反映供求关系 三、价格由价值决定，受供求关系影响并制约供求关系\n资本：能够带来剩余价值的价值\n实践与认识：实践决定认识，认识作用于实践，并非相互作用\n无产阶级科学的世界观和方法论是：辩证唯物主义、历史唯物主义\n否定思维与存在的同一性：不可知论\n马克思主义科学体系中处于核心地位的是：科学社会主义\n19世纪初英法空想社会主义的代表人物：圣西门、傅里叶、欧文\n人的本质：在其现实性上是一切社会关系的总和\n生产关系中起决定性作用的是：生产资料的所有制形式\n资本家普遍获得相对剩余价值：各个资本家追求超额剩余价值的结果\n剩余价值创造的唯一源泉：雇佣工人的剩余劳动\n在共产主义社会，劳动不再是单纯的谋生手段，而成为：生活的第一需要\n唯物辩证法的总观点：联系和发展\n对立统一是唯物辩证法的：实质、核心、内在动力\n马克思在：《《政治经济学批判》序言》提出了“两个绝不会”\n马克思主义认识论认为，主体和客体关系内涵包括：实践、认识、审美、价值\n社会主义建设的几种重要模式：苏联、南斯拉夫、中国\n货币转化为资本的决定性条件：劳动力成为商品\n经济全球化的实质决定了他的发展必然是：有利于发达资本主义国家\n垄断资本主义为向社会主义的过渡准备了物质条件表现在：生产全面社会化、管理日益社会化、资本日益社会化\n空想社会主义经历了哪些阶段：16-17早期空想、18空想平均、19批判空想\n实践与认识的关系：认识具有预见性、认识是实践的先导、实践高于认识、实践和认识具有本质的区别\n宿命论：一切都是安排好的，英雄只是执行者\n机械论：任何人在历史面前都是无能为力的\n历史循环论：历史周而复始，人只能随之循环\n历史唯物主义：包括英雄在内的人民群众创造的历史作用是受历史条件制约的\n雇佣工人的劳动时间分为：再生产劳动力价值的时间、生产剩余价值的时间\n资本主义再生产的实质是：物质资料生产与资本主义生产关系再生产的统一\n资本主义的生产过程是：劳动过程和价值增殖过程的统一\n资本主义经济危机呈现周期性的原因是：资本主义基本矛盾运动的特点\n国家垄断资本主义的产生从根本上来说是：生产社会化和资本主义私人占有之间的矛盾发展的结果\n认识的辩证过程是：相对真理到绝对真理、实践到认识到实践、感性到理性到感性\n经济基础与上层建筑：上层建筑不能先于经济基础产生、经济基础决定上层建筑、上层建筑反作用于经济基础、经济基础与上层建筑构成矛盾运动\n唯物辩证法认为事物发展的规律是：事物内在的本质的稳定的联系\n马克思恩格斯进一步发展和完善了英国古典政治经济学的：劳动价值论\n马克思主义的劳动价值论：是对古典政治经济学劳动价值论的批判继承和发展 是剩余价值理论的基础 为揭示资本主义生产方式的本质奠定了理论基础 是随着是随着时代和实践的发展而不断发展的 研究的是价值如何形成\n雇佣工人的劳动时间分为：再生产劳动力价值的时间、生产剩余价值的时间\n”谋事在人成事在天“是：历史唯物论的观点\n雇佣工人的劳动时间分为：再生产劳动力价值的时间、生产剩余价值的时间\n资本主义经济危机呈现周期性的原因是：资本主义基本矛盾运动的特点\n绝对真理和相对真理的关系是：客观真理的两种不同属性\n资本主义经济危机爆发的根本原因：资本主义基本矛盾\n资本主义基本矛盾：生产社会化与生产资料私人占有之间的矛盾\n马克思主义三个组成部分思想的第一次综合表述是在：共产党宣言\n质变量变规律揭示的是事物发展的：形式和状态\n荀子说，“天行有常，不为尧存，不为桀亡”是一种：朴素唯物主义\n马克思主义活的灵魂是：具体问题具体分析\n列宁得出社会主义可能会在一国或多国首先取得胜利的结论，依据是：帝国主义时代资本主义政治经济发展不平衡的规律\n有用就是真理违背了：真理的客观性\n资本主义积累的源泉是：剩余价值\n同一颗大树，在每个人眼中不一样，由于：人的感觉受理性指导 已有的认识影响感觉 人的认识具有能动性\n矛盾分析法包含广泛而深刻的内容，具体体现是：分析矛盾特殊性的方法 两点论和重点论结合的方法 抓关键的方法 批判继承的方法 把握对立统一的方法\n马克思指出“我的观点是：社会经济形态的发展是一种自然历史过程”，这一观点的基本含义是：社会同自然界一样，本质是客观的物质联系 社会同自然界一样，有着不以人的意志为转移的客观规律 人们有可能以自然科学那样精确的眼光来研究人类社会\n资本原始积累的主要途径有：用暴力手段进行殖民掠夺 用暴力手段剥夺农民土地\n马克思在：《《政治经济学批判》序言》提出了“两个绝不会”\n标志着马克思主义基本形成的著作：《关于费尔巴哈的提纲》 《德意志意识形态》\n 恩格斯指出“单凭观察所得的经验，是绝不能充分证明必然性的”，其中包含的基本原理有：感性认识具有局限性 感性认识需要上升到理性认识\n","categories":["学习"],"tags":["考点预测","马克思主义"]},{"title":"计算机组成原理复习重点摘要","url":"/2024/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%E6%91%98%E8%A6%81/","content":"计算机组成原理复习重点摘要又到了做复习摘要的时候了哈哈哈\n第一章 计算机系统概论计算机系统简介多级层次结构的计算机系统\n计算机的基本组成冯诺依曼计算机的特点\n计算机硬件的主要技术指标三大指标\n第二章 计算机的发展及应用第三章 系统总线总线的基本概念三种总线结构及特点\n总线的分类总线的分类\n总线的特性总线标准\n总线的结构总线控制三种查询方式的特点\n四种通讯方式\n例3.1-4 传输的各种计算\n第四章 存储器概述存储器分类\n存储器的层次结构\n主存储器线选法\n三种刷新方式计算\n字位拓展 例4.1-3\n海明码 例4.4-5\n低位交叉编址 例4.6\n高速缓冲存储器cache命中率 平均访问时间等计算 例4.7\n三种映射方式 例4.8-11 （我也没看懂组相联，会做就行）\n四组相联映像\n辅助存储器磁表面存储的计算 例4.12-14\n循环冗余校验码CRC 例4.15\n输入输出系统概述五种传输方式\nI&#x2F;O设备其他I&#x2F;O设备程序查询方式程序中断方式中断服务程序流程\nDMA方式DMA工作过程\n计算机运算方法无符号数和有符号数原码 反码 补码 移码\n定点数和浮点数的表示浮点数在数轴上的表示范围 例6.5\n浮点数的规格化\n定点运算算数移位 例6.7\n逻辑移位\n判断溢出\n各种计算 例6.17-28\n定点原码一位乘\n定点数除法\n浮点数四则运算浮点数加减运算 例6.30\n算术逻辑单元指令系统机器指令操作数类型和操作类型寻址方式十种寻址方式的理解\n指令格式举例指令格式设计 例7.4 例7.5-6\nRISCRISC与CISC的对比\nCPU的结构和功能CPU的结构指令周期指令周期 机器周期 时钟周期\n指令流水影响流水线性能的因素及解决办法\n流水线性能流水线性能的三种计算 例8.1\n流水线中的多发技术\n中断系统中断屏蔽技术 中断屏蔽字 CPU执行流程\n控制单元的功能未操作命令的分析控制单元的功能控制单元的设计组合逻辑设计微程序设计微程序控制单元框图及工作原理\n微指令格式\n微程序设计举例\n","categories":["学习"],"tags":["考点预测","计算机组成原理"]},{"title":"计算机组成原理大作业开题答辩","url":"/2024/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%BC%80%E9%A2%98%E7%AD%94%E8%BE%A9/","content":"尊敬的各位评委老师、同学们：\n大家好！非常荣幸能够进行本次开题答辩。我们的研究题目是《基于鲲鹏数学库的高性能数学计算加速方法研究与实践》。接下来，我将为大家依次从以下四个方面展开，1、鲲鹏数学库 2、KML_FFT库函数 3、实验方案 4、总结\n\n第一部分：鲲鹏数学库首先，我们来介绍鲲鹏数学库（KML）。\n鲲鹏数学库是华为为鲲鹏平台优化的高性能数学函数库，是鲲鹏 BoostKit 加速库的重要组成部分。KML 专为鲲鹏 920 处理器设计，基于其独特的指令集架构（KISA），通过高效并行化、多核优化和特定算法的深度加速，大幅提升了科学计算、数据分析和信号处理等领域的计算性能。\nKML 的主要功能包括对标量、矢量和矩阵的数学计算支持，涵盖基本四则运算、三角函数、对数函数、指数函数以及线性代数运算等。\nKML 的创新点主要体现在以下几个方面：\n\n硬件结合优化：充分利用鲲鹏 920 的向量计算能力和硬件性能，显著提升计算效率。\n多核并行：针对 64 核架构，实现多线程优化与负载均衡，有效降低复杂运算的时间成本。\n内存管理优化：采用指令流水和数据对齐策略，减少内存延迟，进一步提升吞吐率。\n\nKML 的应用场景非常广泛，包括：\n\n大数据分析，如机器学习算法；\n高性能计算（HPC），如科学仿真、气象预报、基因研究；\n人工智能（AI），如语音识别、图像识别等领域。\n\n\n第二部分：KML_FFT 库函数接下来是 KML_FFT 库函数，这是我们研究的重点。\nKML_FFT 是鲲鹏数学库的一个子模块，主要用于快速傅里叶变换（FFT）的加速。快速傅里叶变换是一种广泛应用于工程、科学和数学领域的算法，能够将离散傅里叶变换（DFT）的计算复杂度从 $O(n^2)$ 降低到 $O(n \\log n)$。基于其重要性，FFT 被 IEEE 科学与工程计算期刊评为 20 世纪十大算法之一。\nKML_FFT 在鲲鹏架构上通过以下方式实现深度优化：\n\n向量化操作：充分利用硬件的 SIMD 指令，提高计算密度；\n算法改进：对传统 FFT 算法进行优化，减少计算冗余；\n内存优化：采用流水线式的数据处理方式，提升整体效率。\n\n在实际使用中，KML_FFT 提供了易用的接口，用户只需引入 kml_fft.h 头文件，即可在 C 语言中调用其功能。我们后续的实验将重点对比 KML_FFT 和传统 FFT 算法的性能表现。\n\n第三部分：实验方案实验方案分为三个部分：\n\n安装与配置：\n\n从官网下载安装鲲鹏数学库，并通过 WinSCP 将其上传到云服务器；\n在开发环境中配置头文件 kml_fft.h，完成基本函数调用的测试。\n\n\n功能实现：\n\n使用传统 Cooley-Tukey FFT 算法实现快速傅里叶变换；\n使用 KML_FFT 库函数实现同样的计算任务。\n\n\n性能对比：\n\n比较传统 FFT 和 KML_FFT 的运行时间，验证 KML_FFT 的优化效果；\n通过测试不同规模数据的性能差异，分析其在大数据处理中的优势。\n\n\n\n此外，我们还在实验中穿插设计了两个扩展实验：\n\n牛顿迭代法求解非线性方程的根；\n矩阵特征值和特征向量的计算。\n\n通过这些实验，我们希望深入了解 KML 在解决复杂数学问题中的潜能。\n\n第四部分：总结最后是总结部分。\n通过我们的研究工作，我们希望达成以下目标：\n\n加深对鲲鹏 BoostKit 基础加速库的理解；\n掌握使用 KML 库解决复杂数学问题的方法；\n实验验证 KML_FFT 库函数的优化性能。\n\n本研究不仅验证了 KML 在高性能计算中的显著优势，还突出体现了国产数学库在硬件适配上的独特创新。未来，我们计划进一步扩展实验场景，例如探索 KML 在多线程优化和分布式计算中的应用，研究其在更大规模数据处理中的潜力。\n我们相信，鲲鹏数学库的出现标志着国产技术在高性能计算领域迈出了重要一步。而我们的研究将为鲲鹏生态的完善贡献微薄之力。\n\n以上就是我们的开题报告。感谢各位老师的聆听，希望能得到您的宝贵建议和指导！谢谢大家！\n","categories":["学习"],"tags":["计算机组成原理","答辩"]},{"title":"基于鲲鹏数学库的高性能数学计算加速方法研究与实践","url":"/2024/12/21/%E5%9F%BA%E4%BA%8E%E9%B2%B2%E9%B9%8F%E6%95%B0%E5%AD%A6%E5%BA%93%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/","content":"基于鲲鹏数学库的高性能数学计算加速方法研究与实践1 实验目的1. 验证鲲鹏数学库的性能优化效果\n核心目标：通过一系列数学计算实验，系统验证基于鲲鹏架构的 Kunpeng Math Library (KML) 相较传统实现方式的性能提升程度。\n细化目标\n验证 KML 在不同数学计算任务中的加速效果，包括基础数学运算（如三角函数计算）、矩阵计算（如矩阵乘法）和高级线性代数问题（如特征值分解）。\n比较 KML 在单线程和多线程模式下的性能表现，探索其并行能力。\n\n\n\n2. 探索鲲鹏架构的硬件适配性\n硬件架构支持验证\n检验 KML 对鲲鹏处理器的硬件特性（如 SIMD 指令集、多核并行）和内存架构（如 L1&#x2F;L2 缓存优化）的适配程度。\n探索基于 ARM 架构优化的数学库在高性能计算（HPC）场景中的实际表现。\n\n\n平台优势探索\n评估 KML 在典型计算任务（如矩阵运算、快速傅里叶变换）中对其他平台（如 x86 架构）的相对性能优势，为基于鲲鹏的数学计算方案提供参考。\n\n\n\n3. 优化实际科学计算任务\n面向工程计算和科学研究\n通过 KML 的高性能计算加速，解决实际工程和科研中的计算瓶颈问题。例如，优化数据分析、机器学习训练中的矩阵运算，加速信号处理中的傅里叶变换等。\n\n\n扩展应用场景\n在本实验中探索 KML 在不同任务中的适配性，为其在更多计算场景（如气象模拟、分子动力学模拟等）提供基础。\n\n\n\n4. 提升鲲鹏生态的实践经验\n用户指导与案例积累\n总结使用 KML 的安装、配置、调试方法，以及在各类任务中的具体实现步骤，为开发者提供实践指南。\n为鲲鹏生态的推广提供优化实践案例，进一步推动基于 ARM 架构的高性能计算技术在行业中的普及。\n\n\n性能优化经验总结\n通过对比实验，提炼出优化数学计算性能的经验，如向量化处理、多线程并行优化、内存管理优化等，为后续开发高效的数学计算程序提供理论和实践依据。\n\n\n\n5. 评估性能与准确性的平衡\n性能测试\n在数学运算中，尤其是高级运算（如特征值分解、快速傅里叶变换），性能与准确性可能存在一定平衡点。实验目标之一是分析 KML 在保持高精度的同时实现性能提升的能力。\n\n\n结果一致性验证\n确保使用 KML 计算的结果在科学研究或工程应用中具有可接受的准确性，并验证其与传统实现方式的一致性。\n\n\n\n6. 推动数学计算领域的技术进步\n实践新算法\n利用鲲鹏架构和 KML 优化数学运算的能力，探索传统算法在新型硬件架构下的优化潜力。\n\n\n高性能计算的技术转化\n将 KML 的优势推广到实际的工业和学术计算任务中，为数学计算领域的技术进步提供支持。\n\n\n\n2 实验设备\n华为鲲鹏云服务器；\n\n具备网络连接的个人电脑。\n\n\n3 实验原理1. 数学库优化的核心思想鲲鹏数学库（KML）的设计理念是通过充分利用硬件特性提升数学运算的性能。以下是其核心优化思想：\n\n指令级优化\nKML 借助 ARMv8 架构的 SIMD（Single Instruction Multiple Data）指令集，能够在单次指令操作中对多个数据元素进行并行处理，从而显著提升运算速度。\n使用如 Neon 指令等优化数学函数（如三角函数、对数函数等）的批量处理能力。\n\n\n多线程并行\n通过 pthread 和 OpenMP 等多线程技术，KML 可高效分解计算任务，充分利用多核处理器的计算资源。\n\n\n内存访问优化\n避免频繁的内存读取与写入，通过对内存对齐、缓存友好型算法等优化策略，减少数据传输瓶颈。\n\n\n\n2. 硬件架构与性能优化的关系鲲鹏服务器基于 ARM 架构，具备以下硬件特性，KML 在设计时针对这些特性进行了针对性优化：\n\n高密度核心： 鲲鹏处理器具有高核数的特点，非常适合高并发计算任务，KML 可在矩阵运算、FFT 中有效分摊任务到多个核心，降低单核压力。\n宽向量寄存器： ARM 的 SIMD 技术利用宽向量寄存器，使得多数据并行计算成为可能。例如，KML_SVML 的优化实现可一次性处理多个向量元素。\n内存子系统优化： 鲲鹏架构的 L1 和 L2 缓存对矩阵计算中常见的密集存储访问模式进行了专门优化。KML 的矩阵运算函数充分利用了这一特性，通过块状处理减少了内存访问延迟。\n\n3. 数学计算的多层次优化方法KML 的优化覆盖了从低级指令到高级数学库的多个层次：\n\n基础数学函数优化： 优化基本数学函数（如三角函数、指数函数）的实现，通过硬件寄存器和流水线指令集实现批量处理。\nBLAS 和 LAPACK 优化\nBLAS：优化矩阵-向量运算、矩阵-矩阵运算等基础线性代数运算，广泛用于科学计算中。\nLAPACK：在更高级别的线性代数操作（如特征值问题、奇异值分解）中，KML 将关键计算步骤分解为高效的 BLAS 调用，并结合硬件特性进行细粒度优化。\n\n\n快速傅里叶变换（FFT）： FFT 算法中涉及复杂的递归和循环结构，KML 通过流水线技术和分块计算优化了时间复杂度，同时减少了内存访问次数。\n\n4. 实验的对比设计与性能评估策略为了全面评估 KML 的性能，实验采用了“传统实现”和“优化实现”的对比方式：\n\n传统实现：直接使用标准数学库（如 math.h）或手动实现算法，模拟常规的计算方式。\n优化实现：基于 KML 提供的库函数完成相同计算任务。\n性能评估\n时间复杂度：记录不同方法的执行时间，量化性能提升。\n准确性：验证 KML 的计算结果是否与传统实现一致，确保在优化性能的同时保证结果的可靠性。\n资源利用率：观察 CPU、内存的使用情况，分析 KML 如何在硬件资源利用上占据优势。\n\n\n\n5. 典型优化场景\n矩阵运算： 矩阵计算（如矩阵-向量乘法、矩阵分解）是科学计算中的核心任务。KML 针对矩阵密集型计算进行了特殊优化，减少了循环嵌套带来的性能瓶颈。\n高维向量运算： 例如三角函数计算，普通实现逐元素计算效率低下，而 KML 利用向量化技术和批量计算方法，可显著加速处理大规模数据。\n特征值问题： 对称矩阵特征值与特征向量计算涉及复杂的迭代算法，KML 在 LAPACK 的基础上进一步优化了矩阵操作的并行性。\n\n6. KML 的接口设计与易用性\n动态库链接： 用户可通过简单的编译选项链接 KML 提供的动态库，从而快速完成性能优化。\n模块化功能： 不同的子模块（如 BLAS、VML、SPBLAS 等）满足了从基础运算到高级线性代数的多种需求，提供了良好的兼容性和可扩展性。\n\n4 实验任务操作指导4.1安装KML下面介绍如何安装KML\n首先使用远程登录工具，登录到鲲鹏 ECS 服务器上\n下载 WinSCP 客户端并安装。\n启动WinSCP，启动后界面如下：\n\n看不见是正常的，别担心\n\n填写说明：\n\n协议：选填 SFTP 或者 SCP 均可。\n\n主机名：云服务器的公网 IP。登录管理控制台即可查看对应云服务器的公网 IP。\n\n端口：默认 22。\n\n用户名：云服务器的用户名。\n\n使用“SSH密钥方式”登录云服务器时：\n\n如果是“CoreOS”的公共镜像，用户名为“core”。\n\n如果是“非CoreOS”的公共镜像，用户名为“root”。\n\n\n\n使用“密码方式”登录云服务器，公共镜像（包括CoreOS）的用户名为：root。\n\n密码：购买云服务器设置的密码或通过密钥方式转化后的密码。\n\n单击“登录”，进入 “WinSCP” 文件传输界面。\n\n登录成功之后，您可以选择左侧本地计算机的文件，拖拽到右侧的远程云服务器，完成文件上传到云服务器。\n\n\n具体操作可以参考：\n本地Windows主机使用WinSCP上传文件到Linux云服务器 https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0166284971.html\n 然后到https://www.hikunpeng.com/developer/boostkit/library/detail?subtab=%E6%95%B0%E5%AD%A6%E5%BA%93获取KML软件包（GCC版本）\n\n看不见是正常的，别担心\n\n\n看不见是正常的，别担心\n\n下载软件包后解压得到此文件：\n\n看不见是正常的，别担心\n\n再通过“本地Windows主机使用WinSCP上传文件到Linux云服务器https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0166284971.html”中所述的远程登录将该文件上传到云服务器\n接下来安装KML。\n步骤1 登录云服务器，进入刚刚上传文件所在的目录，输入\nrpm -ivh kml-xxxx.aarch64.rpm\n\n安装软件包，其中命令中涉及的xxxx代表版本号，下图示中的版本号是2.4.0-1\n \n看不见是正常的，别担心\n\n步骤 2 安装后验证\n执行source命令或重新登录终端让环境变量生效。\nsource /etc/profile\n\n\n看不见是正常的，别担心\n\n查看环境变量LD_LIBRARY_PATH是否包含KML的安装路径“&#x2F;usr&#x2F;local&#x2F;kml&#x2F;lib”。\nenv | grep LD_LIBRARY_PATH\n\n如果变量包含安装路径，说明安装成功。\n\n看不见是正常的，别担心\n\n安装成功后在安装路径（默认路径是“&#x2F;usr&#x2F;local&#x2F;kml”）下生成相应文件，其中，include文件夹包含子库的头文件，lib文件夹包含了数学库的动态库文件。\n\n看不见是正常的，别担心\n\n使用时，请在GCC编译选项中添加动态库所在路径，链接需要使用的动态库文件，添加编译选项后用ldd命令检查程序依赖库是否准确链接。\n若需要使用KML_BLAS请添加如下代码，此处对官方给出的代码进行适当修改以正常使用：\n单线程不加锁版本：-L /usr/local/kml/lib/kblas/nolocking -lkblas -I /usr/local/kml/include -pthread单线程加锁版本：-L /usr/local/kml/lib/kblas/locking -lkblas -I /usr/local/kml/include -pthreadpthread实现多线程版本：-L /usr/local/kml/lib/kblas/pthread -lkblas -I /usr/local/kml/include -pthreadOpenMP实现多线程版本：-L /usr/local/kml/lib/kblas/omp -lkblas -I /usr/local/kml/include -pthread\n若需要使用KML_VML请添加：\n单线程版本：-L /usr/local/kml/lib/kvml/single -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm多线程版本：-L /usr/local/kml/lib/kvml/multi -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm -fopenmp\n若需要使用KML_SPBLAS请添加：\n单线程版本：-L /usr/local/kml/lib/kspblas/single -lkspblas -I /usr/local/kml/include -pthread多线程版本：-L /usr/local/kml/lib/kspblas/multi -lkspblas -I /usr/local/kml/include -pthread\n若需要使用KML_FFT请添加：\n单精度版本：-L /usr/local/kml/lib -lkfftf -I /usr/local/kml/include -pthread双精度版本：-L /usr/local/kml/lib -lkfft -I /usr/local/kml/include -pthread\n若需要使用KML_MATH请添加：\n高性能版本：-L /usr/local/kml/lib -lkm -lm -I /usr/local/kml/include -pthread高精度版本：-L /usr/local/kml/lib -lkm_l9 -lm -I /usr/local/kml/include -pthread\n若需要使用KML_SVML请添加：\n-L /usr/local/kml/lib -lksvml -lm -I /usr/local/kml/include -pthread\n若需要使用KML_VSL请添加：\n-L /usr/local/kml/lib -lkvsl -I /usr/local/kml/include -pthread -lm\n若需要使用KML_LAPACK：\n先生成完整的LAPACK，然后添加：\nexport KML_LAPACK_ROOT=/usr/local/kml/libexport ADAPT_ROOT=/home/lapack_adaptexport KML_BLAS_ROOT=/usr/local/kml/lib/kblas/ompgcc test.c -o test -fopenmp -I $KML_LAPACK_ROOT/include/kml-0.3.0 -L /usr/local/kml/lib -lklapack -L $ADAPT_ROOT -l:liblapack_adapt.a -L $KML_BLAS_ROOT -lkblas -lgfortran -lm -lkservice -I /usr/local/kml/include\n若需要使用KML_IPL请添加：\n-L /usr/local/kml/lib -lkipl -lklapack_full -L /usr/local/kml/lib/kblas/pthread -lkblas -lm -I /usr/local/kml/include -pthread\n若需要使用KML_SCALAPACK ：先生成完整的SCALAPACK，然后添加：\n# 动态gcc test.c -o app  -fopenmp -I /usr/local/kml/lib/kblas/omp/include/kml-0.3.0 -L /usr/local/kml/lib -l:libkscalapack.a -L /home/scalapack_adapt -l:libscalapack_adapt.a -L /usr/local/kml/lib/kblas/omp -l kblas -L /usr/local/kml/lib  -l:libkservice.a -L /home/lapack_adapt -l:liblapack_adapt.a  -lm -I /usr/local/kml/include# 静态export KML_LAPACK_ROOT=/usr/local/kml/libexport ADAPT_ROOT=/home/scalapack_adaptexport KML_BLAS_ROOT=/usr/local/kml/lib/kblas/ompgcc test.c -o app  -fopenmp -I $KML_LAPACK_ROOT/include/kml-0.3.0 -L /usr/local/kml/lib -l:libkscalapack.a -L $ADAPT_ROOT -l:libscalapack_adapt.a -L $KML_BLAS_ROOT -L /home/lapack_adapt -l:liblapack_adapt.a -l:libkservice.a -lm -I /usr/local/kml/include\n\n下面给出两个基础的测试程序用于测试是否已经成功安装\n使用mkdir创建文件夹FFTTEST，使用cd FFTTEST进入，vim test.c创建测试文件\n#include &lt;stdio.h&gt;#include &quot;km.h&quot;int main()&#123;    double pi = acos(-1);     // typical usage     double a = pi/6, b = 1.0, c = -3*pi/4, d = pi/3;     // print result     printf(&quot;sin(pi/6) = %.15f\\n&quot;, sin(a));     printf(&quot;sin(1.0) = %.15f\\n&quot;, sin(b));     printf(&quot;sin(-3*pi/4) = %.15f\\n&quot;, sin(c));      /*      *  sin(pi/6) = 0.500000000000000      *  sin(1.0) = 0.841470984807897      *  sin(-3*pi/4) = -0.707106781186548      *  sin(pi/3) = 0.866025403784438      * */        return 0;&#125;\n\n利用\ngcc test.c -I /usr/local/kml/include -L /usr/local/kml/lib -lkm_l9 -lm\n\n编译，生成a.out\n\n看不见是正常的，别担心\n\n输入\n./a.out\n\n运行，结果如下\n\n看不见是正常的，别担心\n\n接下来尝试用牛顿迭代法求解非线性方程的根\n依次执行命令 mkdir NEWTON、cd NEWTON 创建并进入到 NEWTON 目录。\n创建 sum.c 文件，编写内容如下：\n//牛顿迭代法求解非线性方程的根#include &lt;stdio.h&gt;#include &quot;km.h&quot;double f(double x) &#123;    return x * x - 2; // 函数 f(x) = x^2 - 2&#125;double df(double x) &#123;    return 2 * x; // 函数的导数 f&#x27;(x) = 2x&#125;double newton(double initial_guess, double tolerance, int max_iterations) &#123;    double x = initial_guess;    int iteration = 0;        while (iteration &lt; max_iterations) &#123;        double fx = f(x);        if (fabs(fx) &lt; tolerance) &#123;            return x; // 找到根，返回当前值        &#125;double dfx = df(x);        if (dfx == 0) &#123;            printf(&quot;Error: Derivative is zero. No solution found.\\n&quot;);            return x; // 导数为零，无法继续        &#125;         x = x - fx / dfx; // 牛顿迭代公式        iteration++;    &#125;    printf(&quot;Max iterations reached. Last approximation: %f\\n&quot;, x);    return x; // 返回最后的近似值&#125;int main() &#123;    double initial_guess = 1.0; // 初始猜测    double tolerance = 1e-7; // 容忍度    int max_iterations = 100; // 最大迭代次数    double root;    printf(&quot;With KML:\\n&quot;);    root = newton(initial_guess, tolerance, max_iterations);    printf(&quot;Root found: %f\\n&quot;, root);    return 0;&#125;\n\n输入\ngcc NEWTON_KML.c -I /usr/local/kml/include -L /usr/local/kml/lib -lkm -lm -o NEWTON_KML./NEWTON_KML\n\n运行之，结构如下：\n\n看不见是正常的，别担心\n\n至此说明kml安装成功\n4.2 矩阵-向量乘加运算对比实验该代码主要进行了如下工作：初始化规模为1000*300的矩阵A，长度为300的向量x，长度为1000的向量y1和y2。分别用两种方法求矩阵-向量乘加运算，即y&#x3D;alpha*A*x+beta*y： \n（1）按照矩阵-向量的乘加规则实现算法求解 \n（2）调用KML_BLAS提供的函数cblas_dgemv求解 分别用计时器记录两种方法消耗的时间，对比KML_BLAS与手动实现矩阵乘加的性能。 \n编写代码如下：\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include &quot;kblas.h&quot;#define M 1000#define N 300int main()&#123;    double A[M*N]=&#123;0&#125;;double x[N]=&#123;0&#125;;double y1[M]=&#123;0&#125;;double y2[M]=&#123;0&#125;;for (int i=0;i&lt;M*N;i++)&#123;   A[i]=i;&#125;for (int i=0;i&lt;N;i++)&#123;   x[i]=i;&#125;for (int i=0;i&lt;M;i++)&#123;   y1[i]=1;   y2[i]=1;&#125; double alpha=1.2;double beta=2.5;struct timespec t1,t2;    //定义初始与结束时间printf(&quot;Without KML:\\n&quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。for(int i=0;i&lt;M;i++)&#123;   double tmp=0;    for(int j=0;j&lt;N;j++)    &#123;         tmp+=(A[i*N+j]*x[j]);    &#125;    y1[i]=alpha*tmp+beta*y1[i];&#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  printf(&quot;With KML:\\n&quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。cblas_dgemv(CblasColMajor,CblasNoTrans, M, N, alpha, A, M, x, 1, beta, y2, 1); clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  return 0;&#125;\n\n输入：\ngcc kblas.c -o kblas -L /usr/local/kml/lib/kblas/nolocking -lkblas -I /usr/local/kml/include\n\n运行之，得到运行结果如下：\n\n看不见是正常的，别担心\n\n可知KML_BLAS提供的函数cblas_dgemv对矩阵-向量乘加运算的优化效果十分显著\n4.3 调用KML_VML库计算100000个数的sin值和普通循环对比体现优化使用多线程版本\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;kvml.h&quot;#define LEN 100000int main()&#123;   double src[LEN]=&#123;0&#125;;   double dst1[LEN]=&#123;0&#125;;   double dst2[LEN]=&#123;0&#125;;   for(int i=0;i&lt;LEN;i++)       src[i]=i;    struct timespec t1,t2;    //定义初始与结束时间    printf(&quot;Without KML_VML &quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    for(int i=0;i&lt;LEN;i++)       dst1[i]=sin(src[i]);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  //得出目标代码段的执行时间。    printf(&quot;With KML_VML &quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    vdsin(LEN,src,dst2);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  //得出目标代码段的执行时间。return 0;&#125;\n\n输入\ngcc vsin.c -o vsin -L /usr/local/kml/lib/kvml/multi -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm -fopenmp./vsin\n\n运行结果如下所示：\n\n看不见是正常的，别担心\n\n可知KML_VML库对三角函数运算的优化效果十分显著\n4.4 体现LAPACK库性能的对比实验首先要生成完整的LAPACK用到的脚本\n接下来的程序需要脚本才能正确运行\n在&#x2F;home目录下创建sh.sh文件，接着编写如下代码：\nset -eEecho &quot;LAPACK_SRC_DIR         $&#123;LAPACK_SRC_DIR:-&lt;undefined&gt;&#125;&quot;echo &quot;LAPACK_TGZ             $&#123;LAPACK_TGZ:=/home/lapack-3.12.0.tar.gz&#125;&quot;echo &quot;LIBKLAPACK_A           $&#123;LIBKLAPACK_A:=/usr/local/kml/lib/libklapack.a&#125;&quot;echo &quot;LIBKSERVICE_A          $&#123;LIBKSERVICE_A:=$&#123;LIBKLAPACK_A/klapack/kservice&#125;&#125;&quot;echo &quot;ADAPT_DIR              $&#123;ADAPT_DIR:=./lapack_adapt&#125;&quot;echo &quot;CMAKE_BUILD_TYPE       $&#123;CMAKE_BUILD_TYPE:=Release&#125;&quot;echo &quot;LIBLAPACK_ADAPT_A      $&#123;LIBLAPACK_ADAPT_A:=liblapack_adapt.a&#125;&quot;echo &quot;LIBKLAPACK_FULL_SO     $&#123;LIBKLAPACK_FULL_SO:=libklapack_full.so&#125;&quot;echo &quot;CC                     $&#123;CC:=gcc&#125;&quot;echo &quot;FC                     $&#123;FC:=gfortran&#125;&quot;mkdir -p $&#123;ADAPT_DIR&#125;ZQcd $&#123;ADAPT_DIR&#125;# build netlib lapackif [ ! -r &quot;$&#123;LAPACK_SRC_DIR&#125;/CMakeLists.txt&quot; ]; then    mkdir -p netlib    ( cd netlib ; tar xzpf $&#123;LAPACK_TGZ&#125; )    LAPACK_SRC_DIR=$(cd netlib/l* ; pwd)fimkdir -p buildcmake_flags=(    -DCMAKE_BUILD_TYPE=$&#123;CMAKE_BUILD_TYPE&#125;    -DCMAKE_POSITION_INDEPENDENT_CODE=ON    -DCMAKE_C_COMPILER=$&#123;CC&#125;    -DCMAKE_Fortran_COMPILER=$&#123;FC&#125;    -DCMAKE_RULE_MESSAGES=off    -DBUILD_DEPRECATED=on    -DBUILD_TESTING=off)( cd build ; cmake $&#123;cmake_flags[*]&#125; $&#123;LAPACK_SRC_DIR&#125; )( cd build ; make -j )cp build/lib/liblapack.a $&#123;LIBLAPACK_ADAPT_A&#125;# get symbols defined both in klapack and netlib lapacknm -g $&#123;LIBLAPACK_ADAPT_A&#125; | grep &#x27;T &#x27; | grep -oP &#x27;\\K\\w+(?=_$)&#x27; | sort | uniq &gt; netlib.symnm -g $&#123;LIBKLAPACK_A&#125; | grep &#x27;T &#x27; | grep -oP &#x27;\\K\\w+(?=_$)&#x27; | sort | uniq &gt; klapack.symcomm -12 klapack.sym netlib.sym &gt; comm.sym# update symbols name of $&#123;LIBLAPACK_ADAPT_A&#125;while read sym; do    (        if ! nm $&#123;LIBLAPACK_ADAPT_A&#125; | grep -qe &quot; T $&#123;sym&#125;_\\$&quot;; then            continue        fi        ar x $&#123;LIBLAPACK_ADAPT_A&#125; $&#123;sym&#125;.f.o        mv $&#123;sym&#125;.f.o $&#123;sym&#125;_netlib.f.o        objcopy --redefine-sym $&#123;sym&#125;_=$&#123;sym&#125;_netlib_ $&#123;sym&#125;_netlib.f.o    ) &amp;done &lt; comm.symwaitar d $&#123;LIBLAPACK_ADAPT_A&#125; $(sed -ne &#x27;s/$/.f.o/p&#x27; comm.sym)ar d $&#123;LIBLAPACK_ADAPT_A&#125; xerbla.f.oar ru $&#123;LIBLAPACK_ADAPT_A&#125; *_netlib.f.orm *_netlib.f.o\n\n在&#x2F;home目录下输入\nsh sh.sh\n\n运行之，得到如下结果：\n\n看不见是正常的，别担心\n\n\n看不见是正常的，别担心\n\n至此LAPACK用到的脚本已经生成完毕\n接下来先展示如何使用一般c语言代码计算实对称矩阵的特征值与特征向量\n编写eigenNoOpt.c文件，文件内容如下：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;float** Matrix_Jac_Eig(float **array, int n, float *eig);int Matrix_Free(float **tmp, int m, int n);int main(void)&#123;    int n;    printf(&quot;请输入矩阵维度:\\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    float **array = (float **)malloc(n * sizeof(float *));    if (array == NULL)    &#123;        printf(&quot;error :申请数组内存空间失败\\n&quot;);        return -1;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        array[i] = (float *)malloc(n * sizeof(float));        if (array[i] == NULL)        &#123;            printf(&quot;error :申请数组子内存空间失败\\n&quot;);            return -1;        &#125;    &#125;    printf(&quot;请输入矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            scanf(&quot;%f&quot;, &amp;array[i][j]);        &#125;    &#125;    float *eig = (float *)malloc(n * sizeof(float));        struct timespec t1,t2;    printf(&quot;Without KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    float **Result = Matrix_Jac_Eig(array, n, eig);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      printf(&quot;特征矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            printf(&quot;%f &quot;, Result[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;特征根:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        printf(&quot;%f \\n&quot;, eig[i]);    &#125;    Matrix_Free(Result, n, n);    free(eig);    eig = NULL;    return 0;&#125;float** Matrix_Jac_Eig(float **array, int n, float *eig)&#123;    int i, j, flag, k;    flag = 0;    k = 0;    float sum = 0;    float **temp_mat = (float **)malloc(n * sizeof(float *));    for (i = 0; i &lt; n; i++)    &#123;        temp_mat[i] = (float *)malloc(n * sizeof(float));    &#125;    for (i = 0; i &lt; n; i++)    &#123;        for (j = 0; j &lt; n; j++)        &#123;            temp_mat[i][j] = array[i][j];        &#125;    &#125;    //判断是否为对称矩阵    for (i = 0; i &lt; n; i++)    &#123;        for (j = i; j &lt; n; j++)        &#123;            if (array[i][j] != array[j][i])            &#123;                flag = 1;                break;            &#125;        &#125;    &#125;    if (flag == 1)    &#123;        printf(&quot;error in Matrix_Eig: 输入并非是对称矩阵:\\n&quot;);        return NULL;    &#125;    else    &#123;        //开始执行算法        int p, q;        float thresh = 0.0000000001;        float max = array[0][1];        float tan_angle, sin_angle, cos_angle;        float **result = (float **)malloc(n * sizeof(float *));        if (result == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **result_temp = (float **)malloc(n * sizeof(float *));        if (result_temp == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **rot = (float **)malloc(n * sizeof(float *));        if (rot == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **mat = (float **)malloc(n * sizeof(float *));        if (mat == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            result[i] = (float *)malloc(n * sizeof(float));            if (result[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            result_temp[i] = (float *)malloc(n * sizeof(float));            if (result_temp[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            rot[i] = (float *)malloc(n * sizeof(float));            if (rot[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            mat[i] = (float *)malloc(n * sizeof(float));            if (mat[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    result[i][j] = 1;                &#125;                else                &#123;                    result[i][j] = 0;                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    mat[i][j] = 1;                &#125;                else                &#123;                    mat[i][j] = 0;                &#125;            &#125;        &#125;        max = array[0][1];        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    continue;                &#125;                else                &#123;                    if (fabs(array[i][j]) &gt;= fabs(max))                    &#123;                        max = array[i][j];                        p = i;                        q = j;                    &#125;                    else                    &#123;                        continue;                    &#125;                &#125;            &#125;        &#125;        while (fabs(max) &gt; thresh)        &#123;            if (fabs(max) &lt; thresh)            &#123;                break;            &#125;            tan_angle = -2 * array[p][q] / (array[q][q] - array[p][p]);            sin_angle = sin(0.5*atan(tan_angle));            cos_angle = cos(0.5*atan(tan_angle));            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        mat[i][j] = 1;                    &#125;                    else                    &#123;                        mat[i][j] = 0;                    &#125;                &#125;            &#125;            mat[p][p] = cos_angle;            mat[q][q] = cos_angle;            mat[q][p] = sin_angle;            mat[p][q] = -sin_angle;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    rot[i][j] = array[i][j];                &#125;            &#125;            for (j = 0; j &lt; n; j++)            &#123;                rot[p][j] = cos_angle*array[p][j] + sin_angle*array[q][j];                rot[q][j] = -sin_angle*array[p][j] + cos_angle*array[q][j];                rot[j][p] = cos_angle*array[j][p] + sin_angle*array[j][q];                rot[j][q] = -sin_angle*array[j][p] + cos_angle*array[j][q];            &#125;            rot[p][p] = array[p][p] * cos_angle*cos_angle +                array[q][q] * sin_angle*sin_angle +                2 * array[p][q] * cos_angle*sin_angle;            rot[q][q] = array[q][q] * cos_angle*cos_angle +                array[p][p] * sin_angle*sin_angle -                2 * array[p][q] * cos_angle*sin_angle;            rot[p][q] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            rot[q][p] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    array[i][j] = rot[i][j];                &#125;            &#125;            max = array[0][1];            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        continue;                    &#125;                    else                    &#123;                        if (fabs(array[i][j]) &gt;= fabs(max))                        &#123;                            max = array[i][j];                            p = i;                            q = j;                        &#125;                        else                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                eig[i] = array[i][i];            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    sum = 0;                    for (k = 0; k &lt; n; k++)                    &#123;                        sum = sum + result[i][k] * mat[k][j];                    &#125;                    result_temp[i][j] = sum;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    result[i][j] = result_temp[i][j];                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                array[i][j] = temp_mat[i][j];            &#125;        &#125;        Matrix_Free(result_temp, n, n);        Matrix_Free(rot, n, n);        Matrix_Free(mat, n, n);        Matrix_Free(temp_mat, n, n);        return result;    &#125;&#125;int Matrix_Free(float **tmp, int m, int n)&#123;    int i, j;    if (tmp == NULL)    &#123;        return(1);    &#125;    for (i = 0; i &lt; m; i++)    &#123;        if (tmp[i] != NULL)        &#123;            free(tmp[i]);            tmp[i] = NULL;        &#125;    &#125;    if (tmp != NULL)    &#123;        free(tmp);        tmp = NULL;    &#125;    return(0);&#125;\n\n输入如下代码对其进行编译并运行：\ngcc eigenNoOpt.c -o eigenNoOpt -lm./eigenNoOpt    \n\n得到运行结果如下：\n\n看不见是正常的，别担心\n\n对其进行改进，并作体现LAPACK库性能的对比实验如下：\n将传统C语言算法的代码改为如下：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;float** Matrix_Jac_Eig(float **array, int n, float *eig);int Matrix_Free(float **tmp, int m, int n);int main(void)&#123;    int n;    printf(&quot;请输入矩阵维度:\\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    float **array = (float **)malloc(n * sizeof(float *));    if (array == NULL)    &#123;        printf(&quot;error :申请数组内存空间失败\\n&quot;);        return -1;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        array[i] = (float *)malloc(n * sizeof(float));        if (array[i] == NULL)        &#123;            printf(&quot;error :申请数组子内存空间失败\\n&quot;);            return -1;        &#125;    &#125;    printf(&quot;请输入矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            scanf(&quot;%f&quot;, &amp;array[i][j]);        &#125;    &#125;    float *eig = (float *)malloc(n * sizeof(float));        struct timespec t1,t2;    printf(&quot;Without KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    float **Result = Matrix_Jac_Eig(array, n, eig);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      Matrix_Free(Result, n, n);    free(eig);    eig = NULL;    return 0;&#125;float** Matrix_Jac_Eig(float **array, int n, float *eig)&#123;    int i, j, flag, k;    flag = 0;    k = 0;    float sum = 0;    float **temp_mat = (float **)malloc(n * sizeof(float *));    for (i = 0; i &lt; n; i++)    &#123;        temp_mat[i] = (float *)malloc(n * sizeof(float));    &#125;    for (i = 0; i &lt; n; i++)    &#123;        for (j = 0; j &lt; n; j++)        &#123;            temp_mat[i][j] = array[i][j];        &#125;    &#125;    //判断是否为对称矩阵    for (i = 0; i &lt; n; i++)    &#123;        for (j = i; j &lt; n; j++)        &#123;            if (array[i][j] != array[j][i])            &#123;                flag = 1;                break;            &#125;        &#125;    &#125;    if (flag == 1)    &#123;        printf(&quot;error in Matrix_Eig: 输入并非是对称矩阵:\\n&quot;);        return NULL;    &#125;    else    &#123;        //开始执行算法        int p, q;        float thresh = 0.0000000001;        float max = array[0][1];        float tan_angle, sin_angle, cos_angle;        float **result = (float **)malloc(n * sizeof(float *));        if (result == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **result_temp = (float **)malloc(n * sizeof(float *));        if (result_temp == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **rot = (float **)malloc(n * sizeof(float *));        if (rot == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **mat = (float **)malloc(n * sizeof(float *));        if (mat == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            result[i] = (float *)malloc(n * sizeof(float));            if (result[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            result_temp[i] = (float *)malloc(n * sizeof(float));            if (result_temp[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            rot[i] = (float *)malloc(n * sizeof(float));            if (rot[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            mat[i] = (float *)malloc(n * sizeof(float));            if (mat[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    result[i][j] = 1;                &#125;                else                &#123;                    result[i][j] = 0;                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    mat[i][j] = 1;                &#125;                else                &#123;                    mat[i][j] = 0;                &#125;            &#125;        &#125;        max = array[0][1];        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    continue;                &#125;                else                &#123;                    if (fabs(array[i][j]) &gt;= fabs(max))                    &#123;                        max = array[i][j];                        p = i;                        q = j;                    &#125;                    else                    &#123;                        continue;                    &#125;                &#125;            &#125;        &#125;        while (fabs(max) &gt; thresh)        &#123;            if (fabs(max) &lt; thresh)            &#123;                break;            &#125;            tan_angle = -2 * array[p][q] / (array[q][q] - array[p][p]);            sin_angle = sin(0.5*atan(tan_angle));            cos_angle = cos(0.5*atan(tan_angle));            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        mat[i][j] = 1;                    &#125;                    else                    &#123;                        mat[i][j] = 0;                    &#125;                &#125;            &#125;            mat[p][p] = cos_angle;            mat[q][q] = cos_angle;            mat[q][p] = sin_angle;            mat[p][q] = -sin_angle;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    rot[i][j] = array[i][j];                &#125;            &#125;            for (j = 0; j &lt; n; j++)            &#123;                rot[p][j] = cos_angle*array[p][j] + sin_angle*array[q][j];                rot[q][j] = -sin_angle*array[p][j] + cos_angle*array[q][j];                rot[j][p] = cos_angle*array[j][p] + sin_angle*array[j][q];                rot[j][q] = -sin_angle*array[j][p] + cos_angle*array[j][q];            &#125;            rot[p][p] = array[p][p] * cos_angle*cos_angle +                array[q][q] * sin_angle*sin_angle +                2 * array[p][q] * cos_angle*sin_angle;            rot[q][q] = array[q][q] * cos_angle*cos_angle +                array[p][p] * sin_angle*sin_angle -                2 * array[p][q] * cos_angle*sin_angle;            rot[p][q] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            rot[q][p] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    array[i][j] = rot[i][j];                &#125;            &#125;            max = array[0][1];            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        continue;                    &#125;                    else                    &#123;                        if (fabs(array[i][j]) &gt;= fabs(max))                        &#123;                            max = array[i][j];                            p = i;                            q = j;                        &#125;                        else                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                eig[i] = array[i][i];            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    sum = 0;                    for (k = 0; k &lt; n; k++)                    &#123;                        sum = sum + result[i][k] * mat[k][j];                    &#125;                    result_temp[i][j] = sum;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    result[i][j] = result_temp[i][j];                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                array[i][j] = temp_mat[i][j];            &#125;        &#125;        Matrix_Free(result_temp, n, n);        Matrix_Free(rot, n, n);        Matrix_Free(mat, n, n);        Matrix_Free(temp_mat, n, n);        return result;    &#125;&#125;int Matrix_Free(float **tmp, int m, int n)&#123;    int i, j;    if (tmp == NULL)    &#123;        return(1);    &#125;    for (i = 0; i &lt; m; i++)    &#123;        if (tmp[i] != NULL)        &#123;            free(tmp[i]);            tmp[i] = NULL;        &#125;    &#125;    if (tmp != NULL)    &#123;        free(tmp);        tmp = NULL;    &#125;    return(0);&#125;\n\n将调用KML库的那段代码中改为：\n#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include &quot;klapack.h&quot;int main()&#123;      char jobz = &#x27;V&#x27;;     char uplo = &#x27;L&#x27;;     int n = 10;     int lda = 10;     int info = 0;     double w[10];     double *work = NULL;     double qwork;     int lwork = -1;     int *iwork = NULL;     int qiwork;     int liwork = -1;     double a[] =     &#123;  1.23, 2.75, 3.10, 4.56, 5.92, 7.01, 8.40, 9.88, 6.34, 4.59, 2.75, 1.56, 2.49, 3.31, 4.47, 5.90, 6.55, 7.10, 8.22, 5.78,  3.10, 2.49, 1.88, 5.39, 6.23, 7.68, 3.79, 4.12, 6.44, 7.85,  4.56, 3.31, 5.39, 8.94, 4.58, 2.53, 6.83, 7.46, 1.56, 3.21,  5.92, 4.47, 6.23, 4.58, 9.76, 8.90, 5.12, 3.98, 2.63, 6.34,  7.01, 5.90, 7.68, 2.53, 8.90, 6.75, 4.80, 1.94, 3.55, 2.88,  8.40, 6.55, 3.79, 6.83, 5.12, 4.80, 1.64, 9.20, 5.90, 4.75,  9.88, 7.10, 4.12, 7.46, 3.98, 1.94, 9.20, 7.44, 2.38, 6.71,  6.34, 8.22, 6.44, 1.56, 2.63, 3.55, 5.90, 2.38, 0.76, 2.13,  4.59, 5.78, 7.85, 3.21, 6.34, 2.88, 4.75, 6.71, 2.13, 9.32    &#125;;     struct timespec t1,t2;    //定义初始与结束时间    /* Query optimal work size */     dsyevd_(&amp;jobz, &amp;uplo, &amp;n, a, &amp;lda, w, &amp;qwork, &amp;lwork, &amp;qiwork, &amp;liwork, &amp;info);     if (info != 0)     &#123;         return -1;     &#125;     lwork = (int)qwork;     work = (double *)malloc(sizeof(double) * lwork);     liwork = (int)qiwork;     iwork = (int *)malloc(sizeof(int) * liwork);     /* Calculate eigenvalues and eigenvectors */     printf(&quot;With KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    dsyevd_(&amp;jobz, &amp;uplo, &amp;n, a, &amp;lda, w, work, &amp;lwork, iwork, &amp;liwork, &amp;info);     clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。      printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      free(work);     free(iwork);           return 0;&#125;\n\n编译并运行，得到结果如下：\n\n看不见是正常的，别担心\n\n可知LAPACK库对运算的优化效果十分显著\n4.5 使用KML库函数实现R2R变换优化首先是使用一般C语言实现R2R变换\n编写without.c文件，文件内容如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;void r2r_fft(double *in, double *out, int n) &#123;    int k, m, j;    double wr, wi, arg, c, s;    double *temp = (double*)malloc(n * sizeof(double));        // 实数的 R2R FFT 变换实现    for (k = 0; k &lt; n; k++) &#123;        temp[k] = in[k];    &#125;    // R2R FFT 变换    for (m = 1; m &lt;= n / 2; m *= 2) &#123;        wr = cos(M_PI / m);        wi = sin(M_PI / m);        for (k = 0; k &lt; n; k += 2 * m) &#123;            for (j = 0; j &lt; m; j++) &#123;                arg = j * (2 * M_PI / (2 * m));                c = cos(arg);                s = sin(arg);                double u1 = temp[k + j];                double u2 = temp[k + j + m];                double v1 = temp[k + j + m + 1];                out[k + j] = u1 + u2 * c - v1 * s;                out[k + j + 1] = u1 * s + u2 * v1 * c;            &#125;        &#125;    &#125;    free(temp);&#125;int main() &#123;    int rank = 2;     int *n;     struct timespec t1, t2;     n = (int*)malloc(sizeof(int) * rank);     n[0] = 128;  // 修改数据规模    n[1] = 128;  // 修改数据规模    double *in = (double*)malloc(sizeof(double) * n[0] * n[1]);     for (int i = 0; i &lt; n[0] * n[1]; i++) &#123;         in[i] = (double)(i % 10);  // 用一些基本的数值初始化输入数据    &#125;     double *out = (double*)malloc(sizeof(double) * n[0] * n[1]);    clock_gettime(CLOCK_MONOTONIC, &amp;t1);      // 计算开始时间    r2r_fft(in, out, n[0] * n[1]);            // 执行 R2R FFT    clock_gettime(CLOCK_MONOTONIC, &amp;t2);      // 计算结束时间    printf(&quot;Without KML:\\n&quot;);    printf(&quot;Time: %11u ns\\n&quot;, t2.tv_nsec - t1.tv_nsec);      free(n);    free(in);     free(out);    return 0;&#125;\n\n使用如下代码编译并运行\ngcc without.c -o without -lm./without    \n\n得到结果如下：\n\n看不见是正常的，别担心\n\n接着再使用KML_FFT库函数进行优化：\n编写FFT.c文件，内容如下：\n#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &quot;kfft.h&quot;int main() &#123;    int rank = 2;     int *n;     struct timespec t1, t2;    // 定义初始与结束时间    n = (int*)kml_fft_malloc(sizeof(int) * rank);     n[0] = 128;  // 修改数据规模    n[1] = 128;  // 修改数据规模    double *in = (double*)kml_fft_malloc(sizeof(double) * n[0] * n[1]);     for (int i = 0; i &lt; n[0] * n[1]; i++) &#123;         in[i] = (double)(i % 10);  // 用一些基本的数值初始化输入数据    &#125;     double *out = (double*)kml_fft_malloc(sizeof(double) * n[0] * n[1]);     kml_fft_r2r_kind *kind = (kml_fft_r2r_kind*)kml_fft_malloc(sizeof(kml_fft_r2r_kind) * rank);     kind[0] = KML_FFT_DHT;     kind[1] = KML_FFT_DHT;     kml_fft_plan plan;     clock_gettime(CLOCK_MONOTONIC, &amp;t1);      // 计算开始时间    plan = kml_fft_plan_r2r(rank, n, in, out, kind, KML_FFT_ESTIMATE);     kml_fft_execute_r2r(plan, in, out);     clock_gettime(CLOCK_MONOTONIC, &amp;t2);      // 计算结束时间     printf(&quot;With KML:\\n&quot;);    printf(&quot;Time: %11u ns\\n&quot;, t2.tv_nsec - t1.tv_nsec);      printf(&quot;\\n&quot;);    kml_fft_destroy_plan(plan);     kml_fft_free(n);     kml_fft_free(kind);     kml_fft_free(in);     kml_fft_free(out);     return 0;&#125;\n\n使用如下代码编译并运行\ngcc FFT.c -o FFT -L /usr/local/kml/lib -lkfft -I /usr/local/kml/include -pthread./FFT\n\n得到运行结果如下：\n\n看不见是正常的，别担心\n\n可知KML库对R2R FFT运算的优化效果十分显著\n5.实验结果分析1. 牛顿迭代法求解非线性方程的根\n实现了牛顿迭代法，通过简单的非线性方程（如 $f(x)&#x3D;x2−2$）验证计算结果的准确性。\n传统实现和 KML 的计算结果一致，说明 KML 提供的数学库可以准确求解非线性问题。\n\n2. 矩阵-向量乘加运算性能对比\n在矩阵规模为 1000×300 的情况下，KML 的矩阵乘加操作（cblas_dgemv）相比手动实现加速显著。\n时间数据\n手动实现耗时较长，主要由于逐元素计算导致的循环开销。\n调用 KML 提供的 BLAS 库后，耗时明显减少，充分利用了向量化和并行化。\n\n\n结论：KML 在矩阵计算场景中展现了出色的性能提升。\n\n3. KML_VML 向量数学运算优化\n比较普通循环与 KML 的矢量数学库处理大规模向量（如 100,000 元素）的性能。\n时间数据\n传统实现逐元素计算，耗时较长。\nKML 利用硬件寄存器和 SIMD 指令对数据进行批量处理，极大缩短了运算时间。\n\n\n分析：适合高频调用数学函数的场景，例如模拟计算和信号处理。\n\n4. 快速傅里叶变换（FFT）优化\n对比一般 FFT 算法和 KML_FFT 实现的性能。\n时间数据\n手动实现 FFT 的时间复杂度较高。\nKML 的 kml_fft_plan_r2r 方法不仅加速了计算，还简化了实现过程。\n\n\n结论：KML 的 FFT 模块对高维变换计算尤为高效。\n\n5. LAPACK 在实对称矩阵特征值计算中的优化\n测试任务：计算 $10\\times10$ 实对称矩阵的特征值和特征向量。\n结果分析\n传统实现（如 Jacobi 方法）存在显著计算瓶颈。\n调用 KML 提供的 LAPACK 接口后，计算时间大幅缩短，进一步展示了 KML 在线性代数中的优化潜力。\n\n\n\n通过上述实验，验证了鲲鹏数学库（KML）的性能和适用性。无论是基础数学运算、矩阵计算，还是更复杂的快速变换与特征值问题，KML 的表现均优于传统实现。同时，实验中总结出的优化方法对未来的高性能计算实践提供了有力支持。\n6 思考题使用KML_SVML进行短向量的数学运算优化KML_SVML是短向量的数学运算，包括幂函数、三角函数、指数函数、双曲函数、对数函数等。 KML_SVML通过Neon指令优化、内联汇编等方法，对输入向量进行批量处理，充分利用了鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升。\n请在下面代码空缺处将调用KML_SVML库函数对短向量的数学运算进行优化的代码补充完整\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;ksvml.h&quot;#define LEN 100000int main()&#123;double src[LEN]=&#123;0&#125;;double dst1[LEN]=&#123;0&#125;;double dst2[LEN]=&#123;0&#125;;float32x4_t src2;float32x4_t dst;struct timespec t1,t2; //定义初始与结束时间printf(&quot;Without KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。for(int i=0;i&lt;LEN;i++)src[i]=i;for(int i=0;i&lt;LEN;i++)dst1[i]=sin(src[i]);clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。printf(&quot;With KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。  for(int i=0;i&lt;LEN;i+=4)&#123;   \t//请在此处补充调用KML_SVML库函数对短向量的数学运算进行优化的代码    &#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。return 0;&#125;\n\n答案如下：\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;ksvml.h&quot;#define LEN 100000int main()&#123;double src[LEN]=&#123;0&#125;;double dst1[LEN]=&#123;0&#125;;double dst2[LEN]=&#123;0&#125;;float32x4_t src2;float32x4_t dst;struct timespec t1,t2; //定义初始与结束时间printf(&quot;Without KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。for(int i=0;i&lt;LEN;i++)src[i]=i;for(int i=0;i&lt;LEN;i++)dst1[i]=sin(src[i]);clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。printf(&quot;With KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。  for(int i=0;i&lt;LEN;i+=4)&#123;    src2[0]=i;    src2[1]=i+1;    src2[2]=i+2;    src2[3]=i+3;    dst = svml128_sin_f32(src2);&#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。return 0;&#125;\n\n输入\ngcc svsin.c -o svsin -I /usr/local/kml/include -L /usr/local/kml/lib -lksvml -lm./svsin\n\n编译并运行得到运行结果如下：\n\n看不见是正常的，别担心\n\n通过对比可知使用KML_SVML进行短向量的数学运算优化的优化效果十分显著\n","categories":["学习"],"tags":["计算机组成原理","论文","华为","鲲鹏"]},{"title":"Optimizing Renewable Energy Grid Integration & Forecasting and Scheduling for Wind and Solar Farms","url":"/2024/12/03/CAMCM/","content":" Attached paper .\n","categories":["学习"],"tags":["数模"]},{"title":"美赛苟活大法","url":"/2024/12/26/%E7%BE%8E%E8%B5%9B%E8%8B%9F%E6%B4%BB%E5%A4%A7%E6%B3%95/","content":"十分、万分感谢来自对外经济贸易大学的藏羚羊，本美赛苟活大法是由她编写的，此处仅搬运分享，再次表达感谢！！！\n美赛苟活大法\n下面是藏羚羊的微信公众号，请复制链接后在微信中打开😊 \n\n        \n        聆言'Econ小学二年级已修读完毕😎'","categories":["学习"],"tags":["资料"]},{"title":"2024-2025","url":"/2025/01/01/2024-2025/","content":"时间过得真快，2024也过去了\n浅浅总结一下2024吧\nTo be continue !\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"数据结构与算法重点","url":"/2024/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%87%8D%E7%82%B9/","content":"考题题型：\n选择题10*2\n简答题7*10\n编程题2*10\n\n        \n        手写笔记'数据结构复习手册😎'\n\n\n下面标*的为必考大概率(99.99%)考 如果没考就是那(0.01%)\n选择题*各种排序的时空复杂度\n判断时间复杂度\n存储结构的分类\n最小比较次数\n二分法查找次数\n*栈和队列出入顺序\n链表的插入\n简单模式匹配时间复杂度\n合并两个有序表的代码实现\n*二叉树的先序、中序、后序\n*二叉树结点和度的关系\n*哈夫曼树编码\nB树的概念\n深度优先遍历和广度优先遍历\n二叉树的高度和层数\n二叉搜索树的概念 以及查找次数分析\n平衡二叉树的概念\n满二叉树的概念\n线索化二叉树 代码片段\n图的邻接矩阵\n图各种算法的时间复杂度\n判断图是否有环\n各种排序第一趟或第二趟后的结果\n各排序在有序时花费时间最多的\n散列排序的问题分析\n简答题*Dijkstra算法\n*Prim算法\n*AVL平衡二叉搜索树的建立与删除\n*哈夫曼树编码\n*先序、中序、后序遍历序列与树的结合\n*森林与二叉树的转化\n*各种排序第一趟或第二趟后的结果\n哈希表查找\n堆的建立、插入、删除堆顶元素\n编程题*快速排序算法\n链表树的定义\n","categories":["学习"],"tags":["数据结构与算法"]},{"title":"具体数学重点","url":"/2025/01/03/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6%E9%87%8D%E7%82%B9/","content":"\n        \n        手写笔记'具体数学复习手册😎'\n\n\n","categories":["学习"],"tags":["具体数学"]},{"title":"基于华为云与frp实现内网穿透连接树莓派","url":"/2025/01/16/%E5%9F%BA%E4%BA%8E%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%8Efrp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","content":"放寒假了~ 买了好久的树莓派，终于可以开始玩了。\n首先就是通过raspberry pi imager进行基本的系统下载，在下载系统时设置好wifi并打开ssh连接，然后树莓派开机连接wifi后就能用同一网络下的电脑使用ssh连接树莓派了，进一步的，如果下载的是有图形化界面的系统，就可以用VNC进行远程桌面操控。因为没有显示屏，所以不得不使用这种方法连接树莓派咳咳\n接着，就想到这种方法只能在同一局域网下通过电脑连接树莓派，如果我在其他地方要远程控制树莓派就行不通了。因此，就需要内网穿透技术，下面我将基于华为云服务器实现内网穿透通过ssh连接树莓派。\n1.准备工作\n一台具有公网IP的服务器：\n用于运行frp服务端（例如华为云服务器）。\n\n在购买华为云服务器时需要购买并绑定相应的弹性公网ip才能有网络连接\n华为云服务器的安全组的对应端口要打开，后面会提到\n\n\n树莓派：\n确保树莓派已连接到网络，并启用SSH。\n\n下载frp：\n访问 frp GitHub Releases 下载适合树莓派和服务器的版本。\n\n树莓派（ARM架构）：frp_0.xx.0_linux_arm.tar.gz（我下载时最新的版本是frp_0.61.1_linux_arm.tar.gz）\n服务器（x86架构）：frp_0.xx.0_linux_amd64.tar.gz（我下载时最新的版本是 frp_0.61.1_linux_amd64.tar.gz）\n\n\n\n2.在服务器上配置frp服务端\n登录服务器：\n 使用SSH连接到你的公网服务器。\n\n下载并解压frp：\nwget https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_amd64.tar.gztar -zxvf frp_0.61.1_linux_amd64.tar.gzcd frp_0.61.1_linux_amd64\n注意，wget 在尝试下载 frp 时有几率遇到连接问题，可能是由于网络问题或 GitHub 的访问限制。此时可以在自己的电脑上下载，下载完后通过winSCP将文件传给华为云服务器，或者通过scp命令将文件传给服务器。\nscp frp_0.61.1_linux_amd64.tar.gz root@服务器公网IP:/root/\n\n配置frp服务端：\n编辑 frps.ini 文件：\n nano frps.ini\n\n 添加以下内容：\n  [common]bind_port = 7000\n\n\nbind_port 是frp服务端监听的端口。\n\n注意，此处的7000可以改成其他的端口，只要不冲突就行，也建议进行修改，在后续的安全组配置中要改成对应的端口号。\n\n\n保存并退出：\n\n保存文件：\n按下 Ctrl + O（即按住 Ctrl 键，然后按 O 键）。\n按 Enter 确认保存。\n\n退出 nano：\n   按下 Ctrl + X 退出编辑器。\n\n\n\n启动frp服务端：\n./frps -c frps.ini\n\n服务端会监听 7000 端口，等待客户端连接。\n\n保持服务端运行：\n可以使用 nohup 或 systemd 让frp服务端在后台运行：\nnohup ./frps -c frps.ini &gt; frps.log 2&gt;&amp;1 &amp;\n\n配置华为云安全组：\n\n登录华为云控制台，找到你的服务器实例。\n\n进入“安全组”配置，添加以下规则：\n\n协议：TCP\n端口范围：7000（或者更改为其他的合法端口）\n源地址：0.0.0.0&#x2F;0（或限制为你的电脑IP）\n\n\n保存规则。\n\n\n\n\n7.检查服务端是否运行：\n  ps aux | grep frps\n\n如果没有输出，说明 frp 服务端未运行，需要重新启动：\n ./frps -c frps.ini\n\n 补充：在ssh连接下可以用ctrl+D快速退出ssh连接，也能输入exit退出ssh连接\n3. 在树莓派上配置frp客户端\n登录树莓派：\n使用SSH连接到树莓派。\n\n下载并解压frp：\nwget https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_arm.tar.gztar -zxvf frp_0.61.1_linux_arm.tar.gzcd frp_0.61.1_linux_arm\n注意，此处和上面的问题一样，在下载frp时可能会有一些问题，此时可以在自己的电脑上下载，下载完后通过winSCP将文件传给树莓派，或者通过scp命令将文件传给树莓派。\n\n使用 scp 上传文件\nscp 是一个基于 SSH 的文件传输工具，可以将本地文件上传到远程服务器（如树莓派）。\n在本地电脑上执行以下命令：\n\nMac&#x2F;Linux：\n\n打开终端，运行以下命令：\nscp /path/to/frp_0.61.1_linux_arm.tar.gz pi@树莓派IP:/home/pi/\n\n\n将 /path/to/frp_0.61.1_linux_arm.tar.gz 替换为文件的实际路径。\n将 树莓派IP 替换为树莓派的局域网 IP 地址（如 192.168.1.100）。\n默认上传到树莓派的 /home/pi/ 目录。\n\n\n\n\nWindows：\n\n如果你使用的是 PowerShell，可以运行以下命令：\nscp C:\\Users\\username\\Downloads\\frp_0.61.1_linux_arm.tar.gz pi@树莓派IP:/home/pi/\n\n\n将 C:\\Users\\username\\Downloads\\frp_0.61.1_linux_arm.tar.gz 替换为文件的实际路径。\n将 树莓派IP 替换为树莓派的局域网 IP 地址。\n\n\n\n\n输入密码：\n\n系统会提示你输入树莓派的密码（默认密码是 raspberry）。\n输入密码后，文件会上传到树莓派。\n\n\n\n\n\n配置frp客户端：\n编辑 frpc.ini 文件：\nnano frpc.ini\n\n添加以下内容：\n[common]server_addr = 服务器公网IPserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000\n\n\nserver_addr：填写你的服务器公网IP。\nserver_port：与服务端的 bind_port 一致（默认7000，如果之前有修改，此处也要进行相应的修改）。\n[ssh]：定义一个SSH隧道，将服务器的 6000 端口映射到树莓派的 22 端口。\n\n\n启动frp客户端：\n./frpc -c frpc.ini\n\n客户端会连接到服务器，并将服务器的 6000 端口映射到树莓派的SSH服务。\n\n保持客户端运行：\n 可以使用 nohup 或 systemd 让frp客户端在后台运行：\n nohup ./frpc -c frpc.ini &gt; frpc.log 2&gt;&amp;1 &amp;\n\n检查服务端是否运行：\n ps aux | grep frps\n\n  如果没有输出，说明 frp 客户端未运行，需要重新启动：\n  ./frpc -c frpc.ini\n  补充：在ssh连接下可以用ctrl+D快速退出ssh连接，也能输入exit退出ssh连接\n\n检查端口监听状态：\n 运行以下命令，检查 7000 端口是否被 frp 服务端监听：\n sudo netstat -tuln | grep 7000\n\n  如果看到类似以下输出，说明端口已监听：\n   tcp        0      0 0.0.0.0:7000            0.0.0.0:*               LISTEN\n\n  如果没有输出，说明 frp 服务端未正确监听端口。\n\n检查 frp 客户端日志：\n 查看 frp 客户端的日志文件：\n  cat frpc.log\n\n 如果日志中有错误信息（如连接失败），请根据错误信息进行排查。\n\n\n4. 远程SSH连接树莓派\n通过服务器连接树莓派：\n\n在自己的电脑上使用以下命令通过服务器的公网IP和映射端口连接树莓派：\nssh -p 6000 pi@服务器公网IP\n\n输入树莓派的用户名（默认 pi）和密码即可登录。\n\n\n\n直接连接（如果配置了DDNS）：\n\n如果服务器绑定了域名（如 mypi.ddns.net），可以使用域名连接：\nssh -p 6000 pi@mypi.ddns.net\n\n\n\n至此，应该就可以基于华为云与frp实现内网穿透连接树莓派了，下面给出一些实用性和安全性建议\n5. 设置开机自启动为了确保frp客户端在树莓派重启后自动运行，可以将其设置为系统服务。\n\n创建systemd服务文件：\nsudo nano /etc/systemd/system/frpc.service\n\n添加以下内容：\n[Unit]Description=Frp Client ServiceAfter=network.target[Service]ExecStart=/home/pi/frp_0.61.1_linux_arm/frpc -c /home/pi/frp_0.61.1_linux_arm/frpc.iniRestart=on-failure[Install]WantedBy=multi-user.target\n\n\n修改 ExecStart 路径为你的frp客户端实际路径。\n\n\n启用并启动服务：\nsudo systemctl enable frpcsudo systemctl start frpc\n\n检查服务状态：\nsudo systemctl status frpc\n\n6. 安全性建议\n修改默认SSH端口：\n在树莓派上修改SSH端口（如 2222），并在frp客户端配置中同步修改 local_port。\n\n使用密钥认证：\n禁用密码登录，使用SSH密钥认证。\n\n限制访问IP：\n在服务器防火墙中限制 6000 端口的访问IP。\n\n\n","categories":["学习"],"tags":["华为","树莓派"]}]