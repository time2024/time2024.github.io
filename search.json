[{"title":"2024-2025","url":"/2025/01/01/2024-2025/","content":"时间过得真快，2024也过去了\n浅浅总结一下2024吧\nTo be continue !\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"stm32f407驱动BMX055记录","url":"/2024/11/14/BMX055/","content":"stm32f407驱动BMX055记录前两天BOSS交给我一个BMX055芯片让我试试能不能用\n真的就一个芯片\n\n长下面这样\n\n刚好学习一下如何使用没有模块化的芯片\n首先是接线问题，在网络上找不到现成的BMX055芯片连线连到stm32的接线图，在询问多个学长后得知有以下几种途径\n\n查技术手册\n在各个平台上搜索有用到这个芯片的模块\n\n技术手册首先可以在半导小芯等多个平台搜索这个芯片找到这个芯片的技术手册，中英文都可以，尽量看英文手册。\n为了方便可以直接在此下载 BMX055 技术手册\n然后找到你需要的接线，比如我需要用iic与之通讯，则找到iic的接线图如下：\n\n同时可以参考引脚定义来辅助接线\n\n在刚接线时别急着一次性就把他用好，而是先把基本的接线连好（可以先不连中断），然后先读chip id，确定基本的硬件连线没有问题，芯片上电之后可以工作，再去连中断线\n是的，我这个芯片连线就连了，拔了，连了，拔了重复了好几次，所以不要放弃，多试试吧\n\n\n接线完成了\n然后就是配置stm32f407的iic了\n网上搜到的大部分都是stm32f1的，所以我稍作修改，并添加了一些我自己写的函数，附在下面供大家取用\n\n&#x2F;&#x2F;myiic.c\n//myiic.c#include &quot;myiic.h&quot;#include &quot;delay.h&quot;//初始化IICvoid IIC_Init(void)&#123;\t\t\t  GPIO_InitTypeDef  GPIO_InitStructure;  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);//使能GPIOB时钟  //GPIOB8,B9初始化设置  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//初始化\tIIC_SCL=1;\tIIC_SDA=1;&#125;//产生IIC起始信号void IIC_Start(void)&#123;\tSDA_OUT();     //sda线输出\tIIC_SDA=1;\t  \t  \tIIC_SCL=1;\tdelay_us(4); \tIIC_SDA=0;//START:when CLK is high,DATA change form high to low \tdelay_us(4);\tIIC_SCL=0;//钳住I2C总线，准备发送或接收数据 &#125;\t  //产生IIC停止信号void IIC_Stop(void)&#123;\tSDA_OUT();//sda线输出\tIIC_SCL=0;\tIIC_SDA=0;//STOP:when CLK is high DATA change form low to high \tdelay_us(4);\tIIC_SCL=1; \tIIC_SDA=1;//发送I2C总线结束信号\tdelay_us(4);\t\t\t\t\t\t\t   \t&#125;//等待应答信号到来//返回值：1，接收应答失败//        0，接收应答成功u8 IIC_Wait_Ack(void)&#123;\tu8 ucErrTime=0;\tSDA_IN();      //SDA设置为输入  \tIIC_SDA=1;delay_us(1);\t   \tIIC_SCL=1;delay_us(1);\t \twhile(READ_SDA)\t&#123;\t\tucErrTime++;\t\tif(ucErrTime&gt;250)\t\t&#123;\t\t\tIIC_Stop();\t\t\treturn 1;\t\t&#125;\t&#125;\tIIC_SCL=0;//时钟输出0 \t   \treturn 0;  &#125; //产生ACK应答void IIC_Ack(void)&#123;\tIIC_SCL=0;\tSDA_OUT();\tIIC_SDA=0;\tdelay_us(2);\tIIC_SCL=1;\tdelay_us(2);\tIIC_SCL=0;&#125;//不产生ACK应答\t\t    void IIC_NAck(void)&#123;\tIIC_SCL=0;\tSDA_OUT();\tIIC_SDA=1;\tdelay_us(2);\tIIC_SCL=1;\tdelay_us(2);\tIIC_SCL=0;&#125;\t\t\t\t\t \t\t\t\t     //IIC发送一个字节//返回从机有无应答//1，有应答//0，无应答\t\t\t  void IIC_Send_Byte(u8 txd)&#123;                            u8 t;   \tSDA_OUT(); \t        IIC_SCL=0;//拉低时钟开始数据传输    for(t=0;t&lt;8;t++)    &#123;                      IIC_SDA=(txd&amp;0x80)&gt;&gt;7;        txd&lt;&lt;=1; \t  \t\tdelay_us(2);   //对TEA5767这三个延时都是必须的\t\tIIC_SCL=1;\t\tdelay_us(2); \t\tIIC_SCL=0;\t\t\tdelay_us(2);    &#125;\t &#125; \t    //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   u8 IIC_Read_Byte(unsigned char ack)&#123;\tunsigned char i,receive=0;\tSDA_IN();//SDA设置为输入    for(i=0;i&lt;8;i++ )\t&#123;        IIC_SCL=0;         delay_us(2);\t\tIIC_SCL=1;        receive&lt;&lt;=1;        if(READ_SDA)receive++;   \t\tdelay_us(1);     &#125;\t\t\t\t\t     if (!ack)        IIC_NAck();//发送nACK    else        IIC_Ack(); //发送ACK       return receive;&#125;void WriteData(u8 DevID,u8 Addr,u8 Dat)&#123;\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1| 0);\t//发送设备地址和写信号\tIIC_Wait_Ack();\tIIC_Send_Byte(Addr);\tIIC_Wait_Ack();\tIIC_Send_Byte(Dat);\tIIC_Wait_Ack();\tIIC_Stop();\tdelay_ms(10);&#125;void ReadData(u8 DevID,u8 Addr,u8 *Pbuf,u8 Num)&#123;\tu8 i;\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1 | 0);\t//发送设备地址和写信号\tIIC_Wait_Ack();\tIIC_Send_Byte(Addr);\tIIC_Wait_Ack();\tIIC_Start();\tIIC_Send_Byte(DevID &lt;&lt; 1 | 1);\t//发送设备地址和读信号\tIIC_Wait_Ack();\tfor(i = 0;i &lt; (Num - 1);i ++)\t&#123;\t\tPbuf[i] = IIC_Read_Byte(1);\t&#125;\tPbuf[i] = IIC_Read_Byte(0);\tIIC_Stop();\tdelay_ms(5);&#125;\n\n\n&#x2F;&#x2F;myiic.h\n//myiic.h#ifndef __MYIIC_H#define __MYIIC_H#include &quot;sys.h&quot;    \t   \t\t   //IO方向设置#define SDA_IN()  &#123;GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(9*2));GPIOB-&gt;MODER|=0&lt;&lt;9*2;&#125;\t//PB9输入模式#define SDA_OUT() &#123;GPIOB-&gt;MODER&amp;=~(3&lt;&lt;(9*2));GPIOB-&gt;MODER|=1&lt;&lt;9*2;&#125; //PB9输出模式//IO操作函数\t #define IIC_SCL    PBout(8) //SCL#define IIC_SDA    PBout(9) //SDA\t #define READ_SDA   PBin(9)  //输入SDA //IIC所有操作函数void IIC_Init(void);                //初始化IIC的IO口\t\t\t\t void IIC_Start(void);\t\t\t\t//发送IIC开始信号void IIC_Stop(void);\t  \t\t\t//发送IIC停止信号void IIC_Send_Byte(u8 txd);\t\t\t//IIC发送一个字节u8 IIC_Read_Byte(unsigned char ack);//IIC读取一个字节u8 IIC_Wait_Ack(void); \t\t\t\t//IIC等待ACK信号void IIC_Ack(void);\t\t\t\t\t//IIC发送ACK信号void IIC_NAck(void);\t\t\t\t//IIC不发送ACK信号void IIC_Write_One_Byte(u8 daddr,u8 addr,u8 data);u8 IIC_Read_One_Byte(u8 daddr,u8 addr);\t  void WriteData(u8 DevID,u8 Addr,u8 Dat);void ReadData(u8 DevID,u8 Addr,u8 *Pbuf,u8 Num);#endif\n\n\n接下来就是参考芯片技术手册，编写初始化函数等，通过iic与之通讯\n&#x2F;&#x2F;BMX055.c\n//BMX055.c#include &quot;usart.h&quot;#include &quot;BMX055.h&quot;#include &quot;myiic.h&quot;void IMU_Init(void)&#123;\tWriteData(Acc_addr,0x0F, 0x03);//reset \t\t复位acc\tWriteData(Acc_addr,0x10, 0x08);//+/- 16g\t设置acc的测量范围\tWriteData(Acc_addr,0x11, 0x00);\tdelay_us(100);\tWriteData(Gyro_addr,0x0F, 0x04);\tWriteData(Gyro_addr,0x10, 0x07);// 500\tWriteData(Gyro_addr,0x11, 0x00);\tdelay_us(100);\tWriteData(Mag_addr,0x4B, 0x83);\tdelay_us(100);\tWriteData(Mag_addr,0x4B, 0x01);\tdelay_us(100);\tWriteData(Mag_addr, 0x4c, 0x00); //00000000\t\t将mag由sleep mode切换到normal mode（active）\tWriteData(Mag_addr, 0x4E, 0x84);\tWriteData(Mag_addr, 0x51, 0x04);\tWriteData(Mag_addr, 0x52, 0x16);\tdelay_us(100);&#125;// 初始化BMX055加速度计void BMX055_Init_Accelerometer() &#123; WriteData(Acc_addr, 0x0F, 0x03); // 设置范围为±2g WriteData(Acc_addr, 0x10, 0x08); // 设置带宽为7.81 Hz WriteData(Acc_addr, 0x11, 0x00); // 正常模式，睡眠时长0.5ms delay_us(100000); // 延迟等待配置生效&#125;// 初始化BMX055陀螺仪void BMX055_Init_Gyroscope() &#123; WriteData(Gyro_addr, 0x0F, 0x04); // 设置范围为±125度/秒 WriteData(Gyro_addr, 0x10, 0x07); // 设置输出数据速率为100 Hz WriteData(Gyro_addr, 0x11, 0x00); // 正常模式，睡眠时长2msdelay_us(100000); // 延迟等待配置生效&#125;// 初始化BMX055磁力计void BMX055_Init_Magnetometer() &#123; WriteData(Mag_addr, 0x4B, 0x83); // 软复位 WriteData(Mag_addr, 0x4C, 0x00); // 正常模式，输出数据速率为10 Hz WriteData(Mag_addr, 0x4E, 0x84); // 启用X、Y、Z轴 WriteData(Mag_addr, 0x51, 0x04); // 设置X-Y轴重复次数为9 WriteData(Mag_addr, 0x52, 0x0F); // 设置Z轴重复次数为15delay_us(100000); // 延迟等待配置生效&#125;// 读取加速度计数据void BMX055_Read_Accelerometer(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Acc_addr, 0x02, data, 6); *x = (int16_t)((data[1] &lt;&lt; 8) | (data[0] &amp; 0xF0)) &gt;&gt; 4; // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 8) | (data[2] &amp; 0xF0)) &gt;&gt; 4; // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 8) | (data[4] &amp; 0xF0)) &gt;&gt; 4; // Z轴数据 if (*x &gt; 2047) *x -= 4096; // 负值处理 if (*y &gt; 2047) *y -= 4096; if (*z &gt; 2047) *z -= 4096;&#125;// 读取陀螺仪数据void BMX055_Read_Gyroscope(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Gyro_addr, 0x02, data, 6); *x = (int16_t)((data[1] &lt;&lt; 8) | data[0]); // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 8) | data[2]); // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 8) | data[4]); // Z轴数据 if (*x &gt; 32767) *x -= 65536; // 负值处理 if (*y &gt; 32767) *y -= 65536; if (*z &gt; 32767) *z -= 65536;&#125;// 读取磁力计数据void BMX055_Read_Magnetometer(int16_t *x, int16_t *y, int16_t *z) &#123; uint8_t data[6]; ReadData(Mag_addr, 0x42, data, 6); *x = (int16_t)((data[1] &lt;&lt; 5) | (data[0] &gt;&gt; 3)); // X轴数据 *y = (int16_t)((data[3] &lt;&lt; 5) | (data[2] &gt;&gt; 3)); // Y轴数据 *z = (int16_t)((data[5] &lt;&lt; 7) | (data[4] &gt;&gt; 1)); // Z轴数据 if (*x &gt; 4095) *x -= 8192;  // 负值处理 if (*y &gt; 4095) *y -= 8192; if (*z &gt; 16383) *z -= 32768;&#125;// 读取所有传感器数据的示例void BMX055_Read_All() &#123; int16_t xAccl, yAccl, zAccl; int16_t xGyro, yGyro, zGyro; int16_t xMag, yMag, zMag; BMX055_Read_Accelerometer(&amp;xAccl, &amp;yAccl, &amp;zAccl); // 读取加速度计数据 BMX055_Read_Gyroscope(&amp;xGyro, &amp;yGyro, &amp;zGyro); // 读取陀螺仪数据 BMX055_Read_Magnetometer(&amp;xMag, &amp;yMag, &amp;zMag); // 读取磁力计数据 printf(&quot;加速度 X: %d, Y: %d, Z: %d\\n&quot;, xAccl, yAccl, zAccl); printf(&quot;陀螺仪 X: %d, Y: %d, Z: %d\\n&quot;, xGyro, yGyro, zGyro); printf(&quot;磁场 X: %d, Y: %d, Z: %d\\n&quot;, xMag, yMag, zMag);&#125;// 读取chip idvoid BMX055_Read_Chip_Id() &#123; uint8_t data; ReadData(Acc_addr, 0x00, &amp;data, 1);  // 使用指针传递data printf(&quot;Acc_addr chip_id:%d\\n&quot;, data); ReadData(Gyro_addr, 0x00, &amp;data, 1); printf(&quot;Gyro_addr chip_id:%d\\n&quot;, data); ReadData(Mag_addr, 0x40, &amp;data, 1); printf(&quot;Mag_addr chip_id:%d\\n&quot;, data);&#125;\n\n\n&#x2F;&#x2F;BMX055.h\n//BMX055.h#ifndef __BMX055_H#define __BMX055_H#include &quot;stm32f4xx.h&quot;#include &quot;sys.h&quot; #define AccSen\t\t\t\t\t\t\t0.0078125\t//g/lsb @ +/- 16g#define GyroSen\t\t\t\t\t\t\t0.01524\t\t//°/s/lsb @ 500#define TempSen\t\t\t\t\t\t\t0.5\t\t\t//K/LSB center temperature is 23℃#define MagxySen\t\t\t\t\t\t0.3\t\t\t//uT/lsb#define MagzSen\t\t\t\t\t\t\t0.15\t\t//uT/lsb//SDO1 SDO2 CSB3 pulled to GND#define Acc_addr\t\t\t\t\t\t0x18 #define Gyro_addr\t\t\t\t\t\t0x68 #define Mag_addr\t\t\t\t\t\t0x10 /* BMX055 Register Map *///ACC define#define\tACC_ID\t\t\t\t\t\t\t0x00\t//OXFA#define\tACC_XL\t\t\t\t\t\t\t0x02#define\tACC_XM\t\t\t\t\t\t\t0x03#define\tACC_YL\t\t\t\t\t\t\t0x04#define\tACC_YM\t\t\t\t\t\t\t0x05#define\tACC_ZL\t\t\t\t\t\t\t0x06#define\tACC_ZM\t\t\t\t\t\t\t0x07#define\tTemp\t\t\t\t\t\t\t0x08#define ACC_range\t\t\t\t\t\t0x0f\t//1100b --&gt; +/- 16g#define Shasow_dis\t\t\t\t\t\t0x13#define ACC_ret\t\t\t\t\t\t\t0x14\t//write 0xb6//Gyro define#define\tGYRO_ID\t\t\t\t\t\t\t0x00\t//OXOF#define\tGYRO_XL\t\t\t\t\t\t\t0x02#define\tGYRO_XM\t\t\t\t\t\t\t0x03#define\tGYRO_YL\t\t\t\t\t\t\t0x04#define\tGYRO_YM\t\t\t\t\t\t\t0x05#define\tGYRO_ZL\t\t\t\t\t\t\t0x06#define\tGYRO_ZM\t\t\t\t\t\t\t0x07#define GYRO_range\t\t\t\t\t\t0x0f\t//010b --&gt; +/- 500°/s#define GYRO_ret\t\t\t\t\t\t0x14\t//write 0xb6#define GYRO_OFFSET_reset\t\t\t\t0x21\t//writing 1 to the (0x21) offset_reset bit, all dynamic offset compensation register are reset to zero#define GYRO_SLOW_OFFSET_EN\t\t\t\t0x31\t//EN: &lt;0:2&gt; x/y/z Adjustable rate: &lt;7:6&gt; Time_period &lt;5:3&gt;#define GYRO_SLOW_OFFSET_UNFILT\t\t\t0x1A\t//&lt;5&gt;#define GYRO_FAST_OFFSET_EN\t\t\t\t0x32\t//EN: &lt;0:2&gt; x/y/z Cancellation Start: &lt;3&gt; (if the algorithm finished, &lt;3&gt;will reset to 0) Time_period &lt;5:3&gt;#define GYRO_FAST_OFFSET_UNFILT\t\t\t0x1A\t//&lt;5&gt;#define GYRO_X_OFFSET\t\t\t\t\t0x36#define GYRO_Y_OFFSET\t\t\t\t\t0x37#define GYRO_Z_OFFSET\t\t\t\t\t0x38//MAG define 8bits register 0x40 - 0x71// 0X40 - 0X4A read only#define\tMAG_ID\t\t\t\t\t\t\t0x40\t//OX32#define\tMAG_XL\t\t\t\t\t\t\t0x42\t//read only: data x[4:0]  lsb #define\tMAG_XM\t\t\t\t\t\t\t0x43\t//read only: data x[12:5] msb  x-self-test#define\tMAG_YL\t\t\t\t\t\t\t0x44\t//read only: data x[4:0]  lsb #define\tMAG_YM\t\t\t\t\t\t\t0x45\t//read only: data x[12:5] msb  Y-self-test#define\tMAG_ZL\t\t\t\t\t\t\t0x46\t//read only: data x[4:0]  lsb#define\tMAG_ZM\t\t\t\t\t\t\t0x47\t//read only: data x[12:5] msb  Z-self-test#define\tMAG_RHAL\t\t\t\t\t\t0x48#define\tMAG_RHAM\t\t\t\t\t\t0x49#define MAG_ret\t\t\t\t\t\t\t0x4b\t//1000 0001b bring the device into sleep mode, 操作完成后，自动变为00#define MAG_OPC\t\t\t\t\t\t\t0x4Cvoid IMU_Init(void);void BMX055_Init_Accelerometer();void BMX055_Init_Gyroscope();void BMX055_Init_Magnetometer();void BMX055_Read_Accelerometer(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_Gyroscope(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_Magnetometer(int16_t *x, int16_t *y, int16_t *z);void BMX055_Read_All();void BMX055_Read_Chip_Id();#endif\n\n\n\n然后就可以通过stm32f407与bmx055进行iic通讯了\n先试试chip id能不能读出来，能读出来再去读取其他的数据\n用到芯片的模块如果实在不会接线或者希望更快的使用这个芯片，可以找找有用到这个芯片的模块\n例如下面这个模块\n\n可以直接参考这个模块的接线方式进行\n然后先把程序在这个模块上跑跑能不能成功运行\n可以的话再在自己接好线的芯片上试试\n","categories":["学习"],"tags":["硬件","stm32f407"]},{"title":"C语言知识点总结","url":"/2024/11/17/C/","content":"这是我主持的OurEDA的例会内容整理点击 下载 本次沙龙 PPT\n变量常用变量表（看看就好有个印象就行）\n\n\n类型\n含义\n32位编译器中大小(一般)\n64位编译器中大小(一般)\n最小值(32位)\n最大值(32位)\n\n\n\nbool\n布尔类型\n1byte\n1byte\nfalse\ntrue\n\n\nchar\n单个字符\n1byte\n1byte\n-2^7^\n2^7^-1\n\n\nshort\n短整形\n2byte\n2byte\n-2^15^\n2^15^-1\n\n\nint\n整形\n4byte\n4byte\n-2^31^\n2^31^-1\n\n\nlong\n长整形\n4byte4byte\n8byte\n-2^31^\n2^31^-1\n\n\nlong long\n长整形\n8byte\n8byte\n-2^63^\n2^63^-1\n\n\nfloat\n单精度浮点数\n4byte\n4byte\n-2^127^\n2^128^\n\n\ndouble\n双精度浮点数\n8byte\n8byte\n-2^1023^\n2^1024^\n\n\nlong double\n扩展精度浮点数\n12byte\n16byte\n-2^16383^\n2^16384^\n\n\nchar*\n字符常量或字符串常量\n4byte\n8byte\n无意义\n无意义\n\n\n\n\n\n类型\n有效位数计算\n有效位数\n\n\n\nfloat\n223+1&#x3D;16,777,216\n8-1&#x3D;7\n\n\ndouble\n252+1&#x3D;9,007,199,254,740,992‬\n16-1&#x3D;15\n\n\nlong double\n280+1&#x3D;2.410 24 &#x2F; 2112+1&#x3D;1.0381034\n25-1&#x3D;24 &#x2F; 35-1&#x3D;34\n\n\n一些注意事项\n\n数字默认是 double\n字符串默认是const char*\n\n特殊前缀extern int a;  // 声明一个int类型的变量a，一般用在.h文件中声明项目全局变量const int b=1;  // 定义一个不可变的变量b，使用const关键字都要赋初值static int c=1;  // 在函数中使用，只在第一次使用时初始化，相当于作用域在函数内的全局变量typedef long long int;  // 把long long当作int使用\n\n变量作用域\n局部变量\n\n全局变量\n\n\n字符串字符串在c语言中有两种形式char*和char[]，这里简单分辨下两者之间的不同。\n“HelloWorld!”是字符串常量，不可修改。\n\nchar* c1&#x3D;”HelloWorld!”中，c1指向代码段中的常量，只读不写，且常量相同，指向的地址也相同。\nchar c2[]&#x3D;”HelloWorld!”中，c2指向堆栈段中的数据，可读可写，相当于把代码端的数据拷贝了出来。\n\n结构体结构体可以看作是一种几个基础类型复合的类型。\n语句条件语句\nif - else - if else\nif依据后面的条件语句的结果进行判断，非0为真，0为假\nif会优先和近的else组合\nif()    //...else if()    //...else    //...\n\n\n\nif()    //...if()    //...else    //...\n\n\n\nswitch - case - default\n注意：每种情况下都要有break，否则将会持续执行。\nswitch(ch)&#123;  \tcase &#x27;a&#x27;:\t\t//...\t\tbreak;\tcase &#x27;b&#x27;:\t\t//...\t\tbreak;\tdefault:\t\t//...&#125;\n\n循环语句\nwhile\n先判断，再执行\nwhile 依据后面语句的结果进行判断，非0为真，0为假\n\ndo while（见得较少）\n不判断，先执行一次\n\nfor\n先判断，再执行\n适用于控制执行的次数\n\n\n跳转语句\nbreak\n跳出当前语句（{}）\n\ncontinue\n在 条件语句 中表示什么都不做（替代空语句）；\n在 迭代语句 中表示 直接进入下一轮循环，不执行完当前循环 。\n\ngoto（非常非常不建议，不过学的时候可以试着玩一下）\ngoto任意位置\nfor (int i=0; i&lt;n; i++) &#123;\tfor (int j=0; j&lt;m; j++) &#123;\t\tfor (int k=0; k&lt;o; k++) &#123;\t\t\tif (跳出条件) &#123;\t\t\t\tgoto end;\t\t\t&#125;\t\t&#125;\t&#125;&#125;end://...\n\n函数\n函数结果\n返回类型 函数名（形式传入参数）\n{\n​    函数体;\n​    return ()；\n}\n\nreturn 在 dfs 等算法中用于回溯\n\n内联函数 inline\n提高程序执行效率（整体代换而不是用函数调用)\ninline char *dbtest(int a)&#123;    return (a % 2 &gt; 0 ? &quot;奇&quot; : &quot;偶&quot;);&#125;\n\n指针\n\n\n\n\n&amp;\n\n常量指针（不能修改指针指向地址中的值）\n\n指针常量（不能修改指针的值）\n\n常量指针常量（既不能修改指针指向地址中的值，又不能修改指针的值）\n\n结构体指针变量（ . &#x2F; -&gt; ）\n\n数组与指针\n数组的变量名就是该数组的首地址\n数组的下标就是地址的位移量\n\n\nscanf 与 printf\nscanf(“输入格式”，变量地址);\nprintf(“输出格式”，变量);\n\n","categories":["学习"],"tags":["C语言","知识总结"]},{"title":"Debian 常用命令","url":"/2025/01/19/Debian%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"Debian 常用命令汇总以下是 Debian 系统（包括 Raspberry Pi OS 等基于 Debian 的发行版）中一些常用命令的总结，涵盖了文件操作、系统管理、网络配置等方面：\n文件与目录操作\n列出目录内容：\nlsls -l  # 详细列表ls -a  # 显示隐藏文件\n\n切换目录：\ncd &lt;目录路径&gt;cd ..  # 返回上一级目录cd ~   # 返回用户主目录\n\n创建目录：\nmkdir &lt;目录名&gt;mkdir -p &lt;路径/目录名&gt;  # 递归创建目录\n\n删除文件或目录：\nrm &lt;文件名&gt;  # 删除文件rm -r &lt;目录名&gt;  # 递归删除目录rm -f &lt;文件名&gt;  # 强制删除\n\n复制文件或目录：\ncp &lt;源文件&gt; &lt;目标文件&gt;cp -r &lt;源目录&gt; &lt;目标目录&gt;  # 递归复制目录\n\n移动或重命名文件：\nmv &lt;源文件&gt; &lt;目标文件&gt;\n\n查看文件内容：\ncat &lt;文件名&gt;less &lt;文件名&gt;  # 分页查看head &lt;文件名&gt;  # 查看文件开头tail &lt;文件名&gt;  # 查看文件末尾tail -f &lt;文件名&gt;  # 实时查看文件更新\n\n查找文件：\nfind &lt;目录&gt; -name &lt;文件名&gt;\n\n压缩与解压：\ntar -czvf &lt;压缩文件名.tar.gz&gt; &lt;目录&gt;  # 压缩tar -xzvf &lt;压缩文件名.tar.gz&gt;  # 解压\n\n系统信息与管理\n查看系统信息：\nuname -a  # 查看内核信息cat /etc/os-release  # 查看系统版本\n\n查看磁盘空间：\ndf -h  # 查看磁盘使用情况du -sh &lt;目录&gt;  # 查看目录大小\n\n查看内存与 CPU 使用：\nfree -h  # 查看内存使用top  # 实时查看系统资源占用\n\n查看进程：\nps aux  # 查看所有进程ps aux | grep &lt;进程名&gt;  # 查找特定进程\n\n杀死进程：\nkill &lt;进程ID&gt;kill -9 &lt;进程ID&gt;  # 强制杀死进程\n\n关机与重启：\nsudo shutdown now  # 立即关机sudo reboot  # 重启\n\n查看系统日志：\njournalctl  # 查看系统日志journalctl -f  # 实时查看日志\n\n包管理​\t使用 APT（Advanced Package Tool）作为包管理工具\n\n更新包列表：\nsudo apt update\n\n安装软件包：\nsudo apt install &lt;软件包名&gt;\n\n卸载软件包：\nsudo apt remove &lt;软件包名&gt;sudo apt purge &lt;软件包名&gt;  # 同时删除配置文件\n\n升级已安装的软件包：\nsudo apt upgrade\n\n搜索软件包：\napt search &lt;关键字&gt;\n\n清理缓存：\nsudo apt clean  # 清理所有缓存sudo apt autoremove  # 删除不需要的依赖\n\n用户与权限管理\n切换用户：\nsu &lt;用户名&gt;  # 切换用户sudo -i  # 切换到 root 用户\n\n添加用户：\nsudo adduser &lt;用户名&gt;\n\n删除用户：\nsudo deluser &lt;用户名&gt;\n\n修改文件权限：\nchmod &lt;权限&gt; &lt;文件名&gt;  # 修改权限chmod 755 &lt;文件名&gt;  # 示例：设置可执行权限\n\n修改文件所有者：\nsudo chown &lt;用户&gt;:&lt;组&gt; &lt;文件名&gt;\n\n网络管理\n查看网络接口：\nifconfig  # 查看网络接口信息ip addr  # 查看 IP 地址\n\n测试网络连接：\nping &lt;目标地址&gt;\n\n查看网络状态：\nnetstat -tuln  # 查看端口监听状态ss -tuln  # 更现代的替代工具\n\n下载文件：\nwget &lt;URL&gt;curl -O &lt;URL&gt;\n\n配置网络：\n\n编辑网络配置文件：sudo nano /etc/network/interfaces\n重启网络服务：sudo systemctl restart networking\n\n\n\n服务管理\n启动服务：\nsudo systemctl start &lt;服务名&gt;\n\n停止服务：\nsudo systemctl stop &lt;服务名&gt;\n\n重启服务：\nsudo systemctl restart &lt;服务名&gt;\n\n查看服务状态：\nsudo systemctl status &lt;服务名&gt;\n\n启用开机自启动：\nsudo systemctl enable &lt;服务名&gt;\n\n禁用开机自启动：\nsudo systemctl disable &lt;服务名&gt;\n\n其他常用命令\n查看命令帮助：\nman &lt;命令&gt;  # 查看手册&lt;命令&gt; --help  # 查看简要帮助\n\n查看环境变量：\necho $PATH\n\n设置别名：\nalias ll=&#x27;ls -l&#x27;  # 设置别名unalias ll  # 取消别名\n\n定时任务：\n\n编辑定时任务：crontab -e\n查看定时任务：crontab -l\n\n\n\n","categories":["学习"],"tags":["知识总结","Linux","Debian"]},{"title":"对内容进行了一些完善","url":"/2024/10/05/add-something-new/","content":"\n\n\n因为闲着所以试一些有意思的小玩意儿,不知道有没有人看得到哈哈哈哈哈哈 \n首先就是使用了隐藏文本\n以后可以说一些悄悄话了（）\n新增了跳转链接尝试与 Rhodes Island™ 取得弱神经连接：\n\n        \n        Rhodes Island™'与  Rhodes  Island™  取得弱神经连接'\n\n想添加自己的链接可以联系我\n新增了音乐播放器放一首我听得最多的\n&nbsp;\n\n思绪绵绵呀\n新增了一只噬元兽没错，就是左下角这一只（不知道你们有没有看到，毕竟隐身了）\n在添加的过程中看到有个博客有罗小黑的桌宠，本来打算也添加一个的，但是忘记收藏，导致现在找不到那个博客了。后来我也在B站上找到了lpk文件，尝试了一上午加半个下午，仍然不知道怎么添加，只能作罢。。（如果有谁看到那个用了罗小黑的博客或者知道怎么在web上使用lpk文件，请联系我，不胜感激）\n新增了本站运行时间在右下角哟\n特意把时间设置成北京时间，可以当作时钟（我多贴心）\n\n新增了点击特效就用《起风了》的歌词吧 不要问我为什么，多听几遍就知道了\n希望你们喜欢\n点下去的时候是烟花，松开的时候是歌词，有个时间差更容易看见歌词（可以等烟花散了再松开）\n\n新增了彩色滚动字体  \n    \n  \n    var binft = function (r) {\n      function t() {\n        return b[Math.floor(Math.random() * b.length)]\n      }  \n      function e() {\n        return String.fromCharCode(94 * Math.random() + 33)\n      }\n      function n(r) {\n        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {\n          var l = document.createElement(\"span\");\n          l.textContent = e(), l.style.color = t(), n.appendChild(l)\n        }\n        return n\n      }\n      function i() {\n        var t = o[c.skillI];\n        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)\n      }\n      var l = \"\",\n      o = [\"这一路上走走停停\",\"顺着少年漂流的痕迹\",\"迈出车站的前一刻\",\"竟有些犹豫\",\"不禁笑这近乡情怯\",\"仍无法避免\",\"而长野的天\",\"依旧那么暖\",\"风吹起了从前\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不得真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"逆着光行走 任风吹雨打\",\"短短的路走走停停\",\"也有了几分的距离\",\"不知抚摸的是故事\",\"还是段心情\",\"也许期待的不过是\",\"与时间为敌\",\"再次见到你\",\"微凉晨光里\",\"笑得很甜蜜\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不做真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"晚风吹起你鬓间的白发\",\"抚平回忆留下的疤\",\"你的眼中 明暗交杂 一笑生花\",\"暮色遮住你蹒跚的步伐\",\"走进床头藏起的画\",\"画中的你 低着头说话\",\"我仍感叹于世界之大\",\"也沉醉于儿时情话\",\"不剩真假 不做挣扎 无谓笑话\",\"我终将青春还给了她\",\"连同指尖弹出的盛夏\",\"心之所动 就随风去了\",\"以爱之名 你还愿意吗\"].map(function (r) {\n      return r + \"\"\n      }),\n      a = 15,//文字保留时间\n      g = 1,//文字出现速度 越大越慢\n      s = 4,//乱码长度\n      d = 50,//单个乱码展示时间\n      b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n      c = {\n        text: \"\",\n        prefixP: -s,\n        skillI: 0,\n        skillP: 0,\n        direction: \"forward\",\n        delay: a,\n        step: g\n      };\n      i()\n      };\n      binft(document.getElementById('binft'));\n   \n\n\n\n\n本来彩色滚动字体会导致下面的界面发生跳动，在外面套上div后修好了\n\n改进了折叠文本\n        \n            \n            \n            明日方舟语录\n\n        \n        是棋子，那就吃掉；是堡垒，那就攻陷；是王权，那就推翻。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——《明日方舟》觉得很霸气所以选这一句\n\n        \n\n\n\n\n杂记\n昨天成功捕捉噬元兽，带着她去看了尾巴的伤口并顺带做了绝育\n\n \n\n\n\n伤的挺严重的，已经感染了，幸好及时送到医院\n\n \n\n\n最后再附上几张 令 的图作为结束吧\n\n\n\n\n\n令 还是挺帅的\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"IntelliJ 全家桶和付费插件 最新破解","url":"/2025/05/23/IntelliJ%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%92%8C%E4%BB%98%E8%B4%B9%E6%8F%92%E4%BB%B6%20%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3/","content":"IntelliJ 全家桶和付费插件 最新破解使用方法:\n去官网安装对应的软件\n\n下载破解工具\n\n进入 ja-netfilter-all\\scripts 文件夹\n\n自动激活  macOS 或 Linux: \t执行 “scripts&#x2F;install.sh”  Windows:\n\n\n\n双击执行 “scripts\\install-current-user.vbs” (当前用户)\n\n双击执行 “scripts\\install-all-users.vbs” (对所有用户)\n\n\n\n如果仍然提示输入激活码，进入 https://3.jetbra.in 复制最新激活码\n\n如果还是不行，则先依次执行”scripts\\uninstall-current-user.vbs”、”scripts\\uninstall-all-users.vbs”再再次依次执行”scripts\\install-current-user.vbs”、”scripts\\install-all-users.vbs”，在done后输入激活码即可，若还不行可以在安装后重启电脑后试试激活码\n\n\n","categories":["学习"],"tags":["资料","破解"]},{"title":"算法题的错题整理及反思","url":"/2024/10/27/algorithm/","content":"这是关于算法题的整理及思考题目来源不一定，主要来源应该是CF、洛谷等\n也会包含一些关于比赛的反思等\n水平较低哈哈哈哈哈哈哈哈哈，还在尝试中\n\nCodeforces Round 982 (Div. 2) B标签：\n\n\n暴力枚举（brute force）\n贪心（greedy）\n\n\n题目：\n\n\nProblem-B-Codeforces\nStalin Sort-洛谷\n\n\n题目大意\n\n给出一个数组，问是否可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的。\n*子数组指的是任意一段连续子数组，斯大林排序指将严格降序的元素剔除，具体定义见题目\n\n思路分析：\n\n通过斯大林排序的定义可知\n\n任何一段数组进行斯大林排序后第一个元素都不会改变\n\n如果处理完的数组元素大于等于两个，则按非降序排列\n\n\n进一步分析\n\n对于使用斯大林排序的任意子数组，如果存在大于第一个元素的其他元素则会被保留，而小于第一个元素的一定会被剔除因此要使最后是非降序的，就必须要把子数组中大于第一个元素的其他元素都剔除掉\n那么要使剔除后的数组是可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的就要使剔除后的数组的首元素最大\n接下来只需要从头遍历整个数组，找到有最多元素的满足首元素最大的数组（不一定连续）即可\n即对数组中的每个元素寻找有多少个（k）在他之后的不大于他的元素，并记录下最大值（f）\n将元素总个数减去（最大值+1）就是其他要剔除的元素的个数\n\n\n\n        \n            \n            \n            可能的疑问\n\n        \n        \n问题一：对每个元素只考虑后面的其他元素，为什么不用考虑前面的其他元素就把他们全部剔除\n答：\n\n如果前面的元素大于等于该元素，则前面元素遍历时的值k1就会大于该值k2，那么f就会等于k1，不影响\n如果前面的元素小于该元素，则必须剔除，否则剔除后的数组的首元素就不是最大的，那么就不满足要求\n\n\n\n        \n\n思路误区：\n\n比赛时想的是减序列通过斯大林排序一定会消失，所以先对整个数组进行一次斯大林排序，得到非减序列，再把第一次出现的最大值前的元素全部剔除掉，那么剩下的就是非增序列了，问题在于在第一次通过斯大林排序时删掉的元素仍在剔除元素后的数组之中，此时数组还可能存在递增序列，不满足题意很烦的是样例给的随便过，比赛时一直没找到问题所在\n\n代码：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    int t;    cin &gt;&gt; t; // 读取测试用例数量      while (t--)    {        int n;        cin &gt;&gt; n;        int* a = new int[n + 1];        for (int i = 0; i &lt; n; i++)        {            cin &gt;&gt; a[i];        }        int f = 0;        for (int i = 0; i &lt; n - 1; i++)        {            int k = 0;            for (int j = i + 1; j &lt; n; j++)            {                if (a[j] &lt;= a[i])                    k++;            }            f = max(f, k);        }        cout &lt;&lt; n - (f + 1) &lt;&lt; endl;        delete[] a;    }    return 0;}\n\nEducational Codeforces Round 115 (Rated for Div. 2) C标签：\n\n\n暴力\n\n\n题目：\n\n\nProblem - C - Codeforces\n\n\n题目大意\n\n从数组中删掉两个数使得数学平均值不变，问一共有多少组\n\n思路分析：\n\nFirst of all, instead of the mathematic mean, let’s consider the sum of elements. If the mathematic mean is , then the sum of elements of the array is . Let’s denote the sum of elements in the original array as . Note  is always an integer.\nIf we remove two elements from the array, the resulting sum of elements should become . So, the sum of the elements we remove should be exactly .\nIf  is not an integer, the answer is  (to check that, you can simply compare  with ). Otherwise, we have to find the number of pairs  such that  and . This is a well-known problem.\nTo solve it, you can calculate the number of occurrences of each element and store it in some associative data structure (for example, map in C++). Let  be the number of occurrences of element . Then, you should iterate on the element  you want to remove and check how many elements match it, that is, how many elements give exactly  if you add  to them. The number of these elements is just . Let’s sum up all these values for every element in the array.\nUnfortunately, this sum is not the answer yet. We need to take care of two things:\n\nif for some index , , then  matches itself, so you have to subtract the number of such elements from the answer;\nevery pair of elements is counted twice: the first time when we consider the first element of the pair, and the second time — when we consider the second element of the pair. So, don’t forget to divide the answer by .\n\n\n代码：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() {  int t;  scanf(\"%d\", &amp;t);  while (t--) {    int n;    scanf(\"%d\", &amp;n);    vector&lt;int&gt; a(n);    map&lt;int, int&gt; cnt;    for (auto &amp;x : a) {      scanf(\"%d\", &amp;x);      cnt[x] += 1;    }    long long sum = accumulate(a.begin(), a.end(), 0LL);    if ((2 * sum) % n != 0) {      puts(\"0\");      continue;    }    long long need = (2 * sum) / n;    long long ans = 0;    for (int i = 0; i &lt; n; ++i) {      int a1 = a[i];      int a2 = need - a1;      if (cnt.count(a2)) ans += cnt[a2];      if (a1 == a2) ans -= 1;    }    printf(\"%lld\\n\", ans / 2);  }}\n\nP9236 [蓝桥杯 2023 省 A] 异或和之和标签：\n\n\n前缀和\n位运算\n\n\n题目：\n\nP9236 蓝桥杯 2023 省 A 异或和之和\n\n题目大意\n\n给定一个数组 ，分别求其每个子段的异或和，并求出它们的和。或者说，对于每组满足 1≤L≤R≤n 的 L,R，求出数组中第 L 至第 R 个元素的异或和。然后输出每组 L,R 得到的结果加起来的值。\n\n思路分析：\n\n首先考虑使用暴力求解，穷举L、R的所有组合，此时时间复杂度为  ，对每种情况从L到R求异或和，则此时时间复杂度为  ，能过30%的数据。\n继续优化，使用前缀异或和，因为每个数和自己的异或和都是0，每个数和零的异或和都是它本身，因此求L到R的异或和就是求 1到L-1的异或和 和 1到R的异或和 的异或和，这样在输入每个数时就能一边输入一边求出前缀异或和并存在数组中。求L到R的异或和只需要将前缀和  与前缀和 求异或和即可。时间复杂度是  ，能够60%的数据。\n继续优化，可以发现前缀和  与前缀和 的异或和的第  （从0开始）位为1时才对结果有贡献  ，而所有L和R的组合恰好是把所有前缀和两两求异或和再求和，因此，我们可以统计出所有前缀和的第  位的1的个数  和0的个数  ，只有第  位是1和0搭配时异或和的第  （从0开始）位才为1，则根据乘法原理一共在第  位的贡献是  ，又因为，因此结果为：，时间复杂度为 ，可以通过该题。具体实现可以对于每一个  前缀和，我们将其按位拆分，并将结果加入计数数组  中。其中 i 表示第 i 个二进制位，j 表示这一位上为 j（只能为 0 或 1）， 表示在所有数中，第 i 个二进制位上为 j 的有 个。\n\n代码：\n#include &lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; #include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int main(){\tint n;\tlong long sum=0;\tlong long flag=0;\tlong long A;\tlong long w[25][3]={0}; \tcin&gt;&gt;n;\tlong long *mem=new long long [n+1];\tmem[0]=0;\tfor(int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;A;\t\tmem[i]=mem[i-1]^A;\t}\tfor(int i=0;i&lt;=n;i++)\t{\t\tfor(int j=0;j&lt;=20;j++)\t\t{\t\t\tw[j][mem[i]&gt;&gt;j&amp;1]++;\t\t}\t}\tfor(int i=0;i&lt;=20;i++)\t\tsum+=w[i][0]*w[i][1]*pow(2,i);\tcout&lt;&lt;sum&lt;&lt;endl;\treturn 0;} \n\nP8773 [蓝桥杯 2022 省 A] 选数异或标签：\n\n\n线段树\nST表\n\n\n题目：\n\n蓝桥杯 2022 省 A] 选数异或\n\n题目大意\n\n给定一个长度为  的数列  和一个非负整数 , 给定  次查询, 每次询问能否从某个区间  中选择两个数使得他们的异或等于  。\n\n思路分析：\n\n因为提前给出了，而要^=，则可以根据得出=^，因此可以在输入时就对其进行预处理。我们可以用map记录某个元素最后出现的位置，然后对每一个输入的 我们可以找到其之前的与其异或后为的最后一个元素的位置，记作=^，且可知&lt;并且若不存在则，那么要使区间  中有两个数使得他们的异或等于  ，只需使得该区间内有一个元素的在该区间内即可，即只需要的最大值大于等于即可。我们可以设为  中的最大值，那么只需&gt;=，就能保证在区间  中有至少有两个数使得他们的异或等于 。同时在具体实现上我们可以用在输入数据时就进行预处理。\n\n代码：\n#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; #include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;int main(){\tint n,m,x;\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;x;\tmap&lt;int,int&gt; a;\tint A;\tint *f=new int[n+1];\tfor(int i=0;i&lt;=n;i++)\t{\t\tf[i]=0; \t}\tfor(int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;A;\t\tf[i]=max(f[i-1],a[A^x]);\t\ta[A]=i;\t}\tfor(int j=0;j&lt;m;j++)\t{\t\tint l,r;\t\tcin&gt;&gt;l&gt;&gt;r;\t\tif(f[r]&gt;=l)\t\t\tcout&lt;&lt;\"yes\"&lt;&lt;endl;\t\telse\t\t\tcout&lt;&lt;\"no\"&lt;&lt;endl;\t}\treturn 0;} \n\n附记突然发现我都是三分钟热度，隔一段时间就换不同的事做，兜兜转转的，一会做算法，一会做嵌入式，一会做前端，循环往复，结果每件事都做得一般哈哈哈哈哈（看来我是分时操作系统），性格好像也是，有时候很社牛，有时候又很社恐，还是太在意他人的看法吗哈哈哈哈，反正也没什么人会看，就在这底下蛮写这一段话吧，算是对这一段时间的总结，接下来要维持这种样子吗？还是做一些改变？还没想好，但是现在这样也挺舒服的，隔一段时间做一件事不会腻，也算是保持新鲜感的一种方法吧。就先写到这吧（2025.4.9）\n\n","categories":["学习"],"tags":["算法","错题整理"]},{"title":"Linux 常用命令","url":"/2024/11/19/Linux/","content":"Linux 常用命令汇总基本命令关机和重启\n关机：\nshutdown ‐h now          #立刻关机 shutdown ‐h 5         #5分钟后关机 poweroff            #立刻关机 \n\n重启\nshutdown ‐r now          #立刻重启 shutdown ‐r 5         #5分钟后重启 reboot              #立刻重启 \n\n帮助命令\n帮助\nshutdown –help          #查看关机命令帮助信息 ifconfig    ‐‐help          #查看网卡信息 man              #（命令说明书） man shutdown \n\n注意：man shutdown 打开命令说明书之后，使用按键 q 退出 \n\n目录操作命令目录切换命令\ncd\ncd /              #切换到根目录 cd /usr              #切换到根目录下的 usr 目录 cd ../              #切换到上一级目录  或者    cd .. cd ~              #切换到 home 目录 cd ‐              #切换到上次访问的目录 \n\n\n目录查看命令\nls\nLs            #查看当前目录下的所有目录和文件 ls ‐a          #查看当前目录下的所有目录和文件（包括隐藏的文件） ls ‐l  或  ll        #列表查看当前目录下的所有目录和文件（显示更多信息） ls /dir          #查看指定目录下的所有目录和文件      如：ls /usr \n\n目录操作命令创建目录\nmkdir\nmkdir        aaa     #  在当前目录下创建一个名为 aaa 的目录 mkdir        /usr/aaa    #  在指定目录下创建一个名为 aaa 的目录 \n\n删除目录或文件\nrm\nrm  文件        #删除当前目录下的文件 rm ‐f  文件          #删除当前目录的的文件（不询问） #删除目录： rm ‐r aaa          #递归删除当前目录下的 aaa 目录 rm ‐rf aaa          #递归删除当前目录下的 aaa 目录（不询问） #全部删除： rm ‐rf *            #将当前目录下的所有目录和文件全部删除 rm ‐rf /*         #【慎用！】将根目录下的所有文件全部删除 \n\n注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删 除任何目录或文件，都直接使用 rm ‐rf 目录&#x2F;文件&#x2F;压缩包 \n\n目录修改\n重命名目录\n命令：mv 当前目录 新目录 示例：mv aaa bbb    #将目录 aaa 改为 bbb    \n\n注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作。 \n\n\n剪切目录     \n命令：mv 目录名称 目录的新位置示例：mv /usr/tmp/aaa /usr  #将/usr/tmp 目录下的 aaa 目录剪切到 /usr 目录下面   \n\n注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。\n\n\n拷贝目录\n&gt;命令：cp ‐r  目录名称  目录拷贝的目标位置      ‐r 代表递归 &gt;示例：cp /usr/tmp/aaa    /usr   #将/usr/tmp 目录下的 aaa 目录复制到  /usr 目录下面 \n\n注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用 写‐r 递归。 \n\n目录检索\n命令：find  目录  参数  文件名称 示例：find /usr/tmp ‐name &#x27;a*&#x27;        #查找/usr/tmp 目录下的所有以 a 开头的目录或文件\n\n文件操作命令新建文件\n命令：touch  文件名 示例：touch    aa.txt      #在当前目录创建一个名为 aa.txt 的文件 \n\n删除文件\n命令：rm ‐rf  文件名 \n\n修改文件\n打开文件\nvi  文件名 示例：vi aa.txt  或者  vim aa.txt      #打开当前目录下的 aa.txt 文件 \n\n若文件不存在则新建文件并打开 \n注意：使用 vi 编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘 i&#x2F;a&#x2F;o 进入 编辑模式。 \n\n编辑文件\n使用 vi 编辑器打开文件后点击按键：i ，a 或者 o 即可进入编辑模式。\ni：在光标所在字符前开始插入\na：在光标所在字符后开始插入 \no：在光标所在行的下面另起一新行插入\n\n保存文件\n第一步：ESC  进入命令行模式 \n第二步：：进入底行模式 \n第三步：wq!  #保存并退出编辑 \n\n取消编辑\n第一步：ESC  进入命令行模式 \n第二步：：进入底行模式 \n第三步：q!   #撤销本次修改并退出编辑\n\n\n\n查看文件\n文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail \ncat：看最后一屏 示例：使用 cat 查看/etc/sudo.conf 文件，只能显示最后一屏内容。 cat sudo.conf \n\nmore：百分比显示 示例：使用 more 查看/etc/sudo.conf 文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q 可以退出查看 more sudo.conf \n\nless：翻页查看 示例：使用 less 查看/etc/sudo.conf 文件，可以使用键盘上的 PgUp 和 PgDn 向上和向下翻页，q 结束查看 less sudo.conf \n\ntail：指定行数或者动态查看 示例：使用 tail ‐10  查看/etc/sudo.conf 文件的后 10 行，Ctrl+C 结束     tail ‐10 sudo.conf \n\n","categories":["学习"],"tags":["知识总结","Linux"]},{"title":"新增AI功能","url":"/2025/06/22/ai/","content":"现在可以通过左边栏的AI模块进入，访问本博客专属的AI喵~\n目前还有些许问题等待解决\n\n增加公式的在线渲染\n增加AI对本博客的内容总结以及导航\n增加AI的联网功能\n增加访客自定义的角色\n增加图像等文件的上传\n增加流式输出\n增加更强的保护措施\n\n本AI所有聊天记录都是访客的本地保存，刷新后即清空消失，不会上传或存储到任何其他地方，我看不到任何访客的聊天记录，特此声明，可以放心使用。\n","categories":["学习"],"tags":["AI"]},{"title":"感谢大家","url":"/2024/10/02/thx/","content":"\n感谢我身边的大家，本博客的搭建离不开大家的建议和帮助。\n\n\n特此鸣谢\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"杂谈","url":"/2024/02/09/my-first-blog/","content":"这是我的第一个博客嘿嘿嘿\n\n\n这是我的第一个 Blog\n但是我不知道写什么哈哈哈哈哈\n\n\n目前还在测试中\n\n\n如果你感觉无聊你可以看看B站 \n\n关于后续后续我将会发布有关于IT技术、生活等方面的内容，不过我觉得应该不会有什么人看的，所以水一水(雾)。\n关于为什么写博客有两个理由，一个是为了装*，另一个还是为了装*哈哈哈哈哈哈哈哈哈。\n\n好了，正经一点\n\n其实是因为看见大神学长写博客所以突发奇想，想给自己做一个博客(好像还是不是什么正经理由嘿嘿嘿)\n\n时间有点来不及了，还有挺多事要做的，所以先写到这儿吧，现在要发布了(希望能发布成功)\n附一张我最爱的小猪的照片：\n \n再附一张铃兰和罗小黑的动图：\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"复制黏贴出错原因分析","url":"/2024/11/20/copy_wrong/","content":"复制黏贴出错原因分析最近我在进行复制黏贴时出现了多次的错误\n一次是复制一个网址，黏贴看上去也没问题，但是就是跳转不到对应的网页，直到我将他在记事本中黏贴时才发现其变成了一堆乱码\n还有一次是我在网页上拷贝代码，将代码黏贴后看上去也没有任何问题，但就是运行时报错，每一行都报无法识别命令的错\n因此在此记录该问题，并简要分析复制黏贴出错原因\n推荐大家复制黏贴不行时试试自己输入，后续找到克服问题的方法会在此提出，或者尝试下列措施\n\n首先先分析一下为什么复制黏贴会出错\n复制粘贴内容出现不一致或变成乱码的原因可能与以下因素有关：\n1. 字符编码问题\n不同的软件或系统使用的字符编码方式可能不一致（例如 UTF-8、GB2312 等）。当粘贴的内容被另一个程序读取时，如果解码方式不一致，就会导致乱码。\n解决方法：确保复制和粘贴的两端使用相同的字符编码。如果是文档，保存为 UTF-8 通常兼容性较好。\n\n2. 格式问题\n复制的内容可能包含不可见的格式化信息（如字体、颜色、样式等），但目标软件不支持这些格式，可能导致显示异常或部分信息丢失。\n解决方法：尝试使用“纯文本”粘贴（通常是通过 Ctrl+Shift+V 或选择“仅粘贴文本”选项）。\n\n3. 源数据限制\n某些软件（如网页）可能会在复制时附加隐藏代码或广告内容，导致粘贴后出现意外结果。（真可恶）\n解决方法：先粘贴到一个纯文本编辑器（如记事本）中清除多余信息，然后再复制到目标位置。\n\n4. 语言和区域设置冲突\n如果系统的语言或区域设置与粘贴内容不匹配，可能会导致显示不正确。例如，中文文本在未启用中文支持的环境中可能会变成乱码。\n解决方法：检查系统的语言和区域设置，确保支持复制内容的语言。\n\n5. 特殊字符或符号\n某些特殊字符或符号可能在不同的软件或系统中显示效果不同，甚至可能直接变成乱码。\n解决方法：尽量避免使用过多特殊字符，或者确认目标软件是否支持这些字符。\n\n6. 跨平台兼容性问题\nWindows、macOS 和 Linux 之间在处理换行符、制表符等特殊格式时可能存在差异，导致粘贴内容变形。\n解决方法：在跨平台操作时，使用通用工具或格式化工具（如转换成纯文本）处理内容。\n\n7. 剪贴板问题\n剪贴板有时会因为数据量过大或软件冲突而无法正确复制和粘贴。\n解决方法：清空剪贴板后重新操作，或者使用专门的剪贴板管理工具（如 ClipClip）。\n\n8. 目标程序的限制\n某些程序在粘贴时会主动过滤内容或重构格式，导致粘贴结果不同。\n解决方法：尝试不同的粘贴方式，或者检查程序的粘贴选项设置。\n\n","categories":["学习"],"tags":["计算机问题"]},{"title":"基于Ubuntu编译内核并添加内核模块","url":"/2025/03/26/%E5%9F%BA%E4%BA%8EUbuntu%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","content":"本文详细记录在 Ubuntu 24.10 系统上编译 Linux 内核、创建最小化运行环境，并添加自定义内核模块的全过程。所有操作均在 VMware 虚拟机环境下验证通过。\n\n使用的系统镜像是 ubuntu-24.10-desktop-amd64.iso \n\n一、环境准备与内核编译首先第一步是在桌面创建一个文件夹，这里我就取名为 linux ，在 linux 文件夹中打开终端\n接着我们需要获取内核的源码，去 官网 https://kernel.org 下载最新的稳定版，这里我们就下载 stable:6.13.8 ，复制 tarball 的链接后，到前面在linux文件夹中打开的终端，输入：\n# 下载稳定版内核源码（以6.13.8为例）wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.13.8.tar.xz\n\n在下载完成之后我们需要对文件夹进行解压缩，输入：\n# 解压源码包tar -xf linux-6.13.8.tar.xz\n\n解压完成后进入该文件夹，输入：\n# 进入源码目录cd linux-6.13.8\n\n此时内核的源代码中已经有 Makefile ，因此可以直接 make \n这里我们使用默认配置，输入：\n# 生成默认配置（使用x86_64架构的默认配置）make defconfig\n\n接着就开始内核的编译，因为我的虚拟机就两核因此使用双线程，大家可以根据自己的配置进行调整，输入：\n# 开始编译内核（-j参数根据CPU核心数设置，双核示例）make -j 2\n\n接着就是漫长的等待，编译完成后会生成 arch/x86/boot/bzImage 内核文件\n二、最小化环境测试接着我们使用 QEMU 这个模拟器进行内核功能的测试，输入：\nqemu-system-x86_64 -kernel arch/x86/boot/bzImage\n\n但是只有内核本身是跑不起来的，此时我们要返回 linux 文件夹，并在 linux 文件夹内创建 shell 文件夹，然后在 shell 文件夹内创建 shell.c 文件，输入：\n# 返回工程目录并创建shell环境cd ..mkdir shellcd shell# 编写测试程序（使用vim或任意编辑器）vim shell.c\n\n接着可以编写一个简单的 c 程序试验一下，输入：\n/* 最小化交互程序 */#include&lt;stdio.h&gt;int main()&#123;    char a;    while(1)    &#123;        printf(&quot;Are you OK?&quot;);        scanf(&quot;%c&quot;,&amp;a);    &#125;    return 0;&#125;\n\n接着编译并运行，输入：\ngcc shell.c./a.out\n\n现在已经可以顺利运行该 shell.c 文件了，为了使编译生成的文件不被动态地链接到其他无关的库，则在编译时使用 -static ，输入：\n# 静态编译（避免动态链接依赖）gcc shell.c -static\n\n 接着将可运行文件重命名为 init ，这是 linux 内核默认搜索的一个文件名，输入：\nmv ./a.out init# 也可以在上一步直接 gcc shell.c -static -o init\n\n然后再将其打包成一个 cpio 格式的压缩包，输入：\n# 打包为initramfs（需包含名为init的可执行文件）echo &quot;init&quot; | cpio -H newc -o &gt; init.cpio\n\n在文件压缩成功之后再使用 qemu 尝试启动，输入：\n# 使用QEMU启动自定义内核qemu-system-x86_64 -kernel ../linux-6.13.8/arch/x86/boot/bzImage -initrd init.cpio\n\n运行后输出是：\n\n此时 QEMU 已成功启动自定义内核，编译内核至此已经完成了，接下来将是添加内核模块\n三、添加内核模块此时的目录结构应为：\n~/桌面/linux/├── linux-6.13.8/          ├── shell/                │   ├── init             │   ├── init.cpio        │   └── shell.c          \n\n接着开始编写内核模块，在 shell/ 目录下新建文件 hello.c，编写模块的源码：\n#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Your Name&quot;);MODULE_DESCRIPTION(&quot;A simple Linux kernel module&quot;);/* 模块加载函数 */static int __init hello_init(void) &#123;    printk(KERN_INFO &quot;Hello, Kernel Module loaded!\\n&quot;);  // 内核日志输出    return 0;&#125;/* 模块卸载函数 */static void __exit hello_exit(void) &#123;    printk(KERN_INFO &quot;Goodbye, Kernel Module unloaded.\\n&quot;);&#125;/* 注册模块入口/出口 */module_init(hello_init);  // 模块加载时调用 hello_initmodule_exit(hello_exit);  // 模块卸载时调用 hello_exit\n\n然后是编写模块的 Makefile ，在同一目录下创建 Makefile ：\n# 指定模块名称（需与源码文件名一致）obj-m := hello.o# 内核源码路径（根据实际位置修改）KDIR := ~/桌面/linux/linux-6.13.8  # 指向你的内核源码目录# 当前模块路径PWD := $(shell pwd)all:\tmake -C $(KDIR) M=$(PWD) modulesclean:\tmake -C $(KDIR) M=$(PWD) clean\n\n接着开始编译内核模块，进入shell/ 目录并编译，输入：\ncd ~/桌面/linux/shell# 执行编译（生成hello.ko内核模块）make\n\n此时若成功则会输出：\nmake -C ~/桌面/linux/linux-6.13.8 M=~/桌面/linux/shell modules  CC [M]  ~/桌面/linux/shell/hello.o  MODPOST 1 modules  CC      ~/桌面/linux/shell/hello.mod.o  LD [M]  ~/桌面/linux/shell/hello.ko\n\n检查模块信息，应包含许可证、作者等信息，输入：\n# 查看模块信息modinfo hello.ko\n\n四、集成与完整测试修改用户态 init 程序，更新 shell.c ，使其加载内核模块并交互：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123;    printf(&quot;=== My Minimal Shell ===\\n&quot;);        // 1. 加载内核模块    system(&quot;insmod /hello.ko&quot;);    printf(&quot;Kernel module loaded. Check dmesg.\\n&quot;);    // 2. 模拟用户交互    int input;    while (1) &#123;        printf(&quot;Enter &#x27;0&#x27; to exit: &quot;);        scanf(&quot;%d&quot;, &amp;input);        if (input == 0) break;    &#125;    // 3. 卸载模块    system(&quot;rmmod hello&quot;);    printf(&quot;Kernel module unloaded.\\n&quot;);    return 0;&#125;\n\n接着编译并打包新的 initramfs ，输入：\n# 静态编译gcc -static shell.c -o init  # 确保可执行chmod +x init               cd ~/桌面/linux/shell# 打包包含模块的initramfs（必须包含init和hello.ko）echo -e &quot;init\\nhello.ko&quot; | cpio -o -H newc &gt; init.cpio  \n\n最后是通过 QEMU 启动完整测试，输入：\n# 带控制台输出的启动方式qemu-system-x86_64 \\    -kernel ~/桌面/linux/linux-6.13.8/arch/x86/boot/bzImage \\    -initrd ~/桌面/linux/shell/init.cpio \\    -nographic -append &quot;console=ttyS0&quot;\n\n输出：\n=== My Minimal Shell ===Kernel module loaded. Check dmesg.Enter &#x27;0&#x27; to exit: \n\n输入 0 退出程序后，检查卸载日志，输入：\n# 过滤内核日志中的卸载信息dmesg | grep Goodbye\n\n输出：\nGoodbye, Kernel Module unloaded.\n\n运行后的输出是：\n\n通过以上步骤，即可完成从内核编译到模块开发的完整流程。\n但是目前仍存在部分小问题，等待后续学习修正。\n","categories":["学习"],"tags":["知识总结","操作系统"]},{"title":"C++ STL常用内容总结","url":"/2024/10/29/stl/","content":"说明这是关于C++ STL常用内容总结\n强调使用方法，并不强调原理\n本篇博客是我用于个人学习总结用的\n\n\n大部分内容来源于网络和书本，因为是个人整理复习用所以就先不加了，如果后期看的人多我会加上的\n因为还有挺多课的，而且还有比赛和组里的任务，所以可能会不定期不定量更新\n内容可能有不全的，或错误的，欢迎批评指正\n目录主要包含下面几个STL函数\n\n\nvector 动态数组\nstack 栈\nqueue 队列\ndeque 双端队列\npriority_queue 优先队列\nmap 映射\nset 集合\npair 二元组\nstring 字符串\nbitset\narray 数组\ntuple 元组\n……\n\n\n这是目前的安排，计划在11.03前赶完，因为11.03要比赛，11.10还要考离散，中间还要把几次练习赛的题补了。（好忙）\n补：比赛也算是拿了银奖了\n被高中生爆杀\n\n目前（11.02）已将上述STL函数整理完成，算是按时提前完成了吧\n后续会增加一些常用的STL函数，例如sort等\n暂定在12.20前完成后续的补充\n话不多说，接下来进入正题吧\nSTL函数总结vector 动态数组介绍vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。\n\n注意：在局部区域中（比如局部函数里面）开vector数组，是在 堆空间 里面开的。\n在局部区域开 数组 是在 栈空间 开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。\n故局部区域 不可以 开大长度数组，但是可以开大长度vector。\n\n\n头文件：\n#include &lt;vector&gt;\n\n一维初始化：\nvector&lt;int&gt; a; //定义了一个名为a的一维数组,数组存储int类型数据vector&lt;double&gt; b;//定义了一个名为b的一维数组，数组存储double类型数据vector&lt;node&gt; c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型\n\n指定长度和初始值的初始化\nvector&lt;int&gt; v(n);// 定义一个长度为n的数组，初始值默认为0，下标范围 [0, n - 1]vector&lt;int&gt; v(n, 1);//定义一个长度为n的数组，下标范围 [0, n - 1], v[0] 到 v[n - 1]所有的元素初始值均为1//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）\n\n初始化中有多个元素\nvector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//数组a中有五个元素，数组长度就为5\n\n拷贝初始化\nvector&lt;int&gt; a(n + 1, 0);vector&lt;int&gt; b(a); // 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组vector&lt;int&gt; c = a; // 也是拷贝初始化,c和a是完全一样的数组\n\n二维初始化\n//定义第一维固定长度为5，第二维可变化的二维数组vector&lt;int&gt; v[5];//定义可变长二维数组//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素//第一维固定长度为5，第二维长度可以改变\n\n\nvector&lt;int&gt; v[5]可以这样理解：长度为5的v数组，数组中存储的是vector&lt;int&gt; 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：\nv[1].push_back(2);//第二行尾部增加一个元素 2v[2].push_back(3);//第三行尾部增加一个元素 3\n\n\n行列均可变\n//初始化二维均可变长数组vector&lt;vector&lt;int&gt;&gt; v;//定义一个行和列均可变的二维数组\n\n\n应用：可以在v数组里面装多个数组\nvector&lt;int&gt; t1&#123;1, 2, 3, 4&#125;;vector&lt;int&gt; t2&#123;2, 3, 4, 5&#125;;v.push_back(t1);v.push_back(t2);v.push_back(&#123;3, 4, 5, 6&#125;) // &#123;3, 4, 5, 6&#125;可以作为vector的初始化,相当于一个无名vector\n\n\n行列长度均固定\n\nn + 1行  m + 1列  初始值为0\nvector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//定义一个长度为 n+1 的数组，下标范围 [0, n - 1], a[0] 到 a[n - 1]所有的元素初始值均为vector&lt;int&gt;(m + 1, 0)\n\n\nc++17及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）\nvector a&#123;1, 2, 3, 4, 5&#125;; // 声明一个int类型动态数组，初识元素自己指定vector a(n + 1, vector(m + 1, 0));\n\n方法函数个人认为vector和数组的差距首先是存储位置不一样，vector是在堆空间，数组是在栈空间，其次就是vector中有许多方法函数，这些方法函数可以极大的方便我们编程，解题，不仅仅vector是这样的，其他STL函数也是。但是因为我才刚刚入门，这只是我的一种感觉，具体怎么等我多学一些，学深一些再来补充。先占个坑。\n知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。\nc指定为数组名称，含义中会注明算法复杂度。\n\n\n\n代码\n含义\n\n\n\nc.front()\n返回第一个数据O ( 1 )\n\n\nc.back()\n返回数组中的最后一个数据 O ( 1 )\n\n\nc.pop_back()\n删除最后一个数据O ( 1 )\n\n\nc.push_back(element)\n在尾部加一个数据O ( 1 )\n\n\nc.size()\n返回实际数据个数（unsigned类型）O ( 1 )\n\n\nc.clear()\n清除元素个数O ( N )，N为元素个数\n\n\nc.resize(n, v)\n改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0\n\n\nc.insert(it, x)\n向任意迭代器it（通俗来说就是地址）插入一个元素x ，O ( N )\n\n\nc.erase(first,last)\n删除[first,last)的所有元素，O ( N )\n\n\nc.begin()\n返回首元素的迭代器（通俗来说就是地址）O ( 1 )\n\n\nc.end()\n返回最后一个元素后一个位置的迭代器（地址）O ( 1 )\n\n\nc.empty()\n判断是否为空，为空返回真，反之返回假 O ( 1 )\n\n\n\n注意：\n\nend()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此\n\n使用 vi.resize(n, v) 函数时，若 vi 之前指定过大小为 pre\n\npre &gt; n ：即数组大小变小了，数组会保存前 n 个元素，前 n 个元素值为原来的值，不都变为 v\npre &lt; n ：即数组大小变大了，数组会在后面插入 n - pre 个值为 v 的元素\n\n也就是说，这个初始值 v 只对新插入的元素生效。\n#include&lt;bits/stdc++.h&gt;using namespace std;void out(vector&lt;int&gt; &amp;a) &#123; for (auto &amp;x: a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;\\n&quot;; &#125;int main() &#123;\tvector&lt;int&gt; a(5, 1);\tout(a); // 1 1 1 1 1\ta.resize(10, 2);\tout(a); // 1 1 1 1 1 2 2 2 2 2\ta.resize(3, 3);\tout(a); // 1 1 1\treturn 0;&#125;\n\n\n排序\n使用sort排序要： sort(c.begin(), c.end());\n\nsort()为STL函数，请参考本文最后面STL函数系列。\n\n对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。\nvector&lt;int&gt; a(n + 1);sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序\n\n访问共三种方法：\n\n下标法 ： 和普通数组一样\n\n注意：一维数组的下标是从 0 到 v.size()-1 ，访问之外的数会出现越界错误\n\n迭代器法 ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置\n\n使用auto ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）\n\n\n下标访问直接和普通数组一样进行访问即可。\n//添加元素for(int i = 0; i &lt; 5; i++)\tvi.push_back(i);\t//下标访问 for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n迭代器访问类似指针，迭代器就是充当指针的作用。\nvector&lt;int&gt; vi&#123;1, 2, 3, 4, 5&#125;;//迭代器访问vector&lt;int&gt;::iterator it;   // 相当于声明了一个迭代器类型的变量it// 通俗来说就是声明了一个指针变量\n\n\n方法一\nvector&lt;int&gt;::iterator it = vi.begin(); for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n方法二\nvector&lt;int&gt;::iterator it;for(it = vi.begin(); it != vi.end();it ++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;//vi.end()指向尾元素地址的下一个地址// 或者auto it = vi.begin();while (it != vi.end()) &#123;    cout &lt;&lt; *it &lt;&lt; &quot;\\n&quot;;    it++;&#125;\n\n智能指针只能遍历完数组，如果要指定的内容进行遍历，需要另选方法。\nauto 能够自动识别并获取类型。\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;    cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// for (auto &amp;x: a)：这是一个范围for循环，用于遍历向量a中的每个元素。auto关键字自动推导变量x的类型，这里x的类型将是int&amp;（整数的引用），因为我们在循环中使用了引用&amp;。使用引用的好处是可以直接修改向量中的元素值。// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;\tcout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\n\n\nvector注意：\n\nvi[i] 和 *(vi.begin() + i) 等价，与指针类似。\nvector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。\n\n\nstack 栈介绍栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。\n\n头文件\n//头文件需要添加#include&lt;stack&gt;\n\n声明\n//声明stack&lt;int&gt; s;stack&lt;string&gt; s;stack&lt;node&gt; s;//node是结构体类型\n\n方法函数\n\n\n代码\n含义\n\n\n\ns.push(ele)\n元素ele入栈，增加元素 O ( 1 )\n\n\ns.pop()\n移除栈顶元素 O ( 1 )\n\n\ns.top()\n取得栈顶元素（但不删除）O ( 1 )\n\n\ns.empty()\n检测栈内是否为空，空为真 O ( 1 )\n\n\ns.size()\n返回栈内元素的个数 O ( 1 )\n\n\n栈遍历栈遍历栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中\nstack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) &#123;    int tp = st.top(); // 栈顶元素    st.pop();&#125;\n\n数组模拟栈进行遍历通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n特点： 比STL的stack速度更快，遍历元素方便\nint s[100]; // 栈 从左至右为栈底到栈顶int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1for(int i = 0; i &lt;= 5; ++i) &#123;\t//入栈 \ts[++tt] = i;&#125;// 出栈int top_element = s[tt--]; //入栈操作示意//  0  1  2  3  4  5  //                tt//出栈后示意//  0  1  2  3  4 //              tt\n\nqueue 队列介绍队列是一种先进先出的数据结构。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n定义初始化\n//定义初始化queue&lt;int&gt; q;\n\n方法函数\n\n\n代码\n含义\n\n\n\nq.front()\n返回队首元素 O ( 1 )\n\n\nq.back()\n返回队尾元素 O ( 1 )\n\n\nq.push(element)\n尾部添加一个元素element 进队O ( 1 )\n\n\nq.pop()\n删除第一个元素 出队 O ( 1 )\n\n\nq.size()\n返回队列中元素个数，返回值类型unsigned int O ( 1 )\n\n\nq.empty()\n判断是否为空，队列为空，返回true O ( 1 )\n\n\n队列模拟使用q[]数组模拟队列\nhh表示队首元素的下标，初始值为0\ntt表示队尾元素的下标，初始值为-1，表示刚开始队列为空\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int q[N];int main() &#123;\tint hh = 0,tt = -1;//\t入队 \tq[++tt] = 1;\tq[++tt] = 2; //\t将所有元素出队 \twhile(hh &lt;= tt) &#123;\t\tint t = q[hh++];\t\tprintf(&quot;%d &quot;,t);\t&#125;\treturn 0; &#125; \n\ndeque  双端队列介绍首尾都可插入和删除的队列为双端队列。\n\n头文件\n//添加头文件#include&lt;deque&gt;\n\n初始化定义\n//初始化定义deque&lt;int&gt; dq;\n\n方法函数\n注意双端队列的常数比较大。\n\n\n\n\n代码\n含义\n\n\n\npush_back(x)&#x2F;push_front(x)\n把x插入队尾后 &#x2F; 队首 O ( 1 )\n\n\nback()&#x2F;front()\n返回队尾 &#x2F; 队首元素 O ( 1 )\n\n\npop_back() &#x2F; pop_front()\n删除队尾 &#x2F; 队首元素 O ( 1 )\n\n\nerase(iterator it)\n删除双端队列中的某一个元素\n\n\nerase(iterator first,iterator last)\n删除双端队列中[first,last)中的元素\n\n\nempty()\n判断deque是否空 O ( 1 )\n\n\nsize()\n返回deque的元素数量 O ( 1 )\n\n\nclear()\n清空deque\n\n\n注意点deque可以进行排序\n\n双端队列排序一般不用，感觉毫无用处，使用其他STL依然可以实现相同功能\n\n//从小到大sort(q.begin(), q.end())//从大到小排序sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型sort(q.begin(), q.end(), greater());//高版本C++才可以用\n\npriority_queue 优先队列介绍优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。\n可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。\n它的底层是通过堆来实现的。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n初始化\n//初始化定义priority_queue&lt;int&gt; q;\n\n函数方法\n\n\n代码\n含义\n\n\n\nq.top()\n访问队首元素 O ( 1 )\n\n\nq.push()\n入队 O ( l o g N )\n\n\nq.pop()\n堆顶（队首）元素出队 O ( l o g N )\n\n\nq.size()\n队列元素个数 O ( 1 )\n\n\nq.empty()\n是否为空 O ( 1 )\n\n\n注意没有clear()！不提供该方法\n优先队列只能通过top()访问队首元素（优先级最高的元素）\n设置优先级基本数据类型的优先级priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小根堆, 每次取出的元素是队列中的最小值\n\n参数解释：\n\n第一个参数：就是优先队列中存储的数据类型\n\n第二个参数：\nvector&lt;int&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector&lt;double&gt;总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。\n\n第三个参数：\nless&lt;int&gt; 表示数字大的优先级大，堆顶为最大的数字greater&lt;int&gt;表示数字小的优先级大，堆顶为最小的数字int代表的是数据类型，也要填优先队列中存储的数据类型\n\n\n\n\n基础写法（非常常用）：\npriority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值\n\n自定义排序（不常见，主要是写着麻烦）：\n下面的代码比较长，基础类型优先级写着太麻烦，用基础写法即可。\nstruct cmp1 &#123;\tbool operator()(int x, int y) &#123;\t\treturn x &gt; y;\t&#125;&#125;;struct cmp2 &#123;\tbool operator()(const int x, const int y) &#123;\t\treturn x &lt; y;\t&#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆\n\n高级数据类型(结构体)优先级\n即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。\n\n优先级设置可以定义在结构体内进行小于号重载，也可以定义在结构体外。\n//要排序的结构体（存储在优先队列里面的）struct Point &#123;\tint x, y;&#125;;\n\n\n版本一：自定义全局比较规则\n//定义的比较结构体//注意：cmp是个结构体 struct cmp &#123;//自定义堆的排序规则 \tbool operator()(const Point&amp; a,const Point&amp; b) &#123;\t\treturn a.x &lt; b.x;\t&#125;&#125;;//初始化定义， priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; // x大的在堆顶\n\n版本二：直接在结构体里面写\n\n因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。\n\n结构体内部有两种方式：\n\n方式一 ：\nstruct node &#123;\tint x, y;\tfriend bool operator &lt; (Point a, Point b) &#123;//为两个结构体参数，结构体调用一定要写上friend\t\treturn a.x &lt; b.x;//按x从小到大排，x大的在堆顶\t&#125;&#125;;\n\n方式二 ：（推荐此种）\nstruct node &#123;    int x, y;    bool operator &lt; (const Point &amp;a) const &#123;//直接传入一个参数，不必要写friend        return x &lt; a.x;//按x升序排列，x大的在堆顶    &#125;&#125;;\n\n优先队列的定义\npriority_queue&lt;Point&gt; q;\n\n注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是完全相反的。所以只需要记住sort的排序规则和优先队列的排序规则是相反的就可以了。\n\n当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 &gt; ，那么孩子节点要大于父亲节点，堆顶自然是最小值。\n\n\n\n\n\n存储特殊类型的优先级存储pair类型\n排序规则：默认先对pair的first进行降序排序，然后再对second降序排序对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    priority_queue&lt;pair&lt;int, int&gt; &gt;q;\tq.push(&#123;7, 8&#125;);\tq.push(&#123;7, 9&#125;);\tq.push(make_pair(8, 7));    while(!q.empty()) &#123;        cout &lt;&lt; q.top().first &lt;&lt; &quot; &quot; &lt;&lt; q.top().second &lt;&lt; &quot;\\n&quot;;        q.pop();    &#125;    return 0;&#125;\n\n\n结果：8 77 97 8\n\n\n\nmap 映射介绍映射类似于函数的对应关系，每个x对应一个y，而map是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。\n\n比如说：学习 对应 看书，学习 是键，看书 是值。学习-&gt;看书玩耍 对应 打游戏，玩耍 是键，打游戏 是值。玩耍-&gt;打游戏\n\n\n头文件\n//头文件#include&lt;map&gt;\n\n初始化\n//初始化定义map&lt;string, string&gt; mp;map&lt;string, int&gt; mp;map&lt;int, node&gt; mp;//node是结构体类型\n\n\nmap特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n\n\n\n函数方法\n\n\n代码\n含义\n\n\n\nmp.find(key)\n返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end ( )\n\n\nmp.erase(it)\n删除迭代器对应的键和值 O ( l o g N )\n\n\nmp.erase(key)\n根据映射的键删除键和值 O ( l o g N )\n\n\nmp.erase(first,last)\n删除左闭右开区间迭代器对应的键和值 O ( l a s t − f i r s t )\n\n\nmp.size()\n返回映射的对数 O (1)\n\n\nmp.clear()\n清空map中的所有元素 O ( N )\n\n\nmp.insert()\n插入元素，插入时要构造键值对\n\n\nmp.empty()\n如果map为空，返回true，否则返回false\n\n\nmp.begin()\n返回指向map第一个元素的迭代器（地址）\n\n\nmp.end()\n返回指向map尾部的迭代器（最后一个元素的下一个地址）\n\n\nmp.rbegin()\n返回指向map最后一个元素的迭代器（地址）\n\n\nmp.rend()\n返回指向map第一个元素前面(上一个）的逆向迭代器（地址）\n\n\nmp.count(key)\n查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0\n\n\nmp.lower_bound()\n返回一个迭代器，指向键值&gt;&#x3D; key的第一个元素\n\n\nmp.upper_bound()\n返回一个迭代器，指向键值&gt; key的第一个元素\n\n\n注意下面说明部分函数方法的注意点\n\n注意：查找元素是否存在时，可以使用①mp.find() ② mp.count() ③ mp[key]但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间）所以为了不增加额外的空间负担，最好使用前两种方法\n\n迭代器进行正反向遍历\nmp.begin()和mp.end()用法：\n用于正向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.begin();while(it != mp.end()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n1 22 33 4\n\nmp.rbegin()和mp.rend()用法：\n用于逆向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.rbegin();while(it != mp.rend()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n3 42 31 2\n\n二分查找二分查找lower_bound() upper_bound()\n\nmap的二分查找以第一个元素（即键为准），对键进行二分查找返回值为map迭代器类型\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tmap&lt;int, int&gt; m&#123;&#123;1, 2&#125;, &#123;2, 2&#125;, &#123;1, 2&#125;, &#123;8, 2&#125;, &#123;6, 2&#125;&#125;;//有序\tmap&lt;int, int&gt;::iterator it1 = m.lower_bound(2);\tcout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\\n&quot;;//it1-&gt;first=2\tmap&lt;int, int&gt;::iterator it2 = m.upper_bound(2);\tcout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\\n&quot;;//it2-&gt;first=6\treturn 0;&#125;\n\n添加元素//先声明map&lt;string, string&gt; mp;\n\n\n方式一：\nmp[&quot;学习&quot;] = &quot;看书&quot;;mp[&quot;玩耍&quot;] = &quot;打游戏&quot;;\n\n方式二：插入元素构造键值对\nmp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));\n\n方式三：\nmp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));\n\n方式四:\nmp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);\n\n访问元素下标访问(大部分情况用于访问单个元素)\nmp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\\n&quot;;//只是简写的一个例子，程序并不完整\n\n遍历访问\n方式一：迭代器访问\nmap&lt;string,string&gt;::iterator it;for(it = mp.begin(); it != mp.end(); it++) &#123;\t//      键                 值 \t// it是结构体指针访问所以要用 -&gt; 访问\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\t//*it是结构体变量 访问要用 . 访问\t//cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;&#125;\n\n方式二：智能指针访问\nfor(auto i : mp)cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值\n\n方式三：对指定单个元素访问\nmap&lt;char,int&gt;::iterator it = mp.find(&#x27;a&#x27;);cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\\n&quot;;\n\n方式四：c++17特性才具有\nfor(auto [x, y] : mp)\tcout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\\n&quot;;//x,y对应键和值\n\n与unordered_map的比较这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n内部实现原理map：内部用红黑树实现，具有自动排序（按键从小到大）功能。\nunordered_map：内部用哈希表实现，内部元素无序杂乱。\n效率比较map：\n\n优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N)\n缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。\n\nunordered_map：\n\n优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n缺点：建立哈希表比较耗时。\n\n\n两者方法函数基本一样，差别不大。\n注意：\n\n随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n\n使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。\n\n查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n// 以 map 为例map&lt;int, int&gt; mp;int x = 999999999;if(mp.count(x)) // 此处判断是否存在x这个键    cout &lt;&lt; mp[x] &lt;&lt; &quot;\\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建\n\n\n另外：\n\n还有一种映射：multimap\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n\nset 集合介绍set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n即：set里面的元素不重复 且有序\n\n头文件\n//头文件#include&lt;set&gt;\n\n初始化\n//初始化定义set&lt;int&gt; s;\n\n函数方法\n\n\n代码\n含义\n\n\n\ns.begin()\n返回set容器的第一个元素的地址（迭代器）O ( 1 )\n\n\ns.end()\n返回set容器的最后一个元素的下一个地址（迭代器）O ( 1 )\n\n\ns.rbegin()\n返回逆序迭代器，指向容器元素最后一个位置O ( 1 )\n\n\ns.rend()\n返回逆序迭代器，指向容器第一个元素前面的位置O ( 1 )\n\n\ns.clear()\n删除set容器中的所有的元素\n\n\ns.empty()\n判断set容器是否为空O ( 1 )\n\n\ns.insert()\n插入一个元素\n\n\ns.size()\n返回当前set容器中的元素个数O ( 1 )\n\n\nerase(iterator)\n删除定位器iterator指向的值\n\n\nerase(first,second）\n删除定位器first和second之间的值\n\n\nerase(key_value)\n删除键值key_value的值\n\n\ns.find(element)\n查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器\n\n\ns.count(element)\n查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现\n\n\ns.lower_bound(k)\n返回&gt;&#x3D;k的第一个元素的迭代器O ( l o g N )\n\n\ns.upper_bound(k)\n返回&gt;k的第一个元素的迭代器O ( l o g N )\n\n\n访问\n迭代器访问\nfor(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n智能指针\nfor(auto i : s)\tcout &lt;&lt; i &lt;&lt; endl;\n\n访问最后一个元素\n//第一种cout &lt;&lt; *s.rbegin() &lt;&lt; endl;\n\n //第二种set&lt;int&gt;::iterator iter = s.end();iter--;cout &lt;&lt; (*iter) &lt;&lt; endl; //打印2;\n\n//第三种cout &lt;&lt; *(--s.end()) &lt;&lt; endl;\n\n重载&lt;运算符\n基础数据类型\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\nset&lt;int&gt; s1; // 默认从小到大排序set&lt;int, greater&lt;int&gt; &gt; s2; // 从大到小排序\n\n方式二：重载运算符。（很麻烦，不太常用，没必要）\n//重载 &lt; 运算符struct cmp &#123;    bool operator () (const int&amp; u, const int&amp; v) const &#123;       // return + 返回条件       return u &gt; v;    &#125;&#125;;set&lt;int, cmp&gt; s; for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto i : s)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;// 10 9 8 7 6 5 4 3 2 1\n\n方式三：初始化时使用匿名函数定义比较规则\nset&lt;int, function&lt;bool(int, int)&gt;&gt; s([&amp;](int i, int j)&#123;    return i &gt; j; // 从大到小&#125;);for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto x : s)    cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n\n高级数据类型（结构体）\n直接重载结构体运算符即可，让结构体可以比较。\nstruct Point &#123;\tint x, y;\tbool operator &lt; (const Point &amp;p) const &#123;\t\t// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\t\tif(x == p.x)\t\t\treturn y &lt; p.y;\t\treturn x &lt; p.x;\t&#125;&#125;;set&lt;Point&gt; s;for(int i = 1; i &lt;= 5; i++) &#123;    int x, y;    cin &gt;&gt; x &gt;&gt; y;    s.insert(&#123;x, y&#125;);&#125;\t/* 输入5 45 23 73 54 8*/for(auto i : s)    cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;/* 输出3 53 74 85 25 4*/\n\n其它setmultiset:元素可以重复，且元素有序\nunordered_set ：元素无序且只能出现一次\nunordered_multiset ： 元素无序可以出现多次\npair 二元组介绍pair只含有两个元素，可以看作是只有两个元素的结构体。\n应用：\n\n头文件\n//头文件#include&lt;utility&gt;\n\n初始化\n//1.初始化定义pair&lt;string, int&gt; p(&quot;zenith32&quot;,1);//带初始值的pair&lt;string, int&gt; p;//不带初始值的\n\n赋值\n//2.赋值p = &#123;&quot;zenith32&quot;, 18&#125;;p = make_pair(&quot;zenith32&quot;, 18);p = pair&lt;string, int&gt;(&quot;zenith32&quot;, 18);\n\n代替二元结构体\n\n作为map键值对进行插入（代码如下）\nmap&lt;string, int&gt; mp;mp.insert(pair&lt;string, int&gt;(&quot;zenith32&quot;,1));// mp.insert(make_pair(&quot;zenith32&quot;, 1));// mp.insert(&#123;&quot;zenith32&quot;, 1&#125;);\n\n访问//定义结构体数组pair&lt;int,int&gt; p[20];for(int i = 0; i &lt; 20; i++) &#123;\t//和结构体类似，first代表第一个元素，second代表第二个元素\tcout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;&#125;\n\nstring 字符串介绍string是一个字符串类，和char型字符串类似。\n可以把string理解为一个字符串类型，像int一样可以定义\n初始化及定义\n头文件\n//头文件#include&lt;string&gt;\n\n初始化\n//1.string str1; //生成空字符串//2.string str2(&quot;123456789&quot;); //生成&quot;123456789&quot;的复制品 //3.string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3//4.string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5//5.string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串//6.string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后\n\n访问单个字符：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s = &quot;zenith!!!&quot;;\tfor(int i = 0; i &lt; s.size(); i++)\t\tcout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;\treturn 0;&#125;\n\nstring数组使用：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s[10];\tfor(int i = 1; i &lt; 10; i++) &#123;\t\ts[i] = &quot;loading...  &quot; ;\t\tcout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\\n&quot;;\t&#125; \treturn 0;&#125;//结果://loading...  1//loading...  2//loading...  3//loading...  4//loading...  5//loading...  6//loading...  7//loading...  8//loading...  9\n\nstring 特性\n支持比较运算符\nstring字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），支持string与C-string的比较（如 str &lt; “hello”）。\n在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按 字典顺序 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。\n同时，string (&quot;aaaa&quot;) &lt;string(&quot;aaaaa&quot;)。\n\n支持+运算符，代表拼接字符串string字符串可以拼接，通过”+”运算符进行拼接。\nstring s1 = &quot;123&quot;;string s2 = &quot;456&quot;;string s = s1 + s2;cout &lt;&lt; s;   //123456\n\n读入详解读入字符串，遇空格，回车结束\nstring s;cin &gt;&gt; s;\n\n读入一行字符串（包括空格），遇回车结束\nstring s;getline(cin, s);\n\n注意: getline(cin, s)会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：getchar() 或 cin.get()\n错误读取：\nint n;string s;cin &gt;&gt; n;getline(cin, s); //此时读取相当于读取了前一个回车字符\n\n正确读取：\nint n;string s;cin &gt;&gt; n;getchar(); //cin.get() 读取前一个回车字符getline(cin, s);//可正确读入下一行的输入\n\n\ncin与cin.getline()混用\ncin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致getline()读取回车，结束。需要在cin后面加cin.ignore()；主动删除输入流中的换行符。（不常用）\n\ncin和cout解锁\n代码（写在main函数开头）：\nios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n\n\n为什么要进行cin和cout的解锁，原因是：\n在一些题目中，读入的数据量很大，往往超过了1e5（105）的数据量,而cin和cout的读入输出的速度很慢（是因为cin和cout为了兼容C语言的读入输出在性能上做了妥协），远不如scanf和printf的速度，具体原因可以搜索相关的博客进行了解。\n所以对cin和cout进行解锁使cin和cout的速度几乎接近scanf和printf，避免输入输出超时。\n\n注意：cin cout解锁使用时，不能与 scanf,getchar, printf,cin.getline()混用，一定要注意，会出错。\n\nstring与C语言字符串（C-string）的区别\nstring是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\\0字符C-stringC语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\\0结尾\n\n一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法c_str()实现string向char数组的转换。\nstring s = &quot;zenith&quot;;const char *s2 = s.c_str();\n\n函数方法\n获取字符串长度\n\n\n\n代码\n含义\n\n\n\ns.size()和s.length()\n返回string对象的字符个数，他们执行效果相同。\n\n\ns.max_size()\n返回string对象最多包含的字符数，超出会抛出length_error异常\n\n\ns.capacity()\n重新分配内存之前，string对象能包含的最大字符数\n\n\n\n插入\n\n\n\n代码\n含义\n\n\n\ns.push_back(element)\n在末尾插入\n\n\ns.insert(pos,element)\n在pos位置插入element\n\n\ns.append(str)\n在s字符串结尾添加str字符串\n\n\n例\n\n\n\n代码\n含义\n\n\n\ns.push_back(‘a’)\n末尾插入一个字符a\n\n\ns.insert(s.begin(),’1’)\n在第一个位置插入1字符\n\n\ns.append(“abc”)\n在s字符串末尾添加字符串“abc”\n\n\n\n删除\n\n\n\n代码\n含义\n\n\n\nerase(iterator p)\n删除字符串中p所指的字符\n\n\nerase(iterator first, iterator last)\n删除字符串中迭代器区间[first,last)上所有字符\n\n\nerase(pos, len)\n删除字符串中从索引位置pos开始的len个字符\n\n\nclear()\n删除字符串中所有字符\n\n\n\n字符替换\n\n\n\n代码\n含义\n\n\n\ns.replace(pos,n,str)\n把当前字符串从索引pos开始的n个字符替换为str\n\n\ns.replace(pos,n,n1,c)\n把当前字符串从索引pos开始的n个字符替换为n1个字符c\n\n\ns.replace(it1,it2,str)\n把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器（iterator）\n\n\n\n大小写转换\n法一：\n\n\n\n代码\n含义\n\n\n\ntolower(s[i])\n转换为小写\n\n\ntoupper(s[i])\n转换为大写\n\n\n法二：\n通过stl的transform算法配合tolower 和toupper 实现。有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。\nstring s;transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写\n\n分割\n\n\n\n代码\n含义\n\n\n\ns.substr(pos,n)\n截取从pos索引开始的n个字符\n\n\n\n查找\n\n\n\n代码\n含义\n\n\n\ns.find (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串\n\n\ns.find (c, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.rfind (str, pos)\n在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串\n\n\ns.rfind (c,pos)\n在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_of (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_not_of (str,pos)\n在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_of(str, pos)\n在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_not_of ( str, pos)\n在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串\n\n\n#include&lt;string&gt;#include&lt;iostream&gt;int main() &#123;    string s(&quot;dog bird chicken bird cat&quot;);//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标    cout &lt;&lt; s.find(&#x27;i&#x27;,6) &lt;&lt; endl;// 结果是：11    // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 4. 从字符串的末尾开始查找字符    cout &lt;&lt; s.rfind(&#x27;i&#x27;) &lt;&lt; endl;// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符    // 5. 在该字符串中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b    // 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9    // 7. 在该字符串最后中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21&#125;\n\n排序\nsort(s.begin(),s.end());  //按ASCII码排序\n\nbitset介绍bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间\n\n头文件\n//头文件#include&lt;bitset&gt;\n\n初始化定义\n初始化方法\nbitset&lt;n&gt; a;//a有n位，每位都为0bitset&lt;n&gt; a(b);//a是unsigned long型b的一个二进制副本bitset&lt;n&gt; a(s);//a是string对象s中含有的位串的副本bitset&lt;n&gt; a(s,pos,n);//a是s中从位置pos开始的n个位的副本\n\n\n注意：n必须为常量表达式\n\n演示代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tbitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为0bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用0补充string s = &quot;100101&quot;;bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用0补充char s2[] = &quot;10101&quot;;bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用0补充cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101return 0;&#125;\n特性bitset可以进行位操作\nbitset&lt;4&gt; foo (string(&quot;1001&quot;));bitset&lt;4&gt; bar (string(&quot;0011&quot;));cout &lt;&lt; (foo^=bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;// 0001 (按位与后赋值给foo)cout &lt;&lt; (foo|=bar) &lt;&lt; endl;// 1011 (按位或后赋值给foo)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; endl;// 0100 (左移2位，低位补0，有自身赋值)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; endl;// 0100 (右移1位，高位补0，有自身赋值)cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; endl;// 0110 (左移，不赋值)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; endl;// 0001 (右移，不赋值)cout &lt;&lt; (foo==bar) &lt;&lt; endl;// false (1001==0011为false)cout &lt;&lt; (foo!=bar) &lt;&lt; endl;// true  (1001!=0011为true)cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;// 0001 (按位与，不赋值)cout &lt;&lt; (foo|bar) &lt;&lt; endl;// 1011 (按位或，不赋值)cout &lt;&lt; (foo^bar) &lt;&lt; endl;// 1010 (按位异或，不赋值)\n\n访问\n//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：bitset&lt;4&gt; foo (&quot;1011&quot;); cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1cout &lt;&lt; foo[1] &lt;&lt; endl;　　//0cout &lt;&lt; foo[2] &lt;&lt; endl;　　//1\n\n方法函数\n\n\n代码\n含义\n\n\n\nb.any()\nb中是否存在置为1的二进制位，有 返回true\n\n\nb.none()\nb中是否没有1，没有 返回true\n\n\nb.count()\nb中为1的个数\n\n\nb.size()\nb中二进制位的个数\n\n\nb.test(pos)\n测试b在pos位置是否为1，是 返回true\n\n\nb[pos]\n返回b在pos处的二进制位\n\n\nb.set()\n把b中所有位都置为1\n\n\nb.set(pos)\n把b中pos位置置为1\n\n\nb.reset()\n把b中所有位都置为0\n\n\nb.reset(pos)\n把b中pos位置置为0\n\n\nb.flip()\n把b中所有二进制位取反\n\n\nb.flip(pos)\n把b中pos位置取反\n\n\nb.to_ulong()\n用b中同样的二进制位返回一个unsigned long值\n\n\narray 数组介绍\n头文件\n#include&lt;array&gt;\n\narray是C++11新增的容器，效率与普通数据相差无几，比vector效率要高，自身添加了一些成员函数。\n和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，只允许访问或者替换存储的元素。\n注意：\narray的使用要在std命名空间里\n使用声明和初始化\n基础数据类型\n声明一个大小为100的int型数组，元素的值不确定\narray&lt;int, 100&gt; a;\n\n声明一个大小为100的int型数组，初始值均为0(初始值与默认元素类型等效)\narray&lt;int, 100&gt; a&#123;&#125;;\n声明一个大小为100的int型数组，初始化部分值，其余全部为0\narray&lt;int, 100&gt; a&#123;1, 2, 3&#125;;\n或者可以用等号\narray&lt;int, 100&gt; a = &#123;1, 2, 3&#125;;\n\n高级数据类型不同于数组的是对元素类型不做要求，可以套结构体\narray&lt;string, 2&gt; s = &#123;&quot;ha&quot;, string(&quot;haha&quot;)&#125;;array&lt;node, 2&gt; a;\n\n取存元素值\n修改元素\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;a[0] = 4;\n\n访问元素\n下标访问\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++)     cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];\n\n利用auto访问\nfor(auto i : a)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\n迭代器访问\nauto it = a.begin();for(; it != a.end(); it++)     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\nat()函数访问\n//下标为1的元素 加上 下标为2的元素，答案为5array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nget方法访问\n//将a数组下标为1位置处的值改为xget&lt;1&gt;(a) = x;//注意 获取的下标只能写数字，不能填变量\n\n成员函数\n\n\n成员函数\n功能\n\n\n\nbegin()\n返回容器中第一个元素的访问迭代器（地址）\n\n\nend()\n返回容器最后一个元素后一个位置的访问迭代器（地址）\n\n\nrbegin()\n返回最后一个元素的访问迭代器（地址）\n\n\nrend()\n返回第一个元素前一个位置的访问迭代器（地址）\n\n\nsize()\n返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数N\n\n\nmax_size()\n返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N\n\n\nempty()\n判断容器是否为空\n\n\nat(n)\n返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常\n\n\nfront()\n返回容器中第一个元素的直接引用，函数不适用于空的 array 容器\n\n\nback()\n返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。\n\n\ndata()\n返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能\n\n\nfill(x)\n将 x 这个值赋值给容器中的每个元素,相当于初始化\n\n\narray1.swap(array2)\n交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型\n\n\n部分用法示例data()指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。\nat()下标为1的元素加上下标为2的元素，答案为5\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nfill()array的fill()函数，将a数组全部元素值变为x\na.fill(x);\n\n另外还有其它的fill()函数:将a数组[begin,end)全部值变为x\nfill(a.begin(), a.end(), x);\n\nget方法获取元素值将a数组下标为1位置处的值改为x\n注意 获取的下标只能写数字，不能填变量\nget&lt;1&gt;(a) = x;\n\n排序sort(a.begin(), a.end());\n\ntuple 元组介绍tuple模板是pair的泛化，可以封装不同类型任意数量的对象。\n可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。\ntuple可以等价为结构体使用\n\n头文件\n#include&lt;tuple&gt;\n\n基础用法声明及初始化\n声明一个空的tuple三元组\ntuple&lt;int, int, string&gt; t1;\n\n赋值\nt1 = make_tuple(1, 1, &quot;hahaha&quot;);\n\n创建的同时初始化\ntuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);\n\n可以使用pair对象构造tuple对象，但tuple对象必须是两个元素\nauto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象\n\n元素操作\n获取tuple对象t的第一个元素\nint first = get&lt;0&gt;(t);\n修改tuple对象t的第一个元素\nget&lt;0&gt;(t) = 1;\n\n函数操作\n获取元素个数\ntuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3\n\n获取对应元素的值\n//通过`get&lt;n&gt;(obj)`方法获取,`n`必须为数字不能是变量tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 1cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 2cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 3\n\n通过tie解包 获取元素值\n//tie可以让tuple变量中的三个值依次赋到tie中的三个变量中int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3\n\n\n后记stl 的总结就到这里先结束了，也算是按时提前完成此次任务了吧\n后续应该会补充一些其他常用的函数，例如 sort 等\n","categories":["学习"],"tags":["知识总结","算法"]},{"title":"使用BearPi-Pico H3863驱动3.52inch e-Paper HAT","url":"/2025/02/07/%E4%BD%BF%E7%94%A8BearPi-Pico%20H3863%E9%A9%B1%E5%8A%A83.52inch%20e-Paper%20HAT/","content":"使用BearPi-Pico H3863驱动3.52inch e-Paper HAT\n先祝大家新年快乐🎉\n微雪的官网已经给出了常见单片机使用3.52inch e-Paper的例程，我们在此基础上对其中的库文件以及例程进行了修改，使其能够适配BearPi-Pico H3863，下面先给出修改完后的文件包\n点击下载\n在下载完之后进行解压，打开海思HiSpark Studio IDE，在BearPi-Pico H3863的SDK工程的 &#x2F;application&#x2F;samples&#x2F; 下新建文件夹E-paper，然后再将刚刚解压的文件夹的内容都拷贝进来\n &#x2F;application&#x2F;samples&#x2F; 下的文件目录如下图所示\n\n在 &#x2F;application&#x2F;samples&#x2F; 下的Kconfig文件的最后添加如下代码\nconfig ENABLE_EPAPER_SAMPLE    bool    prompt &quot;Enable the Sample of E-paper.&quot;    default n    depends on SAMPLE_ENABLE    help        This option means enable the sample of E-paper.if ENABLE_EPAPER_SAMPLEosource &quot;application/samples/E-paper/Kconfig&quot;endif\n\n在 &#x2F;application&#x2F;samples&#x2F; 下的CMakeLists.txt文件中添加如下代码\nif(DEFINED CONFIG_ENABLE_EPAPER_SAMPLE)    add_subdirectory_if_exist(E-paper)endif()\n\n之后打开系统配置，通过修改编译宏配置改模块参与编译，如下图所示\n\n保存关闭之后对该文件进行重编译\n接下来就是使用杜邦线将BearPi-Pico H3863与3.52inch e-Paper HAT连接，\n对应关系如下\n\n\n\nBearPi-Pico H3863\n3.52inch e-Paper HAT\n\n\n\nGP12\nBUSY\n\n\nGP02\nRST\n\n\nGP10\nDC\n\n\nGP08\nCS\n\n\nGP07\nSCLK\n\n\nGP09\nDIN\n\n\nGND\nGND\n\n\n3.3V\nVCC\n\n\n具体连线还需根据设置进行调整\n然后将程序加载到目标板，待加载完成后运行，在墨水屏上输出测试图案，且运行过程中LED亮起即为成功。\n\n","categories":["学习"],"tags":["硬件","知识总结","华为"]},{"title":"基于华为云与frp实现内网穿透连接树莓派","url":"/2025/01/16/%E5%9F%BA%E4%BA%8E%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%8Efrp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","content":"放寒假了~ 买了好久的树莓派，终于可以开始玩了。\n首先就是通过raspberry pi imager进行基本的系统下载，在下载系统时设置好wifi并打开ssh连接，然后树莓派开机连接wifi后就能用同一网络下的电脑使用ssh连接树莓派了，进一步的，如果下载的是有图形化界面的系统，就可以用VNC进行远程桌面操控。因为没有显示屏，所以不得不使用这种方法连接树莓派咳咳\n接着，就想到这种方法只能在同一局域网下通过电脑连接树莓派，如果我在其他地方要远程控制树莓派就行不通了。因此，就需要内网穿透技术，下面我将基于华为云服务器实现内网穿透通过ssh连接树莓派。\n1.准备工作\n一台具有公网IP的服务器：\n用于运行frp服务端（例如华为云服务器）。\n\n在购买华为云服务器时需要购买并绑定相应的弹性公网ip才能有网络连接\n华为云服务器的安全组的对应端口要打开，后面会提到\n\n\n树莓派：\n确保树莓派已连接到网络，并启用SSH。\n\n下载frp：\n访问 frp GitHub Releases 下载适合树莓派和服务器的版本。\n\n树莓派（ARM架构）：frp_0.xx.0_linux_arm.tar.gz（我下载时最新的版本是frp_0.61.1_linux_arm.tar.gz）\n服务器（x86架构）：frp_0.xx.0_linux_amd64.tar.gz（我下载时最新的版本是 frp_0.61.1_linux_amd64.tar.gz）\n\n\n\n2.在服务器上配置frp服务端\n登录服务器：\n 使用SSH连接到你的公网服务器。\n\n下载并解压frp：\nwget https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_amd64.tar.gztar -zxvf frp_0.61.1_linux_amd64.tar.gzcd frp_0.61.1_linux_amd64\n注意，wget 在尝试下载 frp 时有几率遇到连接问题，可能是由于网络问题或 GitHub 的访问限制。此时可以在自己的电脑上下载，下载完后通过winSCP将文件传给华为云服务器，或者通过scp命令将文件传给服务器。\nscp frp_0.61.1_linux_amd64.tar.gz root@服务器公网IP:/root/\n\n配置frp服务端：\n编辑 frps.ini 文件：\n nano frps.ini\n\n 添加以下内容：\n  [common]bind_port = 7000\n\n\nbind_port 是frp服务端监听的端口。\n\n注意，此处的7000可以改成其他的端口，只要不冲突就行，也建议进行修改，在后续的安全组配置中要改成对应的端口号。\n\n\n保存并退出：\n\n保存文件：\n按下 Ctrl + O（即按住 Ctrl 键，然后按 O 键）。\n按 Enter 确认保存。\n\n退出 nano：\n   按下 Ctrl + X 退出编辑器。\n\n\n\n启动frp服务端：\n./frps -c frps.ini\n\n服务端会监听 7000 端口，等待客户端连接。\n\n保持服务端运行：\n可以使用 nohup 或 systemd 让frp服务端在后台运行：\nnohup ./frps -c frps.ini &gt; frps.log 2&gt;&amp;1 &amp;\n\n配置华为云安全组：\n\n登录华为云控制台，找到你的服务器实例。\n\n进入“安全组”配置，添加以下规则：\n\n协议：TCP\n端口范围：7000（或者更改为其他的合法端口）\n源地址：0.0.0.0&#x2F;0（或限制为你的电脑IP）\n\n\n保存规则。\n\n\n\n\n7.检查服务端是否运行：\n  ps aux | grep frps\n\n如果没有输出，说明 frp 服务端未运行，需要重新启动：\n ./frps -c frps.ini\n\n 补充：在ssh连接下可以用ctrl+D快速退出ssh连接，也能输入exit退出ssh连接\n3. 在树莓派上配置frp客户端\n登录树莓派：\n使用SSH连接到树莓派。\n\n下载并解压frp：\nwget https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_arm.tar.gztar -zxvf frp_0.61.1_linux_arm.tar.gzcd frp_0.61.1_linux_arm\n注意，此处和上面的问题一样，在下载frp时可能会有一些问题，此时可以在自己的电脑上下载，下载完后通过winSCP将文件传给树莓派，或者通过scp命令将文件传给树莓派。\n\n使用 scp 上传文件\nscp 是一个基于 SSH 的文件传输工具，可以将本地文件上传到远程服务器（如树莓派）。\n在本地电脑上执行以下命令：\n\nMac&#x2F;Linux：\n\n打开终端，运行以下命令：\nscp /path/to/frp_0.61.1_linux_arm.tar.gz pi@树莓派IP:/home/pi/\n\n\n将 /path/to/frp_0.61.1_linux_arm.tar.gz 替换为文件的实际路径。\n将 树莓派IP 替换为树莓派的局域网 IP 地址（如 192.168.1.100）。\n默认上传到树莓派的 /home/pi/ 目录。\n\n\n\n\nWindows：\n\n如果你使用的是 PowerShell，可以运行以下命令：\nscp C:\\Users\\username\\Downloads\\frp_0.61.1_linux_arm.tar.gz pi@树莓派IP:/home/pi/\n\n\n将 C:\\Users\\username\\Downloads\\frp_0.61.1_linux_arm.tar.gz 替换为文件的实际路径。\n将 树莓派IP 替换为树莓派的局域网 IP 地址。\n\n\n\n\n输入密码：\n\n系统会提示你输入树莓派的密码（默认密码是 raspberry）。\n输入密码后，文件会上传到树莓派。\n\n\n\n\n\n配置frp客户端：\n编辑 frpc.ini 文件：\nnano frpc.ini\n\n添加以下内容：\n[common]server_addr = 服务器公网IPserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000\n\n\nserver_addr：填写你的服务器公网IP。\nserver_port：与服务端的 bind_port 一致（默认7000，如果之前有修改，此处也要进行相应的修改）。\n[ssh]：定义一个SSH隧道，将服务器的 6000 端口映射到树莓派的 22 端口。\n\n\n启动frp客户端：\n./frpc -c frpc.ini\n\n客户端会连接到服务器，并将服务器的 6000 端口映射到树莓派的SSH服务。\n\n保持客户端运行：\n 可以使用 nohup 或 systemd 让frp客户端在后台运行：\n nohup ./frpc -c frpc.ini &gt; frpc.log 2&gt;&amp;1 &amp;\n\n检查服务端是否运行：\n ps aux | grep frps\n\n  如果没有输出，说明 frp 客户端未运行，需要重新启动：\n  ./frpc -c frpc.ini\n  补充：在ssh连接下可以用ctrl+D快速退出ssh连接，也能输入exit退出ssh连接\n\n检查端口监听状态：\n 运行以下命令，检查 7000 端口是否被 frp 服务端监听：\n sudo netstat -tuln | grep 7000\n\n  如果看到类似以下输出，说明端口已监听：\n   tcp        0      0 0.0.0.0:7000            0.0.0.0:*               LISTEN\n\n  如果没有输出，说明 frp 服务端未正确监听端口。\n\n检查 frp 客户端日志：\n 查看 frp 客户端的日志文件：\n  cat frpc.log\n\n 如果日志中有错误信息（如连接失败），请根据错误信息进行排查。\n\n\n4. 远程SSH连接树莓派\n通过服务器连接树莓派：\n\n在自己的电脑上使用以下命令通过服务器的公网IP和映射端口连接树莓派：\nssh -p 6000 pi@服务器公网IP\n\n输入树莓派的用户名（默认 pi）和密码即可登录。\n\n\n\n直接连接（如果配置了DDNS）：\n\n如果服务器绑定了域名（如 mypi.ddns.net），可以使用域名连接：\nssh -p 6000 pi@mypi.ddns.net\n\n\n\n至此，应该就可以基于华为云与frp实现内网穿透连接树莓派了，下面给出一些实用性和安全性建议\n5. 设置开机自启动为了确保frp客户端在树莓派重启后自动运行，可以将其设置为系统服务。\n\n创建systemd服务文件：\nsudo nano /etc/systemd/system/frpc.service\n\n添加以下内容：\n[Unit]Description=Frp Client ServiceAfter=network.target[Service]ExecStart=/home/pi/frp_0.61.1_linux_arm/frpc -c /home/pi/frp_0.61.1_linux_arm/frpc.iniRestart=on-failure[Install]WantedBy=multi-user.target\n\n\n修改 ExecStart 路径为你的frp客户端实际路径。\n\n\n启用并启动服务：\nsudo systemctl enable frpcsudo systemctl start frpc\n\n检查服务状态：\nsudo systemctl status frpc\n\n6. 安全性建议\n修改默认SSH端口：\n在树莓派上修改SSH端口（如 2222），并在frp客户端配置中同步修改 local_port。\n\n使用密钥认证：\n禁用密码登录，使用SSH密钥认证。\n\n限制访问IP：\n在服务器防火墙中限制 6000 端口的访问IP。\n\n\n7**. 同一局域网下使用VNC连接树莓派桌面**\n打开树莓派配置工具：\n运行以下命令打开 raspi-config：\nsudo raspi-config\n\n启用X11模式\n\n在 raspi-config 菜单中，选择 Advanced Options。\n选择A6 Wayland。\n选择W1 X11模式。\n确认OK自动重启系统。\n\n\n启用 VNC：\n\n在 raspi-config 菜单中，选择 Interfacing Options。\n选择 VNC，然后选择 Yes 启用 VNC。\n\n\n配置 VNC 客户端：\n\n打开 VNC 客户端。\n\n在地址栏中输入树莓派的IP地址。\n\n点击连接。\n\n\n\n\n8. 使用VNC远程连接树莓派桌面\n打开树莓派配置工具：\n运行以下命令打开 raspi-config：\nsudo raspi-config\n\n启用 VNC：\n\n在 raspi-config 菜单中，选择 Interfacing Options。\n选择 VNC，然后选择 Yes 启用 VNC。\n\n\n设置分辨率（可选）：\n\n在 raspi-config 菜单中，选择 Display Options。\n选择 Resolution，然后选择一个适合的分辨率（例如 1920x1080）\n\n\n完成配置：\n\n退出 raspi-config 并重启树莓派：\nsudo reboot\n\n\n启动 Virtual Mode 服务：\n\n运行以下命令启动 Virtual Mode 服务：\nsudo /etc/vnc/vncservice start vncserver-virtuald\n\n\n检查 Virtual Mode 状态：\n\n运行以下命令检查 Virtual Mode 服务是否正常运行：\nsudo /etc/vnc/vncservice status vncserver-virtuald\n\n如果服务未运行，尝试重启：\nsudo /etc/vnc/vncservice restart vncserver-virtuald\n\n\n确认 Virtual Mode 端口：\n\nVirtual Mode 默认使用 5901 端口。运行以下命令检查端口是否监听：\nsudo netstat -tuln | grep 5901\n\n如果看到类似以下输出，说明 Virtual Mode 正在监听：\ntcp        0      0 0.0.0.0:5901            0.0.0.0:*               LISTEN\n\n\n如果端口未监听：\n\n可能是 Virtual Mode 服务未正确启动。尝试重启服务：\nsudo /etc/vnc/vncservice restart vncserver-virtuald\n\n\n在本地计算机上创建 SSH 隧道：\n\n运行以下命令，将树莓派的 5901 端口转发到本地的 5901 端口：\nssh -L 5901:localhost:5901 -p 6000 pi@服务器公网ip\n\n\n保持 SSH 隧道连接：\n\n不要关闭这个 SSH 连接，保持它运行以维持隧道。\n\n\n配置 VNC 客户端：\n\n打开 VNC 客户端。\n在地址栏中输入 localhost:5901。\n点击连接。\n\n\n\n\nVirtual Mode 和 Service Mode 是 RealVNC 提供的两种不同的运行模式，它们的主要区别在于 适用场景、运行方式 和 性能表现。以下是它们的详细对比：\n\n1. Service Mode（服务模式）特点\n适用场景：\n用于直接访问树莓派的物理显示器（即连接了 HDMI 显示器或屏幕）。\n适合需要与物理显示器交互的场景，例如调试图形界面或运行图形化应用程序。\n\n\n运行方式：\n作为一个系统服务运行，由 vncserver-x11-serviced 管理。\n直接连接到树莓派的物理显示器（X11 会话）。\n\n\n性能：\n性能较好，因为直接使用物理显示器的硬件加速。\n延迟较低，适合图形密集型应用。\n\n\n端口：\n默认使用 5900 端口。\n\n\n\n优点\n直接访问物理显示器，适合需要与本地屏幕交互的场景。\n性能较好，延迟较低。\n\n缺点\n需要连接物理显示器，否则无法使用。\n如果没有物理显示器，Service Mode 可能无法正常工作。\n\n\n2. Virtual Mode（虚拟模式）特点\n适用场景：\n用于在没有物理显示器的情况下远程访问树莓派桌面。\n适合纯远程访问的场景，例如服务器或无头模式（Headless Mode）下的树莓派。\n\n\n运行方式：\n作为一个虚拟显示器运行，由 vncserver-virtuald 管理。\n不需要物理显示器，即使树莓派没有连接屏幕也可以使用。\n\n\n性能：\n性能稍差，因为没有硬件加速。\n延迟较高，尤其是在图形密集型应用中。\n\n\n端口：\n默认使用 5901 端口。\n\n\n\n优点\n不需要物理显示器，适合无头模式（Headless Mode）下的树莓派。\n可以随时随地远程访问树莓派桌面。\n\n缺点\n性能较差，延迟较高。\n不支持硬件加速，图形性能有限。\n\n\n3. 对比总结\n\n\n特性\nService Mode（服务模式）\nVirtual Mode（虚拟模式）\n\n\n\n适用场景\n需要物理显示器，适合本地调试\n不需要物理显示器，适合纯远程访问\n\n\n运行方式\n直接连接到物理显示器（X11 会话）\n虚拟显示器，无需物理显示器\n\n\n性能\n性能较好，延迟较低\n性能较差，延迟较高\n\n\n端口\n默认 5900\n默认 5901\n\n\n是否需要显示器\n需要\n不需要\n\n\n适合场景\n图形化应用、本地调试\n无头模式、远程访问\n\n\n\n4. 如何选择？\n选择 Service Mode：\n\n如果你连接了物理显示器（如 HDMI 屏幕），并且需要与本地屏幕交互。\n如果你需要较高的图形性能（例如运行图形化应用程序或游戏）。\n\n\n选择 Virtual Mode：\n\n如果你的树莓派没有连接物理显示器（无头模式）。\n如果你只需要远程访问树莓派桌面，且对图形性能要求不高。\n\n\n\n\n5. 如何切换模式？\n启用 Service Mode：\n\n运行以下命令启动 Service Mode：sudo /etc/vnc/vncservice start vncserver-x11-serviced\n确保在 raspi-config 中启用了 VNC：sudo raspi-config\n\n选择 Interfacing Options -&gt; VNC -&gt; Enable。\n\n\n\n\n启用 Virtual Mode：\n\n运行以下命令启动 Virtual Mode：sudo /etc/vnc/vncservice start vncserver-virtuald\n确保 Virtual Mode 服务已启用：sudo /etc/vnc/vncservice enable vncserver-virtuald\n\n\n切换模式：\n\n如果需要从 Service Mode 切换到 Virtual Mode，先停止 Service Mode：sudo /etc/vnc/vncservice stop vncserver-x11-serviced\n然后启动 Virtual Mode：sudo /etc/vnc/vncservice start vncserver-virtuald\n\n\n\n\n6. 注意事项\n端口冲突：\nService Mode 和 Virtual Mode 默认使用不同的端口（5900 和 5901），因此可以同时运行，但通常不建议这样做。\n\n\n性能优化：\n在 Virtual Mode 下，可以通过降低分辨率或启用压缩来优化性能。\n\n\n无头模式：\n如果你的树莓派没有连接显示器，建议使用 Virtual Mode。\n\n\n\n\n总结\nService Mode 适合连接物理显示器的场景，性能较好。\nVirtual Mode 适合无头模式下的远程访问，无需物理显示器。\n\n\n","categories":["学习"],"tags":["华为","树莓派"]},{"title":"基于鲲鹏数学库的高性能数学计算加速方法研究与实践","url":"/2024/12/21/%E5%9F%BA%E4%BA%8E%E9%B2%B2%E9%B9%8F%E6%95%B0%E5%AD%A6%E5%BA%93%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/","content":"基于鲲鹏数学库的高性能数学计算加速方法研究与实践1 实验目的1. 验证鲲鹏数学库的性能优化效果\n核心目标：通过一系列数学计算实验，系统验证基于鲲鹏架构的 Kunpeng Math Library (KML) 相较传统实现方式的性能提升程度。\n细化目标\n验证 KML 在不同数学计算任务中的加速效果，包括基础数学运算（如三角函数计算）、矩阵计算（如矩阵乘法）和高级线性代数问题（如特征值分解）。\n比较 KML 在单线程和多线程模式下的性能表现，探索其并行能力。\n\n\n\n2. 探索鲲鹏架构的硬件适配性\n硬件架构支持验证\n检验 KML 对鲲鹏处理器的硬件特性（如 SIMD 指令集、多核并行）和内存架构（如 L1&#x2F;L2 缓存优化）的适配程度。\n探索基于 ARM 架构优化的数学库在高性能计算（HPC）场景中的实际表现。\n\n\n平台优势探索\n评估 KML 在典型计算任务（如矩阵运算、快速傅里叶变换）中对其他平台（如 x86 架构）的相对性能优势，为基于鲲鹏的数学计算方案提供参考。\n\n\n\n3. 优化实际科学计算任务\n面向工程计算和科学研究\n通过 KML 的高性能计算加速，解决实际工程和科研中的计算瓶颈问题。例如，优化数据分析、机器学习训练中的矩阵运算，加速信号处理中的傅里叶变换等。\n\n\n扩展应用场景\n在本实验中探索 KML 在不同任务中的适配性，为其在更多计算场景（如气象模拟、分子动力学模拟等）提供基础。\n\n\n\n4. 提升鲲鹏生态的实践经验\n用户指导与案例积累\n总结使用 KML 的安装、配置、调试方法，以及在各类任务中的具体实现步骤，为开发者提供实践指南。\n为鲲鹏生态的推广提供优化实践案例，进一步推动基于 ARM 架构的高性能计算技术在行业中的普及。\n\n\n性能优化经验总结\n通过对比实验，提炼出优化数学计算性能的经验，如向量化处理、多线程并行优化、内存管理优化等，为后续开发高效的数学计算程序提供理论和实践依据。\n\n\n\n5. 评估性能与准确性的平衡\n性能测试\n在数学运算中，尤其是高级运算（如特征值分解、快速傅里叶变换），性能与准确性可能存在一定平衡点。实验目标之一是分析 KML 在保持高精度的同时实现性能提升的能力。\n\n\n结果一致性验证\n确保使用 KML 计算的结果在科学研究或工程应用中具有可接受的准确性，并验证其与传统实现方式的一致性。\n\n\n\n6. 推动数学计算领域的技术进步\n实践新算法\n利用鲲鹏架构和 KML 优化数学运算的能力，探索传统算法在新型硬件架构下的优化潜力。\n\n\n高性能计算的技术转化\n将 KML 的优势推广到实际的工业和学术计算任务中，为数学计算领域的技术进步提供支持。\n\n\n\n2 实验设备\n华为鲲鹏云服务器；\n\n具备网络连接的个人电脑。\n\n\n3 实验原理1. 数学库优化的核心思想鲲鹏数学库（KML）的设计理念是通过充分利用硬件特性提升数学运算的性能。以下是其核心优化思想：\n\n指令级优化\nKML 借助 ARMv8 架构的 SIMD（Single Instruction Multiple Data）指令集，能够在单次指令操作中对多个数据元素进行并行处理，从而显著提升运算速度。\n使用如 Neon 指令等优化数学函数（如三角函数、对数函数等）的批量处理能力。\n\n\n多线程并行\n通过 pthread 和 OpenMP 等多线程技术，KML 可高效分解计算任务，充分利用多核处理器的计算资源。\n\n\n内存访问优化\n避免频繁的内存读取与写入，通过对内存对齐、缓存友好型算法等优化策略，减少数据传输瓶颈。\n\n\n\n2. 硬件架构与性能优化的关系鲲鹏服务器基于 ARM 架构，具备以下硬件特性，KML 在设计时针对这些特性进行了针对性优化：\n\n高密度核心： 鲲鹏处理器具有高核数的特点，非常适合高并发计算任务，KML 可在矩阵运算、FFT 中有效分摊任务到多个核心，降低单核压力。\n宽向量寄存器： ARM 的 SIMD 技术利用宽向量寄存器，使得多数据并行计算成为可能。例如，KML_SVML 的优化实现可一次性处理多个向量元素。\n内存子系统优化： 鲲鹏架构的 L1 和 L2 缓存对矩阵计算中常见的密集存储访问模式进行了专门优化。KML 的矩阵运算函数充分利用了这一特性，通过块状处理减少了内存访问延迟。\n\n3. 数学计算的多层次优化方法KML 的优化覆盖了从低级指令到高级数学库的多个层次：\n\n基础数学函数优化： 优化基本数学函数（如三角函数、指数函数）的实现，通过硬件寄存器和流水线指令集实现批量处理。\nBLAS 和 LAPACK 优化\nBLAS：优化矩阵-向量运算、矩阵-矩阵运算等基础线性代数运算，广泛用于科学计算中。\nLAPACK：在更高级别的线性代数操作（如特征值问题、奇异值分解）中，KML 将关键计算步骤分解为高效的 BLAS 调用，并结合硬件特性进行细粒度优化。\n\n\n快速傅里叶变换（FFT）： FFT 算法中涉及复杂的递归和循环结构，KML 通过流水线技术和分块计算优化了时间复杂度，同时减少了内存访问次数。\n\n4. 实验的对比设计与性能评估策略为了全面评估 KML 的性能，实验采用了“传统实现”和“优化实现”的对比方式：\n\n传统实现：直接使用标准数学库（如 math.h）或手动实现算法，模拟常规的计算方式。\n优化实现：基于 KML 提供的库函数完成相同计算任务。\n性能评估\n时间复杂度：记录不同方法的执行时间，量化性能提升。\n准确性：验证 KML 的计算结果是否与传统实现一致，确保在优化性能的同时保证结果的可靠性。\n资源利用率：观察 CPU、内存的使用情况，分析 KML 如何在硬件资源利用上占据优势。\n\n\n\n5. 典型优化场景\n矩阵运算： 矩阵计算（如矩阵-向量乘法、矩阵分解）是科学计算中的核心任务。KML 针对矩阵密集型计算进行了特殊优化，减少了循环嵌套带来的性能瓶颈。\n高维向量运算： 例如三角函数计算，普通实现逐元素计算效率低下，而 KML 利用向量化技术和批量计算方法，可显著加速处理大规模数据。\n特征值问题： 对称矩阵特征值与特征向量计算涉及复杂的迭代算法，KML 在 LAPACK 的基础上进一步优化了矩阵操作的并行性。\n\n6. KML 的接口设计与易用性\n动态库链接： 用户可通过简单的编译选项链接 KML 提供的动态库，从而快速完成性能优化。\n模块化功能： 不同的子模块（如 BLAS、VML、SPBLAS 等）满足了从基础运算到高级线性代数的多种需求，提供了良好的兼容性和可扩展性。\n\n4 实验任务操作指导4.1安装KML下面介绍如何安装KML\n首先使用远程登录工具，登录到鲲鹏 ECS 服务器上\n下载 WinSCP 客户端并安装。\n启动WinSCP，启动后界面如下：\n\n看不见是正常的，别担心\n\n填写说明：\n\n协议：选填 SFTP 或者 SCP 均可。\n\n主机名：云服务器的公网 IP。登录管理控制台即可查看对应云服务器的公网 IP。\n\n端口：默认 22。\n\n用户名：云服务器的用户名。\n\n使用“SSH密钥方式”登录云服务器时：\n\n如果是“CoreOS”的公共镜像，用户名为“core”。\n\n如果是“非CoreOS”的公共镜像，用户名为“root”。\n\n\n\n使用“密码方式”登录云服务器，公共镜像（包括CoreOS）的用户名为：root。\n\n密码：购买云服务器设置的密码或通过密钥方式转化后的密码。\n\n单击“登录”，进入 “WinSCP” 文件传输界面。\n\n登录成功之后，您可以选择左侧本地计算机的文件，拖拽到右侧的远程云服务器，完成文件上传到云服务器。\n\n\n具体操作可以参考：\n本地Windows主机使用WinSCP上传文件到Linux云服务器 https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0166284971.html\n 然后到https://www.hikunpeng.com/developer/boostkit/library/detail?subtab=%E6%95%B0%E5%AD%A6%E5%BA%93获取KML软件包（GCC版本）\n\n看不见是正常的，别担心\n\n\n看不见是正常的，别担心\n\n下载软件包后解压得到此文件：\n\n看不见是正常的，别担心\n\n再通过“本地Windows主机使用WinSCP上传文件到Linux云服务器https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0166284971.html”中所述的远程登录将该文件上传到云服务器\n接下来安装KML。\n步骤1 登录云服务器，进入刚刚上传文件所在的目录，输入\nrpm -ivh kml-xxxx.aarch64.rpm\n\n安装软件包，其中命令中涉及的xxxx代表版本号，下图示中的版本号是2.4.0-1\n \n看不见是正常的，别担心\n\n步骤 2 安装后验证\n执行source命令或重新登录终端让环境变量生效。\nsource /etc/profile\n\n\n看不见是正常的，别担心\n\n查看环境变量LD_LIBRARY_PATH是否包含KML的安装路径“&#x2F;usr&#x2F;local&#x2F;kml&#x2F;lib”。\nenv | grep LD_LIBRARY_PATH\n\n如果变量包含安装路径，说明安装成功。\n\n看不见是正常的，别担心\n\n安装成功后在安装路径（默认路径是“&#x2F;usr&#x2F;local&#x2F;kml”）下生成相应文件，其中，include文件夹包含子库的头文件，lib文件夹包含了数学库的动态库文件。\n\n看不见是正常的，别担心\n\n使用时，请在GCC编译选项中添加动态库所在路径，链接需要使用的动态库文件，添加编译选项后用ldd命令检查程序依赖库是否准确链接。\n若需要使用KML_BLAS请添加如下代码，此处对官方给出的代码进行适当修改以正常使用：\n单线程不加锁版本：-L /usr/local/kml/lib/kblas/nolocking -lkblas -I /usr/local/kml/include -pthread单线程加锁版本：-L /usr/local/kml/lib/kblas/locking -lkblas -I /usr/local/kml/include -pthreadpthread实现多线程版本：-L /usr/local/kml/lib/kblas/pthread -lkblas -I /usr/local/kml/include -pthreadOpenMP实现多线程版本：-L /usr/local/kml/lib/kblas/omp -lkblas -I /usr/local/kml/include -pthread\n若需要使用KML_VML请添加：\n单线程版本：-L /usr/local/kml/lib/kvml/single -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm多线程版本：-L /usr/local/kml/lib/kvml/multi -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm -fopenmp\n若需要使用KML_SPBLAS请添加：\n单线程版本：-L /usr/local/kml/lib/kspblas/single -lkspblas -I /usr/local/kml/include -pthread多线程版本：-L /usr/local/kml/lib/kspblas/multi -lkspblas -I /usr/local/kml/include -pthread\n若需要使用KML_FFT请添加：\n单精度版本：-L /usr/local/kml/lib -lkfftf -I /usr/local/kml/include -pthread双精度版本：-L /usr/local/kml/lib -lkfft -I /usr/local/kml/include -pthread\n若需要使用KML_MATH请添加：\n高性能版本：-L /usr/local/kml/lib -lkm -lm -I /usr/local/kml/include -pthread高精度版本：-L /usr/local/kml/lib -lkm_l9 -lm -I /usr/local/kml/include -pthread\n若需要使用KML_SVML请添加：\n-L /usr/local/kml/lib -lksvml -lm -I /usr/local/kml/include -pthread\n若需要使用KML_VSL请添加：\n-L /usr/local/kml/lib -lkvsl -I /usr/local/kml/include -pthread -lm\n若需要使用KML_LAPACK：\n先生成完整的LAPACK，然后添加：\nexport KML_LAPACK_ROOT=/usr/local/kml/libexport ADAPT_ROOT=/home/lapack_adaptexport KML_BLAS_ROOT=/usr/local/kml/lib/kblas/ompgcc test.c -o test -fopenmp -I $KML_LAPACK_ROOT/include/kml-0.3.0 -L /usr/local/kml/lib -lklapack -L $ADAPT_ROOT -l:liblapack_adapt.a -L $KML_BLAS_ROOT -lkblas -lgfortran -lm -lkservice -I /usr/local/kml/include\n若需要使用KML_IPL请添加：\n-L /usr/local/kml/lib -lkipl -lklapack_full -L /usr/local/kml/lib/kblas/pthread -lkblas -lm -I /usr/local/kml/include -pthread\n若需要使用KML_SCALAPACK ：先生成完整的SCALAPACK，然后添加：\n# 动态gcc test.c -o app  -fopenmp -I /usr/local/kml/lib/kblas/omp/include/kml-0.3.0 -L /usr/local/kml/lib -l:libkscalapack.a -L /home/scalapack_adapt -l:libscalapack_adapt.a -L /usr/local/kml/lib/kblas/omp -l kblas -L /usr/local/kml/lib  -l:libkservice.a -L /home/lapack_adapt -l:liblapack_adapt.a  -lm -I /usr/local/kml/include# 静态export KML_LAPACK_ROOT=/usr/local/kml/libexport ADAPT_ROOT=/home/scalapack_adaptexport KML_BLAS_ROOT=/usr/local/kml/lib/kblas/ompgcc test.c -o app  -fopenmp -I $KML_LAPACK_ROOT/include/kml-0.3.0 -L /usr/local/kml/lib -l:libkscalapack.a -L $ADAPT_ROOT -l:libscalapack_adapt.a -L $KML_BLAS_ROOT -L /home/lapack_adapt -l:liblapack_adapt.a -l:libkservice.a -lm -I /usr/local/kml/include\n\n下面给出两个基础的测试程序用于测试是否已经成功安装\n使用mkdir创建文件夹FFTTEST，使用cd FFTTEST进入，vim test.c创建测试文件\n#include &lt;stdio.h&gt;#include &quot;km.h&quot;int main()&#123;    double pi = acos(-1);     // typical usage     double a = pi/6, b = 1.0, c = -3*pi/4, d = pi/3;     // print result     printf(&quot;sin(pi/6) = %.15f\\n&quot;, sin(a));     printf(&quot;sin(1.0) = %.15f\\n&quot;, sin(b));     printf(&quot;sin(-3*pi/4) = %.15f\\n&quot;, sin(c));      /*      *  sin(pi/6) = 0.500000000000000      *  sin(1.0) = 0.841470984807897      *  sin(-3*pi/4) = -0.707106781186548      *  sin(pi/3) = 0.866025403784438      * */        return 0;&#125;\n\n利用\ngcc test.c -I /usr/local/kml/include -L /usr/local/kml/lib -lkm_l9 -lm\n\n编译，生成a.out\n\n看不见是正常的，别担心\n\n输入\n./a.out\n\n运行，结果如下\n\n看不见是正常的，别担心\n\n接下来尝试用牛顿迭代法求解非线性方程的根\n依次执行命令 mkdir NEWTON、cd NEWTON 创建并进入到 NEWTON 目录。\n创建 sum.c 文件，编写内容如下：\n//牛顿迭代法求解非线性方程的根#include &lt;stdio.h&gt;#include &quot;km.h&quot;double f(double x) &#123;    return x * x - 2; // 函数 f(x) = x^2 - 2&#125;double df(double x) &#123;    return 2 * x; // 函数的导数 f&#x27;(x) = 2x&#125;double newton(double initial_guess, double tolerance, int max_iterations) &#123;    double x = initial_guess;    int iteration = 0;        while (iteration &lt; max_iterations) &#123;        double fx = f(x);        if (fabs(fx) &lt; tolerance) &#123;            return x; // 找到根，返回当前值        &#125;double dfx = df(x);        if (dfx == 0) &#123;            printf(&quot;Error: Derivative is zero. No solution found.\\n&quot;);            return x; // 导数为零，无法继续        &#125;         x = x - fx / dfx; // 牛顿迭代公式        iteration++;    &#125;    printf(&quot;Max iterations reached. Last approximation: %f\\n&quot;, x);    return x; // 返回最后的近似值&#125;int main() &#123;    double initial_guess = 1.0; // 初始猜测    double tolerance = 1e-7; // 容忍度    int max_iterations = 100; // 最大迭代次数    double root;    printf(&quot;With KML:\\n&quot;);    root = newton(initial_guess, tolerance, max_iterations);    printf(&quot;Root found: %f\\n&quot;, root);    return 0;&#125;\n\n输入\ngcc NEWTON_KML.c -I /usr/local/kml/include -L /usr/local/kml/lib -lkm -lm -o NEWTON_KML./NEWTON_KML\n\n运行之，结构如下：\n\n看不见是正常的，别担心\n\n至此说明kml安装成功\n4.2 矩阵-向量乘加运算对比实验该代码主要进行了如下工作：初始化规模为1000*300的矩阵A，长度为300的向量x，长度为1000的向量y1和y2。分别用两种方法求矩阵-向量乘加运算，即y&#x3D;alpha*A*x+beta*y： \n（1）按照矩阵-向量的乘加规则实现算法求解 \n（2）调用KML_BLAS提供的函数cblas_dgemv求解 分别用计时器记录两种方法消耗的时间，对比KML_BLAS与手动实现矩阵乘加的性能。 \n编写代码如下：\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include &quot;kblas.h&quot;#define M 1000#define N 300int main()&#123;    double A[M*N]=&#123;0&#125;;double x[N]=&#123;0&#125;;double y1[M]=&#123;0&#125;;double y2[M]=&#123;0&#125;;for (int i=0;i&lt;M*N;i++)&#123;   A[i]=i;&#125;for (int i=0;i&lt;N;i++)&#123;   x[i]=i;&#125;for (int i=0;i&lt;M;i++)&#123;   y1[i]=1;   y2[i]=1;&#125; double alpha=1.2;double beta=2.5;struct timespec t1,t2;    //定义初始与结束时间printf(&quot;Without KML:\\n&quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。for(int i=0;i&lt;M;i++)&#123;   double tmp=0;    for(int j=0;j&lt;N;j++)    &#123;         tmp+=(A[i*N+j]*x[j]);    &#125;    y1[i]=alpha*tmp+beta*y1[i];&#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  printf(&quot;With KML:\\n&quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。cblas_dgemv(CblasColMajor,CblasNoTrans, M, N, alpha, A, M, x, 1, beta, y2, 1); clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  return 0;&#125;\n\n输入：\ngcc kblas.c -o kblas -L /usr/local/kml/lib/kblas/nolocking -lkblas -I /usr/local/kml/include\n\n运行之，得到运行结果如下：\n\n看不见是正常的，别担心\n\n可知KML_BLAS提供的函数cblas_dgemv对矩阵-向量乘加运算的优化效果十分显著\n4.3 调用KML_VML库计算100000个数的sin值和普通循环对比体现优化使用多线程版本\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;kvml.h&quot;#define LEN 100000int main()&#123;   double src[LEN]=&#123;0&#125;;   double dst1[LEN]=&#123;0&#125;;   double dst2[LEN]=&#123;0&#125;;   for(int i=0;i&lt;LEN;i++)       src[i]=i;    struct timespec t1,t2;    //定义初始与结束时间    printf(&quot;Without KML_VML &quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    for(int i=0;i&lt;LEN;i++)       dst1[i]=sin(src[i]);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  //得出目标代码段的执行时间。    printf(&quot;With KML_VML &quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    vdsin(LEN,src,dst2);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);  //得出目标代码段的执行时间。return 0;&#125;\n\n输入\ngcc vsin.c -o vsin -L /usr/local/kml/lib/kvml/multi -lkvml -L /usr/local/kml/lib -lkm -I /usr/local/kml/include -lm -fopenmp./vsin\n\n运行结果如下所示：\n\n看不见是正常的，别担心\n\n可知KML_VML库对三角函数运算的优化效果十分显著\n4.4 体现LAPACK库性能的对比实验首先要生成完整的LAPACK用到的脚本\n接下来的程序需要脚本才能正确运行\n在&#x2F;home目录下创建sh.sh文件，接着编写如下代码：\nset -eEecho &quot;LAPACK_SRC_DIR         $&#123;LAPACK_SRC_DIR:-&lt;undefined&gt;&#125;&quot;echo &quot;LAPACK_TGZ             $&#123;LAPACK_TGZ:=/home/lapack-3.12.0.tar.gz&#125;&quot;echo &quot;LIBKLAPACK_A           $&#123;LIBKLAPACK_A:=/usr/local/kml/lib/libklapack.a&#125;&quot;echo &quot;LIBKSERVICE_A          $&#123;LIBKSERVICE_A:=$&#123;LIBKLAPACK_A/klapack/kservice&#125;&#125;&quot;echo &quot;ADAPT_DIR              $&#123;ADAPT_DIR:=./lapack_adapt&#125;&quot;echo &quot;CMAKE_BUILD_TYPE       $&#123;CMAKE_BUILD_TYPE:=Release&#125;&quot;echo &quot;LIBLAPACK_ADAPT_A      $&#123;LIBLAPACK_ADAPT_A:=liblapack_adapt.a&#125;&quot;echo &quot;LIBKLAPACK_FULL_SO     $&#123;LIBKLAPACK_FULL_SO:=libklapack_full.so&#125;&quot;echo &quot;CC                     $&#123;CC:=gcc&#125;&quot;echo &quot;FC                     $&#123;FC:=gfortran&#125;&quot;mkdir -p $&#123;ADAPT_DIR&#125;ZQcd $&#123;ADAPT_DIR&#125;# build netlib lapackif [ ! -r &quot;$&#123;LAPACK_SRC_DIR&#125;/CMakeLists.txt&quot; ]; then    mkdir -p netlib    ( cd netlib ; tar xzpf $&#123;LAPACK_TGZ&#125; )    LAPACK_SRC_DIR=$(cd netlib/l* ; pwd)fimkdir -p buildcmake_flags=(    -DCMAKE_BUILD_TYPE=$&#123;CMAKE_BUILD_TYPE&#125;    -DCMAKE_POSITION_INDEPENDENT_CODE=ON    -DCMAKE_C_COMPILER=$&#123;CC&#125;    -DCMAKE_Fortran_COMPILER=$&#123;FC&#125;    -DCMAKE_RULE_MESSAGES=off    -DBUILD_DEPRECATED=on    -DBUILD_TESTING=off)( cd build ; cmake $&#123;cmake_flags[*]&#125; $&#123;LAPACK_SRC_DIR&#125; )( cd build ; make -j )cp build/lib/liblapack.a $&#123;LIBLAPACK_ADAPT_A&#125;# get symbols defined both in klapack and netlib lapacknm -g $&#123;LIBLAPACK_ADAPT_A&#125; | grep &#x27;T &#x27; | grep -oP &#x27;\\K\\w+(?=_$)&#x27; | sort | uniq &gt; netlib.symnm -g $&#123;LIBKLAPACK_A&#125; | grep &#x27;T &#x27; | grep -oP &#x27;\\K\\w+(?=_$)&#x27; | sort | uniq &gt; klapack.symcomm -12 klapack.sym netlib.sym &gt; comm.sym# update symbols name of $&#123;LIBLAPACK_ADAPT_A&#125;while read sym; do    (        if ! nm $&#123;LIBLAPACK_ADAPT_A&#125; | grep -qe &quot; T $&#123;sym&#125;_\\$&quot;; then            continue        fi        ar x $&#123;LIBLAPACK_ADAPT_A&#125; $&#123;sym&#125;.f.o        mv $&#123;sym&#125;.f.o $&#123;sym&#125;_netlib.f.o        objcopy --redefine-sym $&#123;sym&#125;_=$&#123;sym&#125;_netlib_ $&#123;sym&#125;_netlib.f.o    ) &amp;done &lt; comm.symwaitar d $&#123;LIBLAPACK_ADAPT_A&#125; $(sed -ne &#x27;s/$/.f.o/p&#x27; comm.sym)ar d $&#123;LIBLAPACK_ADAPT_A&#125; xerbla.f.oar ru $&#123;LIBLAPACK_ADAPT_A&#125; *_netlib.f.orm *_netlib.f.o\n\n在&#x2F;home目录下输入\nsh sh.sh\n\n运行之，得到如下结果：\n\n看不见是正常的，别担心\n\n\n看不见是正常的，别担心\n\n至此LAPACK用到的脚本已经生成完毕\n接下来先展示如何使用一般c语言代码计算实对称矩阵的特征值与特征向量\n编写eigenNoOpt.c文件，文件内容如下：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;float** Matrix_Jac_Eig(float **array, int n, float *eig);int Matrix_Free(float **tmp, int m, int n);int main(void)&#123;    int n;    printf(&quot;请输入矩阵维度:\\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    float **array = (float **)malloc(n * sizeof(float *));    if (array == NULL)    &#123;        printf(&quot;error :申请数组内存空间失败\\n&quot;);        return -1;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        array[i] = (float *)malloc(n * sizeof(float));        if (array[i] == NULL)        &#123;            printf(&quot;error :申请数组子内存空间失败\\n&quot;);            return -1;        &#125;    &#125;    printf(&quot;请输入矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            scanf(&quot;%f&quot;, &amp;array[i][j]);        &#125;    &#125;    float *eig = (float *)malloc(n * sizeof(float));        struct timespec t1,t2;    printf(&quot;Without KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    float **Result = Matrix_Jac_Eig(array, n, eig);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      printf(&quot;特征矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            printf(&quot;%f &quot;, Result[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;特征根:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        printf(&quot;%f \\n&quot;, eig[i]);    &#125;    Matrix_Free(Result, n, n);    free(eig);    eig = NULL;    return 0;&#125;float** Matrix_Jac_Eig(float **array, int n, float *eig)&#123;    int i, j, flag, k;    flag = 0;    k = 0;    float sum = 0;    float **temp_mat = (float **)malloc(n * sizeof(float *));    for (i = 0; i &lt; n; i++)    &#123;        temp_mat[i] = (float *)malloc(n * sizeof(float));    &#125;    for (i = 0; i &lt; n; i++)    &#123;        for (j = 0; j &lt; n; j++)        &#123;            temp_mat[i][j] = array[i][j];        &#125;    &#125;    //判断是否为对称矩阵    for (i = 0; i &lt; n; i++)    &#123;        for (j = i; j &lt; n; j++)        &#123;            if (array[i][j] != array[j][i])            &#123;                flag = 1;                break;            &#125;        &#125;    &#125;    if (flag == 1)    &#123;        printf(&quot;error in Matrix_Eig: 输入并非是对称矩阵:\\n&quot;);        return NULL;    &#125;    else    &#123;        //开始执行算法        int p, q;        float thresh = 0.0000000001;        float max = array[0][1];        float tan_angle, sin_angle, cos_angle;        float **result = (float **)malloc(n * sizeof(float *));        if (result == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **result_temp = (float **)malloc(n * sizeof(float *));        if (result_temp == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **rot = (float **)malloc(n * sizeof(float *));        if (rot == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **mat = (float **)malloc(n * sizeof(float *));        if (mat == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            result[i] = (float *)malloc(n * sizeof(float));            if (result[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            result_temp[i] = (float *)malloc(n * sizeof(float));            if (result_temp[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            rot[i] = (float *)malloc(n * sizeof(float));            if (rot[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            mat[i] = (float *)malloc(n * sizeof(float));            if (mat[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    result[i][j] = 1;                &#125;                else                &#123;                    result[i][j] = 0;                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    mat[i][j] = 1;                &#125;                else                &#123;                    mat[i][j] = 0;                &#125;            &#125;        &#125;        max = array[0][1];        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    continue;                &#125;                else                &#123;                    if (fabs(array[i][j]) &gt;= fabs(max))                    &#123;                        max = array[i][j];                        p = i;                        q = j;                    &#125;                    else                    &#123;                        continue;                    &#125;                &#125;            &#125;        &#125;        while (fabs(max) &gt; thresh)        &#123;            if (fabs(max) &lt; thresh)            &#123;                break;            &#125;            tan_angle = -2 * array[p][q] / (array[q][q] - array[p][p]);            sin_angle = sin(0.5*atan(tan_angle));            cos_angle = cos(0.5*atan(tan_angle));            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        mat[i][j] = 1;                    &#125;                    else                    &#123;                        mat[i][j] = 0;                    &#125;                &#125;            &#125;            mat[p][p] = cos_angle;            mat[q][q] = cos_angle;            mat[q][p] = sin_angle;            mat[p][q] = -sin_angle;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    rot[i][j] = array[i][j];                &#125;            &#125;            for (j = 0; j &lt; n; j++)            &#123;                rot[p][j] = cos_angle*array[p][j] + sin_angle*array[q][j];                rot[q][j] = -sin_angle*array[p][j] + cos_angle*array[q][j];                rot[j][p] = cos_angle*array[j][p] + sin_angle*array[j][q];                rot[j][q] = -sin_angle*array[j][p] + cos_angle*array[j][q];            &#125;            rot[p][p] = array[p][p] * cos_angle*cos_angle +                array[q][q] * sin_angle*sin_angle +                2 * array[p][q] * cos_angle*sin_angle;            rot[q][q] = array[q][q] * cos_angle*cos_angle +                array[p][p] * sin_angle*sin_angle -                2 * array[p][q] * cos_angle*sin_angle;            rot[p][q] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            rot[q][p] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    array[i][j] = rot[i][j];                &#125;            &#125;            max = array[0][1];            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        continue;                    &#125;                    else                    &#123;                        if (fabs(array[i][j]) &gt;= fabs(max))                        &#123;                            max = array[i][j];                            p = i;                            q = j;                        &#125;                        else                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                eig[i] = array[i][i];            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    sum = 0;                    for (k = 0; k &lt; n; k++)                    &#123;                        sum = sum + result[i][k] * mat[k][j];                    &#125;                    result_temp[i][j] = sum;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    result[i][j] = result_temp[i][j];                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                array[i][j] = temp_mat[i][j];            &#125;        &#125;        Matrix_Free(result_temp, n, n);        Matrix_Free(rot, n, n);        Matrix_Free(mat, n, n);        Matrix_Free(temp_mat, n, n);        return result;    &#125;&#125;int Matrix_Free(float **tmp, int m, int n)&#123;    int i, j;    if (tmp == NULL)    &#123;        return(1);    &#125;    for (i = 0; i &lt; m; i++)    &#123;        if (tmp[i] != NULL)        &#123;            free(tmp[i]);            tmp[i] = NULL;        &#125;    &#125;    if (tmp != NULL)    &#123;        free(tmp);        tmp = NULL;    &#125;    return(0);&#125;\n\n输入如下代码对其进行编译并运行：\ngcc eigenNoOpt.c -o eigenNoOpt -lm./eigenNoOpt    \n\n得到运行结果如下：\n\n看不见是正常的，别担心\n\n对其进行改进，并作体现LAPACK库性能的对比实验如下：\n将传统C语言算法的代码改为如下：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;float** Matrix_Jac_Eig(float **array, int n, float *eig);int Matrix_Free(float **tmp, int m, int n);int main(void)&#123;    int n;    printf(&quot;请输入矩阵维度:\\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    float **array = (float **)malloc(n * sizeof(float *));    if (array == NULL)    &#123;        printf(&quot;error :申请数组内存空间失败\\n&quot;);        return -1;    &#125;    for (int i = 0; i &lt; n; i++)    &#123;        array[i] = (float *)malloc(n * sizeof(float));        if (array[i] == NULL)        &#123;            printf(&quot;error :申请数组子内存空间失败\\n&quot;);            return -1;        &#125;    &#125;    printf(&quot;请输入矩阵元素:\\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        for (int j = 0; j &lt; n; j++)        &#123;            scanf(&quot;%f&quot;, &amp;array[i][j]);        &#125;    &#125;    float *eig = (float *)malloc(n * sizeof(float));        struct timespec t1,t2;    printf(&quot;Without KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    float **Result = Matrix_Jac_Eig(array, n, eig);    clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。    printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      Matrix_Free(Result, n, n);    free(eig);    eig = NULL;    return 0;&#125;float** Matrix_Jac_Eig(float **array, int n, float *eig)&#123;    int i, j, flag, k;    flag = 0;    k = 0;    float sum = 0;    float **temp_mat = (float **)malloc(n * sizeof(float *));    for (i = 0; i &lt; n; i++)    &#123;        temp_mat[i] = (float *)malloc(n * sizeof(float));    &#125;    for (i = 0; i &lt; n; i++)    &#123;        for (j = 0; j &lt; n; j++)        &#123;            temp_mat[i][j] = array[i][j];        &#125;    &#125;    //判断是否为对称矩阵    for (i = 0; i &lt; n; i++)    &#123;        for (j = i; j &lt; n; j++)        &#123;            if (array[i][j] != array[j][i])            &#123;                flag = 1;                break;            &#125;        &#125;    &#125;    if (flag == 1)    &#123;        printf(&quot;error in Matrix_Eig: 输入并非是对称矩阵:\\n&quot;);        return NULL;    &#125;    else    &#123;        //开始执行算法        int p, q;        float thresh = 0.0000000001;        float max = array[0][1];        float tan_angle, sin_angle, cos_angle;        float **result = (float **)malloc(n * sizeof(float *));        if (result == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **result_temp = (float **)malloc(n * sizeof(float *));        if (result_temp == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **rot = (float **)malloc(n * sizeof(float *));        if (rot == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        float **mat = (float **)malloc(n * sizeof(float *));        if (mat == NULL)        &#123;            printf(&quot;error in Matrix_Eig:申请空间失败\\n&quot;);            return NULL;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            result[i] = (float *)malloc(n * sizeof(float));            if (result[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            result_temp[i] = (float *)malloc(n * sizeof(float));            if (result_temp[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            rot[i] = (float *)malloc(n * sizeof(float));            if (rot[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;            mat[i] = (float *)malloc(n * sizeof(float));            if (mat[i] == NULL)            &#123;                printf(&quot;error in Matrix_Eig:申请子空间失败\\n&quot;);                return NULL;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    result[i][j] = 1;                &#125;                else                &#123;                    result[i][j] = 0;                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    mat[i][j] = 1;                &#125;                else                &#123;                    mat[i][j] = 0;                &#125;            &#125;        &#125;        max = array[0][1];        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                if (i == j)                &#123;                    continue;                &#125;                else                &#123;                    if (fabs(array[i][j]) &gt;= fabs(max))                    &#123;                        max = array[i][j];                        p = i;                        q = j;                    &#125;                    else                    &#123;                        continue;                    &#125;                &#125;            &#125;        &#125;        while (fabs(max) &gt; thresh)        &#123;            if (fabs(max) &lt; thresh)            &#123;                break;            &#125;            tan_angle = -2 * array[p][q] / (array[q][q] - array[p][p]);            sin_angle = sin(0.5*atan(tan_angle));            cos_angle = cos(0.5*atan(tan_angle));            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        mat[i][j] = 1;                    &#125;                    else                    &#123;                        mat[i][j] = 0;                    &#125;                &#125;            &#125;            mat[p][p] = cos_angle;            mat[q][q] = cos_angle;            mat[q][p] = sin_angle;            mat[p][q] = -sin_angle;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    rot[i][j] = array[i][j];                &#125;            &#125;            for (j = 0; j &lt; n; j++)            &#123;                rot[p][j] = cos_angle*array[p][j] + sin_angle*array[q][j];                rot[q][j] = -sin_angle*array[p][j] + cos_angle*array[q][j];                rot[j][p] = cos_angle*array[j][p] + sin_angle*array[j][q];                rot[j][q] = -sin_angle*array[j][p] + cos_angle*array[j][q];            &#125;            rot[p][p] = array[p][p] * cos_angle*cos_angle +                array[q][q] * sin_angle*sin_angle +                2 * array[p][q] * cos_angle*sin_angle;            rot[q][q] = array[q][q] * cos_angle*cos_angle +                array[p][p] * sin_angle*sin_angle -                2 * array[p][q] * cos_angle*sin_angle;            rot[p][q] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            rot[q][p] = 0.5*(array[q][q] - array[p][p]) * 2 * sin_angle*cos_angle +                array[p][q] * (2 * cos_angle*cos_angle - 1);            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    array[i][j] = rot[i][j];                &#125;            &#125;            max = array[0][1];            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    if (i == j)                    &#123;                        continue;                    &#125;                    else                    &#123;                        if (fabs(array[i][j]) &gt;= fabs(max))                        &#123;                            max = array[i][j];                            p = i;                            q = j;                        &#125;                        else                        &#123;                            continue;                        &#125;                    &#125;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                eig[i] = array[i][i];            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    sum = 0;                    for (k = 0; k &lt; n; k++)                    &#123;                        sum = sum + result[i][k] * mat[k][j];                    &#125;                    result_temp[i][j] = sum;                &#125;            &#125;            for (i = 0; i &lt; n; i++)            &#123;                for (j = 0; j &lt; n; j++)                &#123;                    result[i][j] = result_temp[i][j];                &#125;            &#125;        &#125;        for (i = 0; i &lt; n; i++)        &#123;            for (j = 0; j &lt; n; j++)            &#123;                array[i][j] = temp_mat[i][j];            &#125;        &#125;        Matrix_Free(result_temp, n, n);        Matrix_Free(rot, n, n);        Matrix_Free(mat, n, n);        Matrix_Free(temp_mat, n, n);        return result;    &#125;&#125;int Matrix_Free(float **tmp, int m, int n)&#123;    int i, j;    if (tmp == NULL)    &#123;        return(1);    &#125;    for (i = 0; i &lt; m; i++)    &#123;        if (tmp[i] != NULL)        &#123;            free(tmp[i]);            tmp[i] = NULL;        &#125;    &#125;    if (tmp != NULL)    &#123;        free(tmp);        tmp = NULL;    &#125;    return(0);&#125;\n\n将调用KML库的那段代码中改为：\n#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include &quot;klapack.h&quot;int main()&#123;      char jobz = &#x27;V&#x27;;     char uplo = &#x27;L&#x27;;     int n = 10;     int lda = 10;     int info = 0;     double w[10];     double *work = NULL;     double qwork;     int lwork = -1;     int *iwork = NULL;     int qiwork;     int liwork = -1;     double a[] =     &#123;  1.23, 2.75, 3.10, 4.56, 5.92, 7.01, 8.40, 9.88, 6.34, 4.59, 2.75, 1.56, 2.49, 3.31, 4.47, 5.90, 6.55, 7.10, 8.22, 5.78,  3.10, 2.49, 1.88, 5.39, 6.23, 7.68, 3.79, 4.12, 6.44, 7.85,  4.56, 3.31, 5.39, 8.94, 4.58, 2.53, 6.83, 7.46, 1.56, 3.21,  5.92, 4.47, 6.23, 4.58, 9.76, 8.90, 5.12, 3.98, 2.63, 6.34,  7.01, 5.90, 7.68, 2.53, 8.90, 6.75, 4.80, 1.94, 3.55, 2.88,  8.40, 6.55, 3.79, 6.83, 5.12, 4.80, 1.64, 9.20, 5.90, 4.75,  9.88, 7.10, 4.12, 7.46, 3.98, 1.94, 9.20, 7.44, 2.38, 6.71,  6.34, 8.22, 6.44, 1.56, 2.63, 3.55, 5.90, 2.38, 0.76, 2.13,  4.59, 5.78, 7.85, 3.21, 6.34, 2.88, 4.75, 6.71, 2.13, 9.32    &#125;;     struct timespec t1,t2;    //定义初始与结束时间    /* Query optimal work size */     dsyevd_(&amp;jobz, &amp;uplo, &amp;n, a, &amp;lda, w, &amp;qwork, &amp;lwork, &amp;qiwork, &amp;liwork, &amp;info);     if (info != 0)     &#123;         return -1;     &#125;     lwork = (int)qwork;     work = (double *)malloc(sizeof(double) * lwork);     liwork = (int)qiwork;     iwork = (int *)malloc(sizeof(int) * liwork);     /* Calculate eigenvalues and eigenvectors */     printf(&quot;With KML:\\n&quot;);    clock_gettime(CLOCK_MONOTONIC,&amp;t1);      //计算开始时间。    dsyevd_(&amp;jobz, &amp;uplo, &amp;n, a, &amp;lda, w, work, &amp;lwork, iwork, &amp;liwork, &amp;info);     clock_gettime(CLOCK_MONOTONIC,&amp;t2);    //计算结束时间。      printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec);      free(work);     free(iwork);           return 0;&#125;\n\n编译并运行，得到结果如下：\n\n看不见是正常的，别担心\n\n可知LAPACK库对运算的优化效果十分显著\n4.5 使用KML库函数实现R2R变换优化首先是使用一般C语言实现R2R变换\n编写without.c文件，文件内容如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;void r2r_fft(double *in, double *out, int n) &#123;    int k, m, j;    double wr, wi, arg, c, s;    double *temp = (double*)malloc(n * sizeof(double));        // 实数的 R2R FFT 变换实现    for (k = 0; k &lt; n; k++) &#123;        temp[k] = in[k];    &#125;    // R2R FFT 变换    for (m = 1; m &lt;= n / 2; m *= 2) &#123;        wr = cos(M_PI / m);        wi = sin(M_PI / m);        for (k = 0; k &lt; n; k += 2 * m) &#123;            for (j = 0; j &lt; m; j++) &#123;                arg = j * (2 * M_PI / (2 * m));                c = cos(arg);                s = sin(arg);                double u1 = temp[k + j];                double u2 = temp[k + j + m];                double v1 = temp[k + j + m + 1];                out[k + j] = u1 + u2 * c - v1 * s;                out[k + j + 1] = u1 * s + u2 * v1 * c;            &#125;        &#125;    &#125;    free(temp);&#125;int main() &#123;    int rank = 2;     int *n;     struct timespec t1, t2;     n = (int*)malloc(sizeof(int) * rank);     n[0] = 128;  // 修改数据规模    n[1] = 128;  // 修改数据规模    double *in = (double*)malloc(sizeof(double) * n[0] * n[1]);     for (int i = 0; i &lt; n[0] * n[1]; i++) &#123;         in[i] = (double)(i % 10);  // 用一些基本的数值初始化输入数据    &#125;     double *out = (double*)malloc(sizeof(double) * n[0] * n[1]);    clock_gettime(CLOCK_MONOTONIC, &amp;t1);      // 计算开始时间    r2r_fft(in, out, n[0] * n[1]);            // 执行 R2R FFT    clock_gettime(CLOCK_MONOTONIC, &amp;t2);      // 计算结束时间    printf(&quot;Without KML:\\n&quot;);    printf(&quot;Time: %11u ns\\n&quot;, t2.tv_nsec - t1.tv_nsec);      free(n);    free(in);     free(out);    return 0;&#125;\n\n使用如下代码编译并运行\ngcc without.c -o without -lm./without    \n\n得到结果如下：\n\n看不见是正常的，别担心\n\n接着再使用KML_FFT库函数进行优化：\n编写FFT.c文件，内容如下：\n#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &quot;kfft.h&quot;int main() &#123;    int rank = 2;     int *n;     struct timespec t1, t2;    // 定义初始与结束时间    n = (int*)kml_fft_malloc(sizeof(int) * rank);     n[0] = 128;  // 修改数据规模    n[1] = 128;  // 修改数据规模    double *in = (double*)kml_fft_malloc(sizeof(double) * n[0] * n[1]);     for (int i = 0; i &lt; n[0] * n[1]; i++) &#123;         in[i] = (double)(i % 10);  // 用一些基本的数值初始化输入数据    &#125;     double *out = (double*)kml_fft_malloc(sizeof(double) * n[0] * n[1]);     kml_fft_r2r_kind *kind = (kml_fft_r2r_kind*)kml_fft_malloc(sizeof(kml_fft_r2r_kind) * rank);     kind[0] = KML_FFT_DHT;     kind[1] = KML_FFT_DHT;     kml_fft_plan plan;     clock_gettime(CLOCK_MONOTONIC, &amp;t1);      // 计算开始时间    plan = kml_fft_plan_r2r(rank, n, in, out, kind, KML_FFT_ESTIMATE);     kml_fft_execute_r2r(plan, in, out);     clock_gettime(CLOCK_MONOTONIC, &amp;t2);      // 计算结束时间     printf(&quot;With KML:\\n&quot;);    printf(&quot;Time: %11u ns\\n&quot;, t2.tv_nsec - t1.tv_nsec);      printf(&quot;\\n&quot;);    kml_fft_destroy_plan(plan);     kml_fft_free(n);     kml_fft_free(kind);     kml_fft_free(in);     kml_fft_free(out);     return 0;&#125;\n\n使用如下代码编译并运行\ngcc FFT.c -o FFT -L /usr/local/kml/lib -lkfft -I /usr/local/kml/include -pthread./FFT\n\n得到运行结果如下：\n\n看不见是正常的，别担心\n\n可知KML库对R2R FFT运算的优化效果十分显著\n5.实验结果分析1. 牛顿迭代法求解非线性方程的根\n实现了牛顿迭代法，通过简单的非线性方程（如 $f(x)&#x3D;x2−2$）验证计算结果的准确性。\n传统实现和 KML 的计算结果一致，说明 KML 提供的数学库可以准确求解非线性问题。\n\n2. 矩阵-向量乘加运算性能对比\n在矩阵规模为 1000×300 的情况下，KML 的矩阵乘加操作（cblas_dgemv）相比手动实现加速显著。\n时间数据\n手动实现耗时较长，主要由于逐元素计算导致的循环开销。\n调用 KML 提供的 BLAS 库后，耗时明显减少，充分利用了向量化和并行化。\n\n\n结论：KML 在矩阵计算场景中展现了出色的性能提升。\n\n3. KML_VML 向量数学运算优化\n比较普通循环与 KML 的矢量数学库处理大规模向量（如 100,000 元素）的性能。\n时间数据\n传统实现逐元素计算，耗时较长。\nKML 利用硬件寄存器和 SIMD 指令对数据进行批量处理，极大缩短了运算时间。\n\n\n分析：适合高频调用数学函数的场景，例如模拟计算和信号处理。\n\n4. 快速傅里叶变换（FFT）优化\n对比一般 FFT 算法和 KML_FFT 实现的性能。\n时间数据\n手动实现 FFT 的时间复杂度较高。\nKML 的 kml_fft_plan_r2r 方法不仅加速了计算，还简化了实现过程。\n\n\n结论：KML 的 FFT 模块对高维变换计算尤为高效。\n\n5. LAPACK 在实对称矩阵特征值计算中的优化\n测试任务：计算 $10\\times10$ 实对称矩阵的特征值和特征向量。\n结果分析\n传统实现（如 Jacobi 方法）存在显著计算瓶颈。\n调用 KML 提供的 LAPACK 接口后，计算时间大幅缩短，进一步展示了 KML 在线性代数中的优化潜力。\n\n\n\n通过上述实验，验证了鲲鹏数学库（KML）的性能和适用性。无论是基础数学运算、矩阵计算，还是更复杂的快速变换与特征值问题，KML 的表现均优于传统实现。同时，实验中总结出的优化方法对未来的高性能计算实践提供了有力支持。\n6 思考题使用KML_SVML进行短向量的数学运算优化KML_SVML是短向量的数学运算，包括幂函数、三角函数、指数函数、双曲函数、对数函数等。 KML_SVML通过Neon指令优化、内联汇编等方法，对输入向量进行批量处理，充分利用了鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升。\n请在下面代码空缺处将调用KML_SVML库函数对短向量的数学运算进行优化的代码补充完整\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;ksvml.h&quot;#define LEN 100000int main()&#123;double src[LEN]=&#123;0&#125;;double dst1[LEN]=&#123;0&#125;;double dst2[LEN]=&#123;0&#125;;float32x4_t src2;float32x4_t dst;struct timespec t1,t2; //定义初始与结束时间printf(&quot;Without KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。for(int i=0;i&lt;LEN;i++)src[i]=i;for(int i=0;i&lt;LEN;i++)dst1[i]=sin(src[i]);clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。printf(&quot;With KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。  for(int i=0;i&lt;LEN;i+=4)&#123;   \t//请在此处补充调用KML_SVML库函数对短向量的数学运算进行优化的代码    &#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。return 0;&#125;\n\n答案如下：\n#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#include&quot;ksvml.h&quot;#define LEN 100000int main()&#123;double src[LEN]=&#123;0&#125;;double dst1[LEN]=&#123;0&#125;;double dst2[LEN]=&#123;0&#125;;float32x4_t src2;float32x4_t dst;struct timespec t1,t2; //定义初始与结束时间printf(&quot;Without KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。for(int i=0;i&lt;LEN;i++)src[i]=i;for(int i=0;i&lt;LEN;i++)dst1[i]=sin(src[i]);clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。printf(&quot;With KML_SVML &quot;);clock_gettime(CLOCK_MONOTONIC,&amp;t1); //计算开始时间。  for(int i=0;i&lt;LEN;i+=4)&#123;    src2[0]=i;    src2[1]=i+1;    src2[2]=i+2;    src2[3]=i+3;    dst = svml128_sin_f32(src2);&#125;clock_gettime(CLOCK_MONOTONIC,&amp;t2); //计算结束时间。printf(&quot;Time:%11u ns\\n&quot;,t2.tv_nsec-t1.tv_nsec); //得出目标代码段的执行时间。return 0;&#125;\n\n输入\ngcc svsin.c -o svsin -I /usr/local/kml/include -L /usr/local/kml/lib -lksvml -lm./svsin\n\n编译并运行得到运行结果如下：\n\n看不见是正常的，别担心\n\n通过对比可知使用KML_SVML进行短向量的数学运算优化的优化效果十分显著\n","categories":["学习"],"tags":["华为","计算机组成原理","论文","鲲鹏"]},{"title":"美赛苟活大法","url":"/2024/12/26/%E7%BE%8E%E8%B5%9B%E8%8B%9F%E6%B4%BB%E5%A4%A7%E6%B3%95/","content":"十分、万分感谢来自对外经济贸易大学的藏羚羊，本美赛苟活大法是由她编写的，此处仅搬运分享，再次表达感谢！！！\n美赛苟活大法\n下面是藏羚羊的微信公众号，请复制链接后在微信中打开😊 \n\n        \n        聆言'Econ小学二年级已修读完毕😎'","categories":["学习"],"tags":["资料"]},{"title":"环境变量变化复原方法","url":"/2025/02/12/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%98%E5%8C%96%E5%A4%8D%E5%8E%9F%E6%96%B9%E6%B3%95/","content":"环境变量变化复原方法\n刚刚在使用 SSH 时，我发现系统提示无法找到相应的命令，随即尝试了 Git、Ping 等其他常见命令，结果都显示“找不到该命令”。此时我就意识到可能是系统环境变量出现了问题。经过一段时间的排查后，我发现系统环境变量中的 Path 值异常，它只包含了我一周前下载的某个软件的安装路径。这让我感到非常困扰，因为这意味着系统中其他重要的路径被意外移除。\n为了解决这一问题，我尝试手动将常见的路径一一添加回去，但由于记不得所有路径，手动恢复变得非常困难。经过一番查找解决方案后，我发现可以通过“系统还原”功能来恢复系统到先前的状态，进而恢复丢失的环境变量。以下是具体的操作步骤：\n系统还原操作步骤：\n打开运行窗口： 按 Win + R 打开运行框，在输入框中输入 rstrui，然后按 Enter 键。这将启动“系统还原”工具。\n选择还原点： 在“系统还原”界面中，点击“下一步”，选择一个还原点，通常选择一个接近环境变量丢失之前的日期。建议选择一个最近的还原点，以便恢复系统的稳定性和功能。\n确认还原点： 系统会列出你所选择的还原点，点击“完成”后，系统将开始恢复操作。在此过程中，所有操作系统设置、程序和注册表会被还原至该还原点的状态。注意，系统还原不会影响你的个人文件，但会撤销最近安装的程序和驱动。\n等待还原过程完成： 系统会自动进行重启，并根据所选的还原点恢复相关的配置设置。恢复过程可能需要一些时间，请耐心等待。\n重启并验证环境变量： 完成系统还原后，重启计算机，再次检查 Path 环境变量是否已经恢复到原有状态。此时，你应该可以恢复对 ssh、git、ping 等命令的访问，且环境变量中的 Path 路径应恢复正常。\n\n关于系统还原：下面简单介绍一下救了我一命的系统还原吧：系统还原是一种 Windows 提供的恢复功能，旨在帮助用户在遇到系统故障或配置错误时，恢复到先前的稳定状态。它通过创建“还原点”来保存系统的关键设置和文件，允许用户在系统出现问题时回到这些还原点。还原点通常会在安装新程序、更新驱动程序或进行系统更新时自动创建。系统还原操作不会影响到用户的个人文件和数据，但会撤销最近的系统更改。\n使用系统还原时的注意事项：\n时间选择：还原点应选择在问题发生前创建的时间。如果没有合适的还原点，则可能无法完全恢复到理想状态。\n程序影响：使用系统还原可能会导致最近安装的应用程序丢失，因此在操作前需要重新安装这些程序。\n文件安全性：系统还原不会影响用户个人数据，因此文件和文档通常不受影响。\n\n总结：系统还原功能为解决因系统配置错误或误操作引起的问题提供了有效的解决方案。对于环境变量丢失或被错误修改的情况，使用系统还原可以快速恢复到先前的正常状态，避免手动修复的复杂性。然而，在使用此功能时，确保选择合适的还原点，避免丢失不必要的数据。\n\n，\n","categories":["学习"],"tags":["知识总结"]},{"title":"WSL的安装与使用","url":"/2025/07/06/WSL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"前言：因为某个项目在windows下编译实在是太慢太慢太慢了受不了了，而在Ubuntu下编译非常非常非常快，因此需要安装 WSL 来提高编译速度。\n据了解 WSL 有两个主要版本：WSL 1 和 WSL 2，它们在架构、性能和功能上有显著差异：\n\n\n\n特性\nWSL 1\nWSL 2\n\n\n\n架构\n转换层（Linux 系统调用 → Windows API）\n轻量级虚拟机（基于 Hyper-V，运行完整 Linux 内核）\n\n\n文件系统性能\nWindows 文件系统（NTFS）访问较慢\n大幅提升（Linux 文件系统 ext4 原生支持）\n\n\n系统调用兼容性\n部分 Linux 系统调用不支持\n几乎 100% 兼容（因使用真实 Linux 内核）\n\n\n启动速度\n更快（无虚拟机）\n稍慢（需启动轻量级 VM）\n\n\n内存占用\n更低\n稍高（需分配固定内存）\n\n\n网络模式\n与 Windows 共享 IP\n独立 IP（类似虚拟机，需端口转发）\n\n\nGPU&#x2F;Docker 支持\n有限\n完整支持（CUDA、Docker 等）\n\n\n而 WSL 2 虽然性能更强、兼容性更好，但在某些硬件相关的场景下会比 WSL 1 更复杂，主要原因包括：\n\n\n网络配置更复杂\n\n\nWSL 2 使用独立的虚拟网络（NAT 模式），而 WSL 1 直接共享 Windows 的网络栈。\n问题示例：\n在 WSL 2 中运行的服务（如 nginx）默认无法通过 localhost 从 Windows 直接访问，需手动配置端口转发或防火墙规则。\n跨设备访问 WSL 2 中的服务（如手机调试）需额外设置。\n\n\n\n\n文件系统访问延迟\n\n\nWindows 访问 Linux 文件：WSL 2 的 Linux 文件存储在虚拟磁盘（ext4）中，Windows 通过 \\\\wsl$ 访问时会有性能损耗。\nLinux 访问 Windows 文件：在 WSL 2 中挂载 Windows 目录（如 /mnt/c）时，IO 性能较差（尤其是大量小文件操作）。\n\n\nUSB&#x2F;外设支持受限\n\n\nWSL 2 默认无法直接访问 USB 设备（如 Arduino、摄像头），需通过第三方工具（如 usbipd-win）或 Windows 驱动桥接。\nWSL 1 因直接调用 Windows 驱动，外设支持更简单。\n\n\nGPU 加速需额外配置\n\n\n虽然 WSL 2 支持 GPU（如 CUDA 开发），但需手动安装：\nWindows 侧：NVIDIA 驱动。\nWSL 2 侧：Linux 版 CUDA Toolkit。\n\n\nWSL 1 无此需求（但 GPU 功能受限）。\n\n\n内存管理问题\n\n\nWSL 2 默认会占用固定内存（如 50% 物理内存），可能因内存不足导致 Windows 卡顿，需手动调整限制（在 .wslconfig 中配置）。\n\n\n因此，我选择安装 WSL 1 ，接下来，我将开始介绍如何在windows电脑上安装 WSL 1 。\n一、安装Windows终端windows11自带windows终端，跳过这一步\n二、启用 WSL 功能打开 PowerShell 管理员模式 输入下面指令\n# 启用 适用于Linux的Windows子系统 功能dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n\n完成后重启系统\n或者也可以手动启用：\nWin + S 输入搜索 控制面板 —&gt; 打开 控制面板 —&gt; 点击 程序和功能 —&gt;启动或关闭Windows功能 —&gt; 勾选适用于Linux的Windows子系统 —&gt; 重启系统\n三、安装 Linux 发行版在 Microsoft Store 搜索 Ubuntu ，安装 Ubuntu 24.04.1 LTS\n# cmd查看Windows系统中已安装的WSLwsl -l -v# 列出可用的分发（需要梯子，在 Microsoft Store 下载不需要梯子）wsl.exe --list --online# 进行安装（需要梯子，在 Microsoft Store 下载不需要梯子）wsl.exe --install &lt;发行版名称&gt;# 例如：wsl.exe --install Ubuntu-24.04\n\nUbuntu 安装完成后打开，此时会让你新建用户，按照提示输入用户名密码。\n四、设置为 WSL 1\n在 PowerShell 中运行：\nwsl --set-version &lt;发行版名称&gt; 1# 例如：wsl --set-version Ubuntu-24.04 1\n\n等待转换完成。\n\n\n五、基本使用\n启动 Linux：\n\n在开始菜单中点击安装的发行版名称，或命令行输入 wsl。\n\n\n更新软件包列表\nsudo apt update\n\n升级已安装的软件\nsudo apt upgrade -y \n\nWindows挂载目录\n在WSL（Windows Subsystem for Linux）中，/mnt目录是Windows文件系统在Linux环境中的挂载点，用于实现Windows和Linux之间的文件互通访问。\nWSL会自动将Windows的磁盘驱动器（如C:、D:）挂载到Linux的/mnt目录下，形成对应子目录：\n\nC:盘 → /mnt/c\nD:盘 → /mnt/d\n以此类推。\n例如，Windows的C:\\Users\\YourName\\Documents在WSL中路径为/mnt/c/Users/YourName/Documents。\n\n对性能敏感的项目建议放在WSL原生文件系统内（如~/project），而非/mnt下。\n在Windows中编辑WSL文件：使用VSCode的Remote-WSL扩展或直接访问\\\\wsl$\\。\n在WSL中编辑Windows文件：注意行尾符和权限问题。\n\n下载 neofetch htop\n# 使用sudo权限通过apt包管理器安装neofetch和htop两个软件# neofetch: 用于在终端显示系统信息和logo的轻量级工具# htop: 交互式系统监控工具，比默认的top命令更强大直观sudo apt install neofetch htop\n\n把文件迁移到wsl并递归赋予权限\n# 递归修改所有权（确保用户是所有者）sudo chown -R $USER:$USER .# 递归赋予读写执行权限sudo chmod -R u+rwx .\n\n使用vscode中的WSL插件访问WSL中的文件与工程\n\n退出 Linux：\n\n在 Linux 终端中输入 exit。\n\n\n关闭 WSL\n# 会终止所有未保存的 WSL 会话，类似于强制关机。wsl --shutdown# 如果需要正常退出 Linux 系统，建议先在 WSL 终端内运行 exit 或 sudo shutdown now。\n\n","categories":["学习"],"tags":["资料"]},{"title":"编译时unused报错解决方案","url":"/2025/07/07/%E7%BC%96%E8%AF%91%E6%97%B6unused%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"这两天在做一个C的项目，编译用到了CMake，遇到了挺多的问题。今天发现了同一个文件相同的内容在一台电脑上可以编译通过，在另一台电脑上编译不通过。始终报的是error:xxx defined but not used  或者 error:unused parameter xxx 的错，经过查阅资料以及对CMakeLists的检查，发现是一台电脑上的CMake屏蔽了unused的报错，一台没屏蔽，在没屏蔽该报错的电脑加上如下内容后也可以正常编译了：\n# use this when you want to add ccflags like -include xxxset(COMPONENT_PUBLIC_CCFLAGS &quot;&quot;)# 设置不显示未使用警告set(COMPONENT_CCFLAGS    -Wno-unused-variable      # 禁止未使用变量警告    -Wno-unused-parameter     # 禁止未使用参数警告    -Wno-unused-function      # 禁止未使用函数警告    -Wno-error=unused-function # 确保未使用函数不会导致编译错误)\n\n","categories":["学习"],"tags":["资料"]},{"title":"加速编译的方法","url":"/2025/07/10/%E5%8A%A0%E9%80%9F%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%B9%E6%B3%95/","content":"前言：之前以为主要是操作系统的问题导致编译速度的差异，使用了 wsl 后编译速度虽然有提高但是还是很慢，因此要继续想办法优化编译速度。在编译的过程中发现除了我修改的主要的代码外，其他的库文件以及一些不知道是什么的文件重复编译导致大量时间的浪费。又因为不知道这些文件有什么用因此不敢轻易将这些文件删除，故采用编译缓存的方式来提高文件的编译速度。\n以下是使用 ccache 加速 GCC&#x2F;G++ 编译的 详细步骤 和 注意事项，适用于 Ubuntu&#x2F;WSL 等 Linux 环境：\n1. 安装 ccache# 更新软件包列表（确保获取最新版本）sudo apt update# 安装 ccache 工具sudo apt install ccache\n\n2. 配置编译器别名（临时生效）在当前终端会话中，临时设置 ccache 包装 GCC&#x2F;G++：\n# 设置环境变量：让系统在调用 gcc 时实际使用 ccache 包装的 gccexport CC=&quot;ccache gcc&quot;# 设置环境变量：让系统在调用 g++ 时实际使用 ccache 包装的 g++export CXX=&quot;ccache g++&quot;\n\n验证环境变量是否生效：\n# 验证环境变量是否生效echo $CC    # 应输出 &quot;ccache gcc&quot;echo $CXX   # 应输出 &quot;ccache g++&quot;\n\n3. 永久生效配置（推荐）(1) 修改全局环境变量编辑 ~/.bashrc 或 ~/.zshrc（根据你的 Shell）：\n# 编辑 Shell 配置文件（如 ~/.bashrc 或 ~/.zshrc）vim ~/.bashrc\n\n在文件末尾添加：\n# 强制所有 gcc 调用走 ccacheexport CC=&quot;/usr/lib/ccache/gcc&quot; # 强制所有 g++ 调用走 ccacheexport CXX=&quot;/usr/lib/ccache/g++&quot;\n\n保存后加载配置：\n# 保存文件后，加载配置使其立即生效source ~/.bashrc\n\n(2) 或创建符号链接（更彻底）# 创建符号链接，将 gcc/g++ 指向 ccache（需要管理员权限）# 任何地方调用 gcc 都会先走 ccachesudo ln -s /usr/bin/ccache /usr/local/bin/gcc# 任何地方调用 g++ 都会先走 ccachesudo ln -s /usr/bin/ccache /usr/local/bin/g++# 覆盖 cc 编译器别名sudo ln -s /usr/bin/ccache /usr/local/bin/cc# 覆盖 c++ 编译器别名sudo ln -s /usr/bin/ccache /usr/local/bin/c++\n\n优先级检查：\n# 验证优先级which gcc  # 应显示 /usr/local/bin/gcc（表示符号链接生效）\n\n4. 验证 ccache 工作(1) 手动编译测试# 使用 ccache 编译一个测试文件ccache gcc -o test test.c # 直接调用 ccache# 或者（如果配置了环境变量/符号链接）gcc -o test test.c         # 隐式通过 ccache\n\n(2) 查看缓存统计ccache -s # 显示缓存命中率、缓存目录等信息\n\n输出示例：\n# 缓存存储位置cache directory                     /home/user/.ccache# 主配置文件primary config                      /home/user/.ccache/ccache.confsecondary config      (readonly)    /etc/ccache.conf# 直接命中缓存次数cache hit (direct)                  0# 预处理后命中次数cache hit (preprocessed)            0# 未命中次数（需重新编译）cache miss                          1...\n\n\n**cache miss**：首次编译未命中缓存，后续重复编译会显示 cache hit。\n\n5. 在构建系统中使用(1) CMake 项目在 CMakeLists.txt 或配置时指定编译器：\n# 方法1：通过环境变量传递# 在配置阶段指定编译器CC=&quot;ccache gcc&quot; CXX=&quot;ccache g++&quot; cmake ..\n\n或直接启用 ccache 支持：\n# 方法2：在 CMake 命令中直接启用 ccachecmake -DCMAKE_CXX_COMPILER_LAUNCHER=ccache -DCMAKE_C_COMPILER_LAUNCHER=ccake ..\n\n(2) Makefile 项目修改 Makefile 的编译器变量：\n# 修改 Makefile 中的编译器变量# 覆盖默认的 gccCC = ccache gcc# 覆盖默认的 g++CXX = ccache g++\n\n\n6. 高级配置（可选）(1) 调整缓存大小（默认 5GB）# 设置缓存最大为 10GB（默认 5GB）ccache --set-config=max_size=10G  # 设置为 10GB\n\n(2) 清空缓存# 清除所有缓存文件ccache -C\n\n(3) 缓存存储路径默认在 ~/.ccache，可通过环境变量修改：\n设置缓存存储到指定路径（默认在 ~/.ccache）export CCACHE_DIR=/path/to/your/cache\n","categories":["学习"],"tags":["资料"]}]