[{"title":"祝chq生日快乐！！！","url":"/2024/10/14/chq-birthday/","content":"\n\n放一首可能不是他最喜欢的但是应该还是比较合适的歌\n\n\n\n\n\n\n祝chq生日快乐！！\n\n\n刷新一下显示滚动彩色祝福语\n\n  \n    \n  \n    var binft = function (r) {\n      function t() {\n        return b[Math.floor(Math.random() * b.length)]\n      }  \n      function e() {\n        return String.fromCharCode(94 * Math.random() + 33)\n      }\n      function n(r) {\n        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {\n          var l = document.createElement(\"span\");\n          l.textContent = e(), l.style.color = t(), n.appendChild(l)\n        }\n        return n\n      }\n      function i() {\n        var t = o[c.skillI];\n        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)\n      }\n      var l = \"\",\n      o = [\"祝chq生日快乐！！！！！！\",\"希望二十岁的你可以爱你所爱\",\"做自己喜欢的事\"].map(function (r) {\n      return r + \"\"\n      }),\n      a = 15,//文字保留时间\n      g = 1,//文字出现速度 越大越慢\n      s = 4,//乱码长度\n      d = 50,//单个乱码展示时间\n      b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n      c = {\n        text: \"\",\n        prefixP: -s,\n        skillI: 0,\n        skillP: 0,\n        direction: \"forward\",\n        delay: a,\n        step: g\n      };\n      i()\n      };\n      binft(document.getElementById('binft'));\n   \n","categories":["记录生活"],"tags":["杂谈"]},{"title":"祝birdking生日快乐！！！","url":"/2024/10/28/birdking-is-so-cool/","content":"\n\n急着睡觉，就先祝他生日快乐吧 !\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"算法题的错题整理及反思","url":"/2024/10/27/algorithm/","content":"这是关于算法题的错题整理及反思题目来源不一定，主要来源应该是CF、洛谷等\n也会包含一些关于比赛的反思等\n水平较低哈哈哈哈哈哈哈哈哈，还在尝试中\n\nCodeforces Round 982 (Div. 2) B标签：\n\n\n暴力枚举（brute force）\n贪心（greedy）\n\n\n题目：\n\n\nProblem-B-Codeforces\nStalin Sort-洛谷\n\n\n题目大意\n\n给出一个数组，问是否可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的。\n*子数组指的是任意一段连续子数组，斯大林排序指将严格降序的元素剔除，具体定义见题目\n\n思路分析：\n\n通过斯大林排序的定义可知\n\n任何一段数组进行斯大林排序后第一个元素都不会改变\n\n如果处理完的数组元素大于等于两个，则按非降序排列\n\n\n进一步分析\n\n对于使用斯大林排序的任意子数组，如果存在大于第一个元素的其他元素则会被保留，而小于第一个元素的一定会被剔除因此要使最后是非降序的，就必须要把子数组中大于第一个元素的其他元素都剔除掉\n那么要使剔除后的数组是可以通过对其任意子数组进行多次斯大林排序，使得最终的数组是非增的就要使剔除后的数组的首元素最大\n接下来只需要从头遍历整个数组，找到有最多元素的满足首元素最大的数组（不一定连续）即可\n即对数组中的每个元素寻找有多少个（k）在他之后的不大于他的元素，并记录下最大值（f）\n将元素总个数减去（最大值+1）就是其他要剔除的元素的个数\n\n\n\n        \n            \n            \n            可能的疑问\n\n        \n        \n问题一：对每个元素只考虑后面的其他元素，为什么不用考虑前面的其他元素就把他们全部剔除\n答：\n\n如果前面的元素大于等于该元素，则前面元素遍历时的值k1就会大于该值k2，那么f就会等于k1，不影响\n如果前面的元素小于该元素，则必须剔除，否则剔除后的数组的首元素就不是最大的，那么就不满足要求\n\n\n\n        \n\n思路误区：\n\n比赛时想的是减序列通过斯大林排序一定会消失，所以先对整个数组进行一次斯大林排序，得到非减序列，再把第一次出现的最大值前的元素全部剔除掉，那么剩下的就是非增序列了，问题在于在第一次通过斯大林排序时删掉的元素仍在剔除元素后的数组之中，此时数组还可能存在递增序列，不满足题意很烦的是样例给的随便过，比赛时一直没找到问题所在\n\n代码：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    int t;    cin &gt;&gt; t; // 读取测试用例数量      while (t--)    &#123;        int n;        cin &gt;&gt; n;        int* a = new int[n + 1];        for (int i = 0; i &lt; n; i++)        &#123;            cin &gt;&gt; a[i];        &#125;        int f = 0;        for (int i = 0; i &lt; n - 1; i++)        &#123;            int k = 0;            for (int j = i + 1; j &lt; n; j++)            &#123;                if (a[j] &lt;= a[i])                    k++;            &#125;            f = max(f, k);        &#125;        cout &lt;&lt; n - (f + 1) &lt;&lt; endl;        delete[] a;    &#125;    return 0;&#125;\n\n\n\n","categories":["学习"],"tags":["算法","错题整理"]},{"title":"杂谈","url":"/2024/02/09/my-first-blog/","content":"这是我的第一个博客嘿嘿嘿\n\n\n这是我的第一个 Blog\n但是我不知道写什么哈哈哈哈哈\n\n\n目前还在测试中\n\n\n如果你感觉无聊你可以看看B站 \n\n关于后续后续我将会发布有关于IT技术、生活等方面的内容，不过我觉得应该不会有什么人看的，所以水一水(雾)。\n关于为什么写博客有两个理由，一个是为了装*，另一个还是为了装*哈哈哈哈哈哈哈哈哈。\n\n好了，正经一点\n\n其实是因为看见大神学长写博客所以突发奇想，想给自己做一个博客(好像还是不是什么正经理由嘿嘿嘿)\n\n时间有点来不及了，还有挺多事要做的，所以先写到这儿吧，现在要发布了(希望能发布成功)\n附一张我最爱的小猪的照片：\n \n再附一张铃兰和罗小黑的动图：\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"对内容进行了一些完善","url":"/2024/10/05/add-something-new/","content":"\n\n\n因为闲着所以试一些有意思的小玩意儿,不知道有没有人看得到哈哈哈哈哈哈 \n首先就是使用了隐藏文本\n以后可以说一些悄悄话了（）\n新增了跳转链接尝试与 Rhodes Island™ 取得弱神经连接：\n\n        \n        Rhodes Island™'与  Rhodes  Island™  取得弱神经连接'\n\n想添加自己的链接可以联系我\n新增了音乐播放器放一首我听得最多的\n&nbsp;\n\n思绪绵绵呀\n新增了一只噬元兽没错，就是左下角这一只（不知道你们有没有看到，毕竟隐身了）\n在添加的过程中看到有个博客有罗小黑的桌宠，本来打算也添加一个的，但是忘记收藏，导致现在找不到那个博客了。后来我也在B站上找到了lpk文件，尝试了一上午加半个下午，仍然不知道怎么添加，只能作罢。。（如果有谁看到那个用了罗小黑的博客或者知道怎么在web上使用lpk文件，请联系我，不胜感激）\n新增了本站运行时间在右下角哟\n特意把时间设置成北京时间，可以当作时钟（我多贴心）\n\n新增了点击特效就用《起风了》的歌词吧 不要问我为什么，多听几遍就知道了\n希望你们喜欢\n点下去的时候是烟花，松开的时候是歌词，有个时间差更容易看见歌词（可以等烟花散了再松开）\n\n新增了彩色滚动字体  \n    \n  \n    var binft = function (r) {\n      function t() {\n        return b[Math.floor(Math.random() * b.length)]\n      }  \n      function e() {\n        return String.fromCharCode(94 * Math.random() + 33)\n      }\n      function n(r) {\n        for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {\n          var l = document.createElement(\"span\");\n          l.textContent = e(), l.style.color = t(), n.appendChild(l)\n        }\n        return n\n      }\n      function i() {\n        var t = o[c.skillI];\n        c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)\n      }\n      var l = \"\",\n      o = [\"这一路上走走停停\",\"顺着少年漂流的痕迹\",\"迈出车站的前一刻\",\"竟有些犹豫\",\"不禁笑这近乡情怯\",\"仍无法避免\",\"而长野的天\",\"依旧那么暖\",\"风吹起了从前\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不得真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"逆着光行走 任风吹雨打\",\"短短的路走走停停\",\"也有了几分的距离\",\"不知抚摸的是故事\",\"还是段心情\",\"也许期待的不过是\",\"与时间为敌\",\"再次见到你\",\"微凉晨光里\",\"笑得很甜蜜\",\"从前初识这世间\",\"万般流连\",\"看着天边似在眼前\",\"也甘愿赴汤蹈火去走它一遍\",\"如今走过这世间\",\"万般流连\",\"翻过岁月不同侧脸\",\"措不及防闯入你的笑颜\",\"我曾难自拔于世界之大\",\"也沉溺于其中梦话\",\"不做真假 不做挣扎 不惧笑话\",\"我曾将青春翻涌成她\",\"也曾指尖弹出盛夏\",\"心之所动 且就随缘去吧\",\"晚风吹起你鬓间的白发\",\"抚平回忆留下的疤\",\"你的眼中 明暗交杂 一笑生花\",\"暮色遮住你蹒跚的步伐\",\"走进床头藏起的画\",\"画中的你 低着头说话\",\"我仍感叹于世界之大\",\"也沉醉于儿时情话\",\"不剩真假 不做挣扎 无谓笑话\",\"我终将青春还给了她\",\"连同指尖弹出的盛夏\",\"心之所动 就随风去了\",\"以爱之名 你还愿意吗\"].map(function (r) {\n      return r + \"\"\n      }),\n      a = 15,//文字保留时间\n      g = 1,//文字出现速度 越大越慢\n      s = 4,//乱码长度\n      d = 50,//单个乱码展示时间\n      b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n      c = {\n        text: \"\",\n        prefixP: -s,\n        skillI: 0,\n        skillP: 0,\n        direction: \"forward\",\n        delay: a,\n        step: g\n      };\n      i()\n      };\n      binft(document.getElementById('binft'));\n   \n\n\n\n\n本来彩色滚动字体会导致下面的界面发生跳动，在外面套上div后修好了\n\n改进了折叠文本\n        \n            \n            \n            明日方舟语录\n\n        \n        是棋子，那就吃掉；是堡垒，那就攻陷；是王权，那就推翻。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——《明日方舟》觉得很霸气所以选这一句\n\n        \n\n\n\n\n杂记\n昨天成功捕捉噬元兽，带着她去看了尾巴的伤口并顺带做了绝育\n\n \n\n\n\n伤的挺严重的，已经感染了，幸好及时送到医院\n\n \n\n\n最后再附上几张 令 的图作为结束吧\n\n\n\n\n\n令 还是挺帅的\n\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"感谢大家","url":"/2024/10/02/thx/","content":"\n感谢我身边的大家，本博客的搭建离不开大家的建议和帮助。\n\n\n特此鸣谢\n","categories":["记录生活"],"tags":["杂谈"]},{"title":"C++ STL常用内容总结","url":"/2024/10/29/stl/","content":"说明这是关于C++ STL常用内容总结\n强调使用方法，并不强调原理\n本篇博客是我用于个人学习总结用的\n\n\n大部分内容来源于网络和书本，因为是个人整理复习用所以就先不加了，如果后期看的人多我会加上的\n因为还有挺多课的，而且还有比赛和组里的任务，所以可能会不定期不定量更新\n内容可能有不全的，或错误的，欢迎批评指正\n目录主要包含下面几个STL函数\n\n\nvector 动态数组\nstack 栈\nqueue 队列\ndeque 双端队列\npriority_queue 优先队列\nmap 映射\nset 集合\npair 二元组\nstring 字符串\nbitset\narray 数组\ntuple 元组\n……\n\n\n这是目前的安排，计划在11.03前赶完，因为11.03要比赛，11.10还要考离散，中间还要把几次练习赛的题补了。（好忙）\n目前（11.02）已将上述STL函数整理完成，算是按时提前完成了吧\n后续会增加一些常用的STL函数，例如sort等\n暂定在12.20前完成后续的补充\n话不多说，接下来进入正题吧\nSTL函数总结vector 动态数组介绍vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。\n\n注意：在局部区域中（比如局部函数里面）开vector数组，是在 堆空间 里面开的。\n在局部区域开 数组 是在 栈空间 开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。\n故局部区域 不可以 开大长度数组，但是可以开大长度vector。\n\n\n头文件：\n#include &lt;vector&gt;\n\n一维初始化：\nvector&lt;int&gt; a; //定义了一个名为a的一维数组,数组存储int类型数据vector&lt;double&gt; b;//定义了一个名为b的一维数组，数组存储double类型数据vector&lt;node&gt; c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型\n\n指定长度和初始值的初始化\nvector&lt;int&gt; v(n);// 定义一个长度为n的数组，初始值默认为0，下标范围 [0, n - 1]vector&lt;int&gt; v(n, 1);//定义一个长度为n的数组，下标范围 [0, n - 1], v[0] 到 v[n - 1]所有的元素初始值均为1//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）\n\n初始化中有多个元素\nvector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//数组a中有五个元素，数组长度就为5\n\n拷贝初始化\nvector&lt;int&gt; a(n + 1, 0);vector&lt;int&gt; b(a); // 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组vector&lt;int&gt; c = a; // 也是拷贝初始化,c和a是完全一样的数组\n\n二维初始化\n//定义第一维固定长度为5，第二维可变化的二维数组vector&lt;int&gt; v[5];//定义可变长二维数组//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素//第一维固定长度为5，第二维长度可以改变\n\n\nvector&lt;int&gt; v[5]可以这样理解：长度为5的v数组，数组中存储的是vector&lt;int&gt; 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：\nv[1].push_back(2);//第二行尾部增加一个元素 2v[2].push_back(3);//第三行尾部增加一个元素 3\n\n\n行列均可变\n//初始化二维均可变长数组vector&lt;vector&lt;int&gt;&gt; v;//定义一个行和列均可变的二维数组\n\n\n应用：可以在v数组里面装多个数组\nvector&lt;int&gt; t1&#123;1, 2, 3, 4&#125;;vector&lt;int&gt; t2&#123;2, 3, 4, 5&#125;;v.push_back(t1);v.push_back(t2);v.push_back(&#123;3, 4, 5, 6&#125;) // &#123;3, 4, 5, 6&#125;可以作为vector的初始化,相当于一个无名vector\n\n\n行列长度均固定\n\nn + 1行  m + 1列  初始值为0\nvector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//定义一个长度为 n+1 的数组，下标范围 [0, n - 1], a[0] 到 a[n - 1]所有的元素初始值均为vector&lt;int&gt;(m + 1, 0)\n\n\nc++17及以上支持的形式（定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数）\nvector a&#123;1, 2, 3, 4, 5&#125;; // 声明一个int类型动态数组，初识元素自己指定vector a(n + 1, vector(m + 1, 0));\n\n方法函数个人认为vector和数组的差距首先是存储位置不一样，vector是在堆空间，数组是在栈空间，其次就是vector中有许多方法函数，这些方法函数可以极大的方便我们编程，解题，不仅仅vector是这样的，其他STL函数也是。但是因为我才刚刚入门，这只是我的一种感觉，具体怎么等我多学一些，学深一些再来补充。先占个坑。\n知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。\nc指定为数组名称，含义中会注明算法复杂度。\n\n\n\n代码\n含义\n\n\n\nc.front()\n返回第一个数据O ( 1 )\n\n\nc.back()\n返回数组中的最后一个数据 O ( 1 )\n\n\nc.pop_back()\n删除最后一个数据O ( 1 )\n\n\nc.push_back(element)\n在尾部加一个数据O ( 1 )\n\n\nc.size()\n返回实际数据个数（unsigned类型）O ( 1 )\n\n\nc.clear()\n清除元素个数O ( N )，N为元素个数\n\n\nc.resize(n, v)\n改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0\n\n\nc.insert(it, x)\n向任意迭代器it（通俗来说就是地址）插入一个元素x ，O ( N )\n\n\nc.erase(first,last)\n删除[first,last)的所有元素，O ( N )\n\n\nc.begin()\n返回首元素的迭代器（通俗来说就是地址）O ( 1 )\n\n\nc.end()\n返回最后一个元素后一个位置的迭代器（地址）O ( 1 )\n\n\nc.empty()\n判断是否为空，为空返回真，反之返回假 O ( 1 )\n\n\n\n注意：\n\nend()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此\n\n使用 vi.resize(n, v) 函数时，若 vi 之前指定过大小为 pre\n\npre &gt; n ：即数组大小变小了，数组会保存前 n 个元素，前 n 个元素值为原来的值，不都变为 v\npre &lt; n ：即数组大小变大了，数组会在后面插入 n - pre 个值为 v 的元素\n\n也就是说，这个初始值 v 只对新插入的元素生效。\n#include&lt;bits/stdc++.h&gt;using namespace std;void out(vector&lt;int&gt; &amp;a) &#123; for (auto &amp;x: a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;\\n&quot;; &#125;int main() &#123;\tvector&lt;int&gt; a(5, 1);\tout(a); // 1 1 1 1 1\ta.resize(10, 2);\tout(a); // 1 1 1 1 1 2 2 2 2 2\ta.resize(3, 3);\tout(a); // 1 1 1\treturn 0;&#125;\n\n\n排序\n使用sort排序要： sort(c.begin(), c.end());\n\nsort()为STL函数，请参考本文最后面STL函数系列。\n\n对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。\nvector&lt;int&gt; a(n + 1);sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序\n\n访问共三种方法：\n\n下标法 ： 和普通数组一样\n\n注意：一维数组的下标是从 0 到 v.size()-1 ，访问之外的数会出现越界错误\n\n迭代器法 ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置\n\n使用auto ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）\n\n\n下标访问直接和普通数组一样进行访问即可。\n//添加元素for(int i = 0; i &lt; 5; i++)\tvi.push_back(i);\t//下标访问 for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n迭代器访问类似指针，迭代器就是充当指针的作用。\nvector&lt;int&gt; vi&#123;1, 2, 3, 4, 5&#125;;//迭代器访问vector&lt;int&gt;::iterator it;   // 相当于声明了一个迭代器类型的变量it// 通俗来说就是声明了一个指针变量\n\n\n方法一\nvector&lt;int&gt;::iterator it = vi.begin(); for(int i = 0; i &lt; 5; i++)\tcout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;;\n\n方法二\nvector&lt;int&gt;::iterator it;for(it = vi.begin(); it != vi.end();it ++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;//vi.end()指向尾元素地址的下一个地址// 或者auto it = vi.begin();while (it != vi.end()) &#123;    cout &lt;&lt; *it &lt;&lt; &quot;\\n&quot;;    it++;&#125;\n\n智能指针只能遍历完数组，如果要指定的内容进行遍历，需要另选方法。\nauto 能够自动识别并获取类型。\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;    cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// for (auto &amp;x: a)：这是一个范围for循环，用于遍历向量a中的每个元素。auto关键字自动推导变量x的类型，这里x的类型将是int&amp;（整数的引用），因为我们在循环中使用了引用&amp;。使用引用的好处是可以直接修改向量中的元素值。// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;\tcout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\n\n\nvector注意：\n\nvi[i] 和 *(vi.begin() + i) 等价，与指针类似。\nvector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。\n\n\nstack 栈介绍栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。\n\n头文件\n//头文件需要添加#include&lt;stack&gt;\n\n声明\n//声明stack&lt;int&gt; s;stack&lt;string&gt; s;stack&lt;node&gt; s;//node是结构体类型\n\n方法函数\n\n\n代码\n含义\n\n\n\ns.push(ele)\n元素ele入栈，增加元素 O ( 1 )\n\n\ns.pop()\n移除栈顶元素 O ( 1 )\n\n\ns.top()\n取得栈顶元素（但不删除）O ( 1 )\n\n\ns.empty()\n检测栈内是否为空，空为真 O ( 1 )\n\n\ns.size()\n返回栈内元素的个数 O ( 1 )\n\n\n栈遍历栈遍历栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中\nstack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) &#123;    int tp = st.top(); // 栈顶元素    st.pop();&#125;\n\n数组模拟栈进行遍历通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n特点： 比STL的stack速度更快，遍历元素方便\nint s[100]; // 栈 从左至右为栈底到栈顶int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1for(int i = 0; i &lt;= 5; ++i) &#123;\t//入栈 \ts[++tt] = i;&#125;// 出栈int top_element = s[tt--]; //入栈操作示意//  0  1  2  3  4  5  //                tt//出栈后示意//  0  1  2  3  4 //              tt\n\nqueue 队列介绍队列是一种先进先出的数据结构。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n定义初始化\n//定义初始化queue&lt;int&gt; q;\n\n方法函数\n\n\n代码\n含义\n\n\n\nq.front()\n返回队首元素 O ( 1 )\n\n\nq.back()\n返回队尾元素 O ( 1 )\n\n\nq.push(element)\n尾部添加一个元素element 进队O ( 1 )\n\n\nq.pop()\n删除第一个元素 出队 O ( 1 )\n\n\nq.size()\n返回队列中元素个数，返回值类型unsigned int O ( 1 )\n\n\nq.empty()\n判断是否为空，队列为空，返回true O ( 1 )\n\n\n队列模拟使用q[]数组模拟队列\nhh表示队首元素的下标，初始值为0\ntt表示队尾元素的下标，初始值为-1，表示刚开始队列为空\n\n一般来说单调栈和单调队列写法均可使用额外变量 tt 或 hh 来进行模拟\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int q[N];int main() &#123;\tint hh = 0,tt = -1;//\t入队 \tq[++tt] = 1;\tq[++tt] = 2; //\t将所有元素出队 \twhile(hh &lt;= tt) &#123;\t\tint t = q[hh++];\t\tprintf(&quot;%d &quot;,t);\t&#125;\treturn 0; &#125; \n\ndeque  双端队列介绍首尾都可插入和删除的队列为双端队列。\n\n头文件\n//添加头文件#include&lt;deque&gt;\n\n初始化定义\n//初始化定义deque&lt;int&gt; dq;\n\n方法函数\n注意双端队列的常数比较大。\n\n\n\n\n代码\n含义\n\n\n\npush_back(x)&#x2F;push_front(x)\n把x插入队尾后 &#x2F; 队首 O ( 1 )\n\n\nback()&#x2F;front()\n返回队尾 &#x2F; 队首元素 O ( 1 )\n\n\npop_back() &#x2F; pop_front()\n删除队尾 &#x2F; 队首元素 O ( 1 )\n\n\nerase(iterator it)\n删除双端队列中的某一个元素\n\n\nerase(iterator first,iterator last)\n删除双端队列中[first,last)中的元素\n\n\nempty()\n判断deque是否空 O ( 1 )\n\n\nsize()\n返回deque的元素数量 O ( 1 )\n\n\nclear()\n清空deque\n\n\n注意点deque可以进行排序\n\n双端队列排序一般不用，感觉毫无用处，使用其他STL依然可以实现相同功能\n\n//从小到大sort(q.begin(), q.end())//从大到小排序sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型sort(q.begin(), q.end(), greater());//高版本C++才可以用\n\npriority_queue 优先队列介绍优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。\n可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。\n它的底层是通过堆来实现的。\n\n头文件\n//头文件#include&lt;queue&gt;\n\n初始化\n//初始化定义priority_queue&lt;int&gt; q;\n\n函数方法\n\n\n代码\n含义\n\n\n\nq.top()\n访问队首元素 O ( 1 )\n\n\nq.push()\n入队 O ( l o g N )\n\n\nq.pop()\n堆顶（队首）元素出队 O ( l o g N )\n\n\nq.size()\n队列元素个数 O ( 1 )\n\n\nq.empty()\n是否为空 O ( 1 )\n\n\n注意没有clear()！不提供该方法\n优先队列只能通过top()访问队首元素（优先级最高的元素）\n设置优先级基本数据类型的优先级priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小根堆, 每次取出的元素是队列中的最小值\n\n参数解释：\n\n第一个参数：就是优先队列中存储的数据类型\n\n第二个参数：\nvector&lt;int&gt; 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector&lt;double&gt;总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。\n\n第三个参数：\nless&lt;int&gt; 表示数字大的优先级大，堆顶为最大的数字greater&lt;int&gt;表示数字小的优先级大，堆顶为最小的数字int代表的是数据类型，也要填优先队列中存储的数据类型\n\n\n\n\n基础写法（非常常用）：\npriority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值\n\n自定义排序（不常见，主要是写着麻烦）：\n下面的代码比较长，基础类型优先级写着太麻烦，用基础写法即可。\nstruct cmp1 &#123;\tbool operator()(int x, int y) &#123;\t\treturn x &gt; y;\t&#125;&#125;;struct cmp2 &#123;\tbool operator()(const int x, const int y) &#123;\t\treturn x &lt; y;\t&#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆\n\n高级数据类型(结构体)优先级\n即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。\n\n优先级设置可以定义在结构体内进行小于号重载，也可以定义在结构体外。\n//要排序的结构体（存储在优先队列里面的）struct Point &#123;\tint x, y;&#125;;\n\n\n版本一：自定义全局比较规则\n//定义的比较结构体//注意：cmp是个结构体 struct cmp &#123;//自定义堆的排序规则 \tbool operator()(const Point&amp; a,const Point&amp; b) &#123;\t\treturn a.x &lt; b.x;\t&#125;&#125;;//初始化定义， priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; // x大的在堆顶\n\n版本二：直接在结构体里面写\n\n因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。\n\n结构体内部有两种方式：\n\n方式一 ：\nstruct node &#123;\tint x, y;\tfriend bool operator &lt; (Point a, Point b) &#123;//为两个结构体参数，结构体调用一定要写上friend\t\treturn a.x &lt; b.x;//按x从小到大排，x大的在堆顶\t&#125;&#125;;\n\n方式二 ：（推荐此种）\nstruct node &#123;    int x, y;    bool operator &lt; (const Point &amp;a) const &#123;//直接传入一个参数，不必要写friend        return x &lt; a.x;//按x升序排列，x大的在堆顶    &#125;&#125;;\n\n优先队列的定义\npriority_queue&lt;Point&gt; q;\n\n注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是完全相反的。所以只需要记住sort的排序规则和优先队列的排序规则是相反的就可以了。\n\n当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 &gt; ，那么孩子节点要大于父亲节点，堆顶自然是最小值。\n\n\n\n\n\n存储特殊类型的优先级存储pair类型\n排序规则：默认先对pair的first进行降序排序，然后再对second降序排序对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    priority_queue&lt;pair&lt;int, int&gt; &gt;q;\tq.push(&#123;7, 8&#125;);\tq.push(&#123;7, 9&#125;);\tq.push(make_pair(8, 7));    while(!q.empty()) &#123;        cout &lt;&lt; q.top().first &lt;&lt; &quot; &quot; &lt;&lt; q.top().second &lt;&lt; &quot;\\n&quot;;        q.pop();    &#125;    return 0;&#125;\n\n\n结果：8 77 97 8\n\n\n\nmap 映射介绍映射类似于函数的对应关系，每个x对应一个y，而map是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。\n\n比如说：学习 对应 看书，学习 是键，看书 是值。学习-&gt;看书玩耍 对应 打游戏，玩耍 是键，打游戏 是值。玩耍-&gt;打游戏\n\n\n头文件\n//头文件#include&lt;map&gt;\n\n初始化\n//初始化定义map&lt;string, string&gt; mp;map&lt;string, int&gt; mp;map&lt;int, node&gt; mp;//node是结构体类型\n\n\nmap特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n\n\n\n函数方法\n\n\n代码\n含义\n\n\n\nmp.find(key)\n返回键为key的映射的迭代器 $O(logN) $ 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end ( )\n\n\nmp.erase(it)\n删除迭代器对应的键和值 O ( l o g N )\n\n\nmp.erase(key)\n根据映射的键删除键和值 O ( l o g N )\n\n\nmp.erase(first,last)\n删除左闭右开区间迭代器对应的键和值 O ( l a s t − f i r s t )\n\n\nmp.size()\n返回映射的对数 O (1)\n\n\nmp.clear()\n清空map中的所有元素 O ( N )\n\n\nmp.insert()\n插入元素，插入时要构造键值对\n\n\nmp.empty()\n如果map为空，返回true，否则返回false\n\n\nmp.begin()\n返回指向map第一个元素的迭代器（地址）\n\n\nmp.end()\n返回指向map尾部的迭代器（最后一个元素的下一个地址）\n\n\nmp.rbegin()\n返回指向map最后一个元素的迭代器（地址）\n\n\nmp.rend()\n返回指向map第一个元素前面(上一个）的逆向迭代器（地址）\n\n\nmp.count(key)\n查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0\n\n\nmp.lower_bound()\n返回一个迭代器，指向键值&gt;&#x3D; key的第一个元素\n\n\nmp.upper_bound()\n返回一个迭代器，指向键值&gt; key的第一个元素\n\n\n注意下面说明部分函数方法的注意点\n\n注意：查找元素是否存在时，可以使用①mp.find() ② mp.count() ③ mp[key]但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间）所以为了不增加额外的空间负担，最好使用前两种方法\n\n迭代器进行正反向遍历\nmp.begin()和mp.end()用法：\n用于正向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.begin();while(it != mp.end()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n1 22 33 4\n\nmp.rbegin()和mp.rend()用法：\n用于逆向遍历map\nmap&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.rbegin();while(it != mp.rend()) &#123;\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\tit ++;&#125;\n\n结果：\n3 42 31 2\n\n二分查找二分查找lower_bound() upper_bound()\n\nmap的二分查找以第一个元素（即键为准），对键进行二分查找返回值为map迭代器类型\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tmap&lt;int, int&gt; m&#123;&#123;1, 2&#125;, &#123;2, 2&#125;, &#123;1, 2&#125;, &#123;8, 2&#125;, &#123;6, 2&#125;&#125;;//有序\tmap&lt;int, int&gt;::iterator it1 = m.lower_bound(2);\tcout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\\n&quot;;//it1-&gt;first=2\tmap&lt;int, int&gt;::iterator it2 = m.upper_bound(2);\tcout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\\n&quot;;//it2-&gt;first=6\treturn 0;&#125;\n\n添加元素//先声明map&lt;string, string&gt; mp;\n\n\n方式一：\nmp[&quot;学习&quot;] = &quot;看书&quot;;mp[&quot;玩耍&quot;] = &quot;打游戏&quot;;\n\n方式二：插入元素构造键值对\nmp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));\n\n方式三：\nmp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));\n\n方式四:\nmp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);\n\n访问元素下标访问(大部分情况用于访问单个元素)\nmp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\\n&quot;;//只是简写的一个例子，程序并不完整\n\n遍历访问\n方式一：迭代器访问\nmap&lt;string,string&gt;::iterator it;for(it = mp.begin(); it != mp.end(); it++) &#123;\t//      键                 值 \t// it是结构体指针访问所以要用 -&gt; 访问\tcout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\t//*it是结构体变量 访问要用 . 访问\t//cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;&#125;\n\n方式二：智能指针访问\nfor(auto i : mp)cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值\n\n方式三：对指定单个元素访问\nmap&lt;char,int&gt;::iterator it = mp.find(&#x27;a&#x27;);cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\\n&quot;;\n\n方式四：c++17特性才具有\nfor(auto [x, y] : mp)\tcout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\\n&quot;;//x,y对应键和值\n\n与unordered_map的比较这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n内部实现原理map：内部用红黑树实现，具有自动排序（按键从小到大）功能。\nunordered_map：内部用哈希表实现，内部元素无序杂乱。\n效率比较map：\n\n优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N)\n缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。\n\nunordered_map：\n\n优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n缺点：建立哈希表比较耗时。\n\n\n两者方法函数基本一样，差别不大。\n注意：\n\n随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n\n使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。\n\n查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n// 以 map 为例map&lt;int, int&gt; mp;int x = 999999999;if(mp.count(x)) // 此处判断是否存在x这个键    cout &lt;&lt; mp[x] &lt;&lt; &quot;\\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建\n\n\n另外：\n\n还有一种映射：multimap\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n\nset 集合介绍set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n即：set里面的元素不重复 且有序\n\n头文件\n//头文件#include&lt;set&gt;\n\n初始化\n//初始化定义set&lt;int&gt; s;\n\n函数方法\n\n\n代码\n含义\n\n\n\ns.begin()\n返回set容器的第一个元素的地址（迭代器）O ( 1 )\n\n\ns.end()\n返回set容器的最后一个元素的下一个地址（迭代器）O ( 1 )\n\n\ns.rbegin()\n返回逆序迭代器，指向容器元素最后一个位置O ( 1 )\n\n\ns.rend()\n返回逆序迭代器，指向容器第一个元素前面的位置O ( 1 )\n\n\ns.clear()\n删除set容器中的所有的元素\n\n\ns.empty()\n判断set容器是否为空O ( 1 )\n\n\ns.insert()\n插入一个元素\n\n\ns.size()\n返回当前set容器中的元素个数O ( 1 )\n\n\nerase(iterator)\n删除定位器iterator指向的值\n\n\nerase(first,second）\n删除定位器first和second之间的值\n\n\nerase(key_value)\n删除键值key_value的值\n\n\ns.find(element)\n查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器\n\n\ns.count(element)\n查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现\n\n\ns.lower_bound(k)\n返回&gt;&#x3D;k的第一个元素的迭代器O ( l o g N )\n\n\ns.upper_bound(k)\n返回&gt;k的第一个元素的迭代器O ( l o g N )\n\n\n访问\n迭代器访问\nfor(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n智能指针\nfor(auto i : s)\tcout &lt;&lt; i &lt;&lt; endl;\n\n访问最后一个元素\n//第一种cout &lt;&lt; *s.rbegin() &lt;&lt; endl;\n\n //第二种set&lt;int&gt;::iterator iter = s.end();iter--;cout &lt;&lt; (*iter) &lt;&lt; endl; //打印2;\n\n//第三种cout &lt;&lt; *(--s.end()) &lt;&lt; endl;\n\n重载&lt;运算符\n基础数据类型\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\nset&lt;int&gt; s1; // 默认从小到大排序set&lt;int, greater&lt;int&gt; &gt; s2; // 从大到小排序\n\n方式二：重载运算符。（很麻烦，不太常用，没必要）\n//重载 &lt; 运算符struct cmp &#123;    bool operator () (const int&amp; u, const int&amp; v) const &#123;       // return + 返回条件       return u &gt; v;    &#125;&#125;;set&lt;int, cmp&gt; s; for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto i : s)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;// 10 9 8 7 6 5 4 3 2 1\n\n方式三：初始化时使用匿名函数定义比较规则\nset&lt;int, function&lt;bool(int, int)&gt;&gt; s([&amp;](int i, int j)&#123;    return i &gt; j; // 从大到小&#125;);for(int i = 1; i &lt;= 10; i++)    s.insert(i);for(auto x : s)    cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n\n高级数据类型（结构体）\n直接重载结构体运算符即可，让结构体可以比较。\nstruct Point &#123;\tint x, y;\tbool operator &lt; (const Point &amp;p) const &#123;\t\t// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\t\tif(x == p.x)\t\t\treturn y &lt; p.y;\t\treturn x &lt; p.x;\t&#125;&#125;;set&lt;Point&gt; s;for(int i = 1; i &lt;= 5; i++) &#123;    int x, y;    cin &gt;&gt; x &gt;&gt; y;    s.insert(&#123;x, y&#125;);&#125;\t/* 输入5 45 23 73 54 8*/for(auto i : s)    cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;/* 输出3 53 74 85 25 4*/\n\n其它setmultiset:元素可以重复，且元素有序\nunordered_set ：元素无序且只能出现一次\nunordered_multiset ： 元素无序可以出现多次\npair 二元组介绍pair只含有两个元素，可以看作是只有两个元素的结构体。\n应用：\n\n头文件\n//头文件#include&lt;utility&gt;\n\n初始化\n//1.初始化定义pair&lt;string, int&gt; p(&quot;zenith32&quot;,1);//带初始值的pair&lt;string, int&gt; p;//不带初始值的\n\n赋值\n//2.赋值p = &#123;&quot;zenith32&quot;, 18&#125;;p = make_pair(&quot;zenith32&quot;, 18);p = pair&lt;string, int&gt;(&quot;zenith32&quot;, 18);\n\n代替二元结构体\n\n作为map键值对进行插入（代码如下）\nmap&lt;string, int&gt; mp;mp.insert(pair&lt;string, int&gt;(&quot;zenith32&quot;,1));// mp.insert(make_pair(&quot;zenith32&quot;, 1));// mp.insert(&#123;&quot;zenith32&quot;, 1&#125;);\n\n访问//定义结构体数组pair&lt;int,int&gt; p[20];for(int i = 0; i &lt; 20; i++) &#123;\t//和结构体类似，first代表第一个元素，second代表第二个元素\tcout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;&#125;\n\nstring 字符串介绍string是一个字符串类，和char型字符串类似。\n可以把string理解为一个字符串类型，像int一样可以定义\n初始化及定义\n头文件\n//头文件#include&lt;string&gt;\n\n初始化\n//1.string str1; //生成空字符串//2.string str2(&quot;123456789&quot;); //生成&quot;123456789&quot;的复制品 //3.string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3//4.string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5//5.string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串//6.string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后\n\n访问单个字符：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s = &quot;zenith!!!&quot;;\tfor(int i = 0; i &lt; s.size(); i++)\t\tcout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;\treturn 0;&#125;\n\nstring数组使用：\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123;\tstring s[10];\tfor(int i = 1; i &lt; 10; i++) &#123;\t\ts[i] = &quot;loading...  &quot; ;\t\tcout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\\n&quot;;\t&#125; \treturn 0;&#125;//结果://loading...  1//loading...  2//loading...  3//loading...  4//loading...  5//loading...  6//loading...  7//loading...  8//loading...  9\n\nstring 特性\n支持比较运算符\nstring字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），支持string与C-string的比较（如 str &lt; “hello”）。\n在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按 字典顺序 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。\n同时，string (&quot;aaaa&quot;) &lt;string(&quot;aaaaa&quot;)。\n\n支持+运算符，代表拼接字符串string字符串可以拼接，通过”+”运算符进行拼接。\nstring s1 = &quot;123&quot;;string s2 = &quot;456&quot;;string s = s1 + s2;cout &lt;&lt; s;   //123456\n\n读入详解读入字符串，遇空格，回车结束\nstring s;cin &gt;&gt; s;\n\n读入一行字符串（包括空格），遇回车结束\nstring s;getline(cin, s);\n\n注意: getline(cin, s)会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：getchar() 或 cin.get()\n错误读取：\nint n;string s;cin &gt;&gt; n;getline(cin, s); //此时读取相当于读取了前一个回车字符\n\n正确读取：\nint n;string s;cin &gt;&gt; n;getchar(); //cin.get() 读取前一个回车字符getline(cin, s);//可正确读入下一行的输入\n\n\ncin与cin.getline()混用\ncin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致getline()读取回车，结束。需要在cin后面加cin.ignore()；主动删除输入流中的换行符。（不常用）\n\ncin和cout解锁\n代码（写在main函数开头）：\nios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n\n\n为什么要进行cin和cout的解锁，原因是：\n在一些题目中，读入的数据量很大，往往超过了1e5（105）的数据量,而cin和cout的读入输出的速度很慢（是因为cin和cout为了兼容C语言的读入输出在性能上做了妥协），远不如scanf和printf的速度，具体原因可以搜索相关的博客进行了解。\n所以对cin和cout进行解锁使cin和cout的速度几乎接近scanf和printf，避免输入输出超时。\n\n注意：cin cout解锁使用时，不能与 scanf,getchar, printf,cin.getline()混用，一定要注意，会出错。\n\nstring与C语言字符串（C-string）的区别\nstring是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\\0字符C-stringC语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\\0结尾\n\n一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法c_str()实现string向char数组的转换。\nstring s = &quot;zenith&quot;;const char *s2 = s.c_str();\n\n函数方法\n获取字符串长度\n\n\n\n代码\n含义\n\n\n\ns.size()和s.length()\n返回string对象的字符个数，他们执行效果相同。\n\n\ns.max_size()\n返回string对象最多包含的字符数，超出会抛出length_error异常\n\n\ns.capacity()\n重新分配内存之前，string对象能包含的最大字符数\n\n\n\n插入\n\n\n\n代码\n含义\n\n\n\ns.push_back(element)\n在末尾插入\n\n\ns.insert(pos,element)\n在pos位置插入element\n\n\ns.append(str)\n在s字符串结尾添加str字符串\n\n\n例\n\n\n\n代码\n含义\n\n\n\ns.push_back(‘a’)\n末尾插入一个字符a\n\n\ns.insert(s.begin(),’1’)\n在第一个位置插入1字符\n\n\ns.append(“abc”)\n在s字符串末尾添加字符串“abc”\n\n\n\n删除\n\n\n\n代码\n含义\n\n\n\nerase(iterator p)\n删除字符串中p所指的字符\n\n\nerase(iterator first, iterator last)\n删除字符串中迭代器区间[first,last)上所有字符\n\n\nerase(pos, len)\n删除字符串中从索引位置pos开始的len个字符\n\n\nclear()\n删除字符串中所有字符\n\n\n\n字符替换\n\n\n\n代码\n含义\n\n\n\ns.replace(pos,n,str)\n把当前字符串从索引pos开始的n个字符替换为str\n\n\ns.replace(pos,n,n1,c)\n把当前字符串从索引pos开始的n个字符替换为n1个字符c\n\n\ns.replace(it1,it2,str)\n把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器（iterator）\n\n\n\n大小写转换\n法一：\n\n\n\n代码\n含义\n\n\n\ntolower(s[i])\n转换为小写\n\n\ntoupper(s[i])\n转换为大写\n\n\n法二：\n通过stl的transform算法配合tolower 和toupper 实现。有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。\nstring s;transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写\n\n分割\n\n\n\n代码\n含义\n\n\n\ns.substr(pos,n)\n截取从pos索引开始的n个字符\n\n\n\n查找\n\n\n\n代码\n含义\n\n\n\ns.find (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串\n\n\ns.find (c, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.rfind (str, pos)\n在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串\n\n\ns.rfind (c,pos)\n在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_of (str, pos)\n在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_first_not_of (str,pos)\n在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_of(str, pos)\n在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符\n\n\ns.find_last_not_of ( str, pos)\n在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串\n\n\n#include&lt;string&gt;#include&lt;iostream&gt;int main() &#123;    string s(&quot;dog bird chicken bird cat&quot;);//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标    cout &lt;&lt; s.find(&#x27;i&#x27;,6) &lt;&lt; endl;// 结果是：11    // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9    // 4. 从字符串的末尾开始查找字符    cout &lt;&lt; s.rfind(&#x27;i&#x27;) &lt;&lt; endl;// 结果是：18 因为是从末尾开始查找，所以返回第一次找到的字符    // 5. 在该字符串中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b    // 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9    // 7. 在该字符串最后中查找第一个属于字符串s的字符    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21&#125;\n\n排序\nsort(s.begin(),s.end());  //按ASCII码排序\n\nbitset介绍bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间\n\n头文件\n//头文件#include&lt;bitset&gt;\n\n初始化定义\n初始化方法\nbitset&lt;n&gt; a;//a有n位，每位都为0bitset&lt;n&gt; a(b);//a是unsigned long型b的一个二进制副本bitset&lt;n&gt; a(s);//a是string对象s中含有的位串的副本bitset&lt;n&gt; a(s,pos,n);//a是s中从位置pos开始的n个位的副本\n\n\n注意：n必须为常量表达式\n\n演示代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;\tbitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为0bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用0补充string s = &quot;100101&quot;;bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用0补充char s2[] = &quot;10101&quot;;bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用0补充cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101return 0;&#125;\n特性bitset可以进行位操作\nbitset&lt;4&gt; foo (string(&quot;1001&quot;));bitset&lt;4&gt; bar (string(&quot;0011&quot;));cout &lt;&lt; (foo^=bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;// 0001 (按位与后赋值给foo)cout &lt;&lt; (foo|=bar) &lt;&lt; endl;// 1011 (按位或后赋值给foo)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; endl;// 0100 (左移2位，低位补0，有自身赋值)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; endl;// 0100 (右移1位，高位补0，有自身赋值)cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; endl;// 0110 (左移，不赋值)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; endl;// 0001 (右移，不赋值)cout &lt;&lt; (foo==bar) &lt;&lt; endl;// false (1001==0011为false)cout &lt;&lt; (foo!=bar) &lt;&lt; endl;// true  (1001!=0011为true)cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;// 0001 (按位与，不赋值)cout &lt;&lt; (foo|bar) &lt;&lt; endl;// 1011 (按位或，不赋值)cout &lt;&lt; (foo^bar) &lt;&lt; endl;// 1010 (按位异或，不赋值)\n\n访问\n//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：bitset&lt;4&gt; foo (&quot;1011&quot;); cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1cout &lt;&lt; foo[1] &lt;&lt; endl;　　//0cout &lt;&lt; foo[2] &lt;&lt; endl;　　//1\n\n方法函数\n\n\n代码\n含义\n\n\n\nb.any()\nb中是否存在置为1的二进制位，有 返回true\n\n\nb.none()\nb中是否没有1，没有 返回true\n\n\nb.count()\nb中为1的个数\n\n\nb.size()\nb中二进制位的个数\n\n\nb.test(pos)\n测试b在pos位置是否为1，是 返回true\n\n\nb[pos]\n返回b在pos处的二进制位\n\n\nb.set()\n把b中所有位都置为1\n\n\nb.set(pos)\n把b中pos位置置为1\n\n\nb.reset()\n把b中所有位都置为0\n\n\nb.reset(pos)\n把b中pos位置置为0\n\n\nb.flip()\n把b中所有二进制位取反\n\n\nb.flip(pos)\n把b中pos位置取反\n\n\nb.to_ulong()\n用b中同样的二进制位返回一个unsigned long值\n\n\narray 数组介绍\n头文件\n#include&lt;array&gt;\n\narray是C++11新增的容器，效率与普通数据相差无几，比vector效率要高，自身添加了一些成员函数。\n和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，只允许访问或者替换存储的元素。\n注意：\narray的使用要在std命名空间里\n使用声明和初始化\n基础数据类型\n声明一个大小为100的int型数组，元素的值不确定\narray&lt;int, 100&gt; a;\n\n声明一个大小为100的int型数组，初始值均为0(初始值与默认元素类型等效)\narray&lt;int, 100&gt; a&#123;&#125;;\n声明一个大小为100的int型数组，初始化部分值，其余全部为0\narray&lt;int, 100&gt; a&#123;1, 2, 3&#125;;\n或者可以用等号\narray&lt;int, 100&gt; a = &#123;1, 2, 3&#125;;\n\n高级数据类型不同于数组的是对元素类型不做要求，可以套结构体\narray&lt;string, 2&gt; s = &#123;&quot;ha&quot;, string(&quot;haha&quot;)&#125;;array&lt;node, 2&gt; a;\n\n取存元素值\n修改元素\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;a[0] = 4;\n\n访问元素\n下标访问\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++)     cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];\n\n利用auto访问\nfor(auto i : a)    cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\n迭代器访问\nauto it = a.begin();for(; it != a.end(); it++)     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\nat()函数访问\n//下标为1的元素 加上 下标为2的元素，答案为5array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nget方法访问\n//将a数组下标为1位置处的值改为xget&lt;1&gt;(a) = x;//注意 获取的下标只能写数字，不能填变量\n\n成员函数\n\n\n成员函数\n功能\n\n\n\nbegin()\n返回容器中第一个元素的访问迭代器（地址）\n\n\nend()\n返回容器最后一个元素后一个位置的访问迭代器（地址）\n\n\nrbegin()\n返回最后一个元素的访问迭代器（地址）\n\n\nrend()\n返回第一个元素前一个位置的访问迭代器（地址）\n\n\nsize()\n返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数N\n\n\nmax_size()\n返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N\n\n\nempty()\n判断容器是否为空\n\n\nat(n)\n返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常\n\n\nfront()\n返回容器中第一个元素的直接引用，函数不适用于空的 array 容器\n\n\nback()\n返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。\n\n\ndata()\n返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能\n\n\nfill(x)\n将 x 这个值赋值给容器中的每个元素,相当于初始化\n\n\narray1.swap(array2)\n交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型\n\n\n部分用法示例data()指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。\nat()下标为1的元素加上下标为2的元素，答案为5\narray&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n\nfill()array的fill()函数，将a数组全部元素值变为x\na.fill(x);\n\n另外还有其它的fill()函数:将a数组[begin,end)全部值变为x\nfill(a.begin(), a.end(), x);\n\nget方法获取元素值将a数组下标为1位置处的值改为x\n注意 获取的下标只能写数字，不能填变量\nget&lt;1&gt;(a) = x;\n\n排序sort(a.begin(), a.end());\n\ntuple 元组介绍tuple模板是pair的泛化，可以封装不同类型任意数量的对象。\n可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。\ntuple可以等价为结构体使用\n\n头文件\n#include&lt;tuple&gt;\n\n基础用法声明及初始化\n声明一个空的tuple三元组\ntuple&lt;int, int, string&gt; t1;\n\n赋值\nt1 = make_tuple(1, 1, &quot;hahaha&quot;);\n\n创建的同时初始化\ntuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);\n\n可以使用pair对象构造tuple对象，但tuple对象必须是两个元素\nauto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象\n\n元素操作\n获取tuple对象t的第一个元素\nint first = get&lt;0&gt;(t);\n修改tuple对象t的第一个元素\nget&lt;0&gt;(t) = 1;\n\n函数操作\n获取元素个数\ntuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3\n\n获取对应元素的值\n//通过`get&lt;n&gt;(obj)`方法获取,`n`必须为数字不能是变量tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 1cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 2cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#x27;\\n&#x27;; // 3\n\n通过tie解包 获取元素值\n//tie可以让tuple变量中的三个值依次赋到tie中的三个变量中int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3\n\n\n后记stl 的总结就到这里先结束了，也算是按时提前完成此次任务了吧\n后续应该会补充一些其他常用的函数，例如 sort 等\n","categories":["学习"],"tags":["算法","知识总结"]}]